// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: identity_service/identity.v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Appelis_Identity_V1_CreateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Appelis_Identity_V1_CreateRequest.OneOf_Payload? = nil

  public var credentials: Appelis_Identity_V1_CreateRequest.Credentials {
    get {
      if case .credentials(let v)? = payload {return v}
      return Appelis_Identity_V1_CreateRequest.Credentials()
    }
    set {payload = .credentials(newValue)}
  }

  public var appKey: String {
    get {
      if case .appKey(let v)? = payload {return v}
      return String()
    }
    set {payload = .appKey(newValue)}
  }

  public var loginToken: Appelis_Identity_V1_CreateRequest.ProjectUserLoginToken {
    get {
      if case .loginToken(let v)? = payload {return v}
      return Appelis_Identity_V1_CreateRequest.ProjectUserLoginToken()
    }
    set {payload = .loginToken(newValue)}
  }

  public var deviceKey: Appelis_Identity_V1_CreateRequest.DeviceKey {
    get {
      if case .deviceKey(let v)? = payload {return v}
      return Appelis_Identity_V1_CreateRequest.DeviceKey()
    }
    set {payload = .deviceKey(newValue)}
  }

  public var defaultLoginToken: Appelis_Identity_V1_CreateRequest.UserLoginToken {
    get {
      if case .defaultLoginToken(let v)? = payload {return v}
      return Appelis_Identity_V1_CreateRequest.UserLoginToken()
    }
    set {payload = .defaultLoginToken(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case credentials(Appelis_Identity_V1_CreateRequest.Credentials)
    case appKey(String)
    case loginToken(Appelis_Identity_V1_CreateRequest.ProjectUserLoginToken)
    case deviceKey(Appelis_Identity_V1_CreateRequest.DeviceKey)
    case defaultLoginToken(Appelis_Identity_V1_CreateRequest.UserLoginToken)

  #if !swift(>=4.1)
    public static func ==(lhs: Appelis_Identity_V1_CreateRequest.OneOf_Payload, rhs: Appelis_Identity_V1_CreateRequest.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.credentials, .credentials): return {
        guard case .credentials(let l) = lhs, case .credentials(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appKey, .appKey): return {
        guard case .appKey(let l) = lhs, case .appKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loginToken, .loginToken): return {
        guard case .loginToken(let l) = lhs, case .loginToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deviceKey, .deviceKey): return {
        guard case .deviceKey(let l) = lhs, case .deviceKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.defaultLoginToken, .defaultLoginToken): return {
        guard case .defaultLoginToken(let l) = lhs, case .defaultLoginToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// used to login user without project
  public struct Credentials {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var username: String = String()

    public var pass: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Used by phones to generate token for device
  public struct DeviceKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var appKey: String = String()

    public var deviceUuid: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// user by logged web user to get token for project
  public struct ProjectUserLoginToken {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var loginToken: String = String()

    public var projectID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// used by jobs to get token for "default" customer. As claim will be used project id of user connected to token.
  public struct UserLoginToken {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var loginToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Appelis_Identity_V1_CreateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Appelis_Identity_V1_CreateResponse.OneOf_Payload? = nil

  public var data: Appelis_Identity_V1_TokenPayload {
    get {
      if case .data(let v)? = payload {return v}
      return Appelis_Identity_V1_TokenPayload()
    }
    set {payload = .data(newValue)}
  }

  public var error: Appelis_Identity_V1_CreateResponse.Error {
    get {
      if case .error(let v)? = payload {return v}
      return .unspecified
    }
    set {payload = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case data(Appelis_Identity_V1_TokenPayload)
    case error(Appelis_Identity_V1_CreateResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Appelis_Identity_V1_CreateResponse.OneOf_Payload, rhs: Appelis_Identity_V1_CreateResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case wrongPayload // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .wrongPayload
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .wrongPayload: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Appelis_Identity_V1_CreateResponse.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_Identity_V1_CreateResponse.Error] = [
    .unspecified,
    .wrongPayload,
  ]
}

#endif  // swift(>=4.2)

public struct Appelis_Identity_V1_RefreshRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var refreshToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_Identity_V1_RefreshResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Appelis_Identity_V1_RefreshResponse.OneOf_Payload? = nil

  public var data: Appelis_Identity_V1_TokenPayload {
    get {
      if case .data(let v)? = payload {return v}
      return Appelis_Identity_V1_TokenPayload()
    }
    set {payload = .data(newValue)}
  }

  public var error: Appelis_Identity_V1_RefreshResponse.Error {
    get {
      if case .error(let v)? = payload {return v}
      return .unspecified
    }
    set {payload = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case data(Appelis_Identity_V1_TokenPayload)
    case error(Appelis_Identity_V1_RefreshResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Appelis_Identity_V1_RefreshResponse.OneOf_Payload, rhs: Appelis_Identity_V1_RefreshResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case invalidToken // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .invalidToken
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .invalidToken: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Appelis_Identity_V1_RefreshResponse.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_Identity_V1_RefreshResponse.Error] = [
    .unspecified,
    .invalidToken,
  ]
}

#endif  // swift(>=4.2)

public struct Appelis_Identity_V1_TokenPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var refreshToken: String = String()

  public var accessToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Appelis_Identity_V1_CreateRequest: @unchecked Sendable {}
extension Appelis_Identity_V1_CreateRequest.OneOf_Payload: @unchecked Sendable {}
extension Appelis_Identity_V1_CreateRequest.Credentials: @unchecked Sendable {}
extension Appelis_Identity_V1_CreateRequest.DeviceKey: @unchecked Sendable {}
extension Appelis_Identity_V1_CreateRequest.ProjectUserLoginToken: @unchecked Sendable {}
extension Appelis_Identity_V1_CreateRequest.UserLoginToken: @unchecked Sendable {}
extension Appelis_Identity_V1_CreateResponse: @unchecked Sendable {}
extension Appelis_Identity_V1_CreateResponse.OneOf_Payload: @unchecked Sendable {}
extension Appelis_Identity_V1_CreateResponse.Error: @unchecked Sendable {}
extension Appelis_Identity_V1_RefreshRequest: @unchecked Sendable {}
extension Appelis_Identity_V1_RefreshResponse: @unchecked Sendable {}
extension Appelis_Identity_V1_RefreshResponse.OneOf_Payload: @unchecked Sendable {}
extension Appelis_Identity_V1_RefreshResponse.Error: @unchecked Sendable {}
extension Appelis_Identity_V1_TokenPayload: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "appelis.identity.v1"

extension Appelis_Identity_V1_CreateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "credentials"),
    2: .same(proto: "appKey"),
    3: .same(proto: "loginToken"),
    4: .same(proto: "deviceKey"),
    5: .same(proto: "defaultLoginToken"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_V1_CreateRequest.Credentials?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .credentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .credentials(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .appKey(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_V1_CreateRequest.ProjectUserLoginToken?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .loginToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .loginToken(v)
        }
      }()
      case 4: try {
        var v: Appelis_Identity_V1_CreateRequest.DeviceKey?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .deviceKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .deviceKey(v)
        }
      }()
      case 5: try {
        var v: Appelis_Identity_V1_CreateRequest.UserLoginToken?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .defaultLoginToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .defaultLoginToken(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .credentials?: try {
      guard case .credentials(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .appKey?: try {
      guard case .appKey(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .loginToken?: try {
      guard case .loginToken(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deviceKey?: try {
      guard case .deviceKey(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .defaultLoginToken?: try {
      guard case .defaultLoginToken(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Identity_V1_CreateRequest, rhs: Appelis_Identity_V1_CreateRequest) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Identity_V1_CreateRequest.Credentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_Identity_V1_CreateRequest.protoMessageName + ".Credentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "pass"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pass) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.pass.isEmpty {
      try visitor.visitSingularStringField(value: self.pass, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Identity_V1_CreateRequest.Credentials, rhs: Appelis_Identity_V1_CreateRequest.Credentials) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.pass != rhs.pass {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Identity_V1_CreateRequest.DeviceKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_Identity_V1_CreateRequest.protoMessageName + ".DeviceKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appKey"),
    2: .same(proto: "deviceUuid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.appKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.appKey.isEmpty {
      try visitor.visitSingularStringField(value: self.appKey, fieldNumber: 1)
    }
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Identity_V1_CreateRequest.DeviceKey, rhs: Appelis_Identity_V1_CreateRequest.DeviceKey) -> Bool {
    if lhs.appKey != rhs.appKey {return false}
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Identity_V1_CreateRequest.ProjectUserLoginToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_Identity_V1_CreateRequest.protoMessageName + ".ProjectUserLoginToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "loginToken"),
    2: .same(proto: "projectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.loginToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.loginToken.isEmpty {
      try visitor.visitSingularStringField(value: self.loginToken, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Identity_V1_CreateRequest.ProjectUserLoginToken, rhs: Appelis_Identity_V1_CreateRequest.ProjectUserLoginToken) -> Bool {
    if lhs.loginToken != rhs.loginToken {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Identity_V1_CreateRequest.UserLoginToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_Identity_V1_CreateRequest.protoMessageName + ".UserLoginToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "loginToken"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.loginToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.loginToken.isEmpty {
      try visitor.visitSingularStringField(value: self.loginToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Identity_V1_CreateRequest.UserLoginToken, rhs: Appelis_Identity_V1_CreateRequest.UserLoginToken) -> Bool {
    if lhs.loginToken != rhs.loginToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Identity_V1_CreateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_V1_TokenPayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      case 2: try {
        var v: Appelis_Identity_V1_CreateResponse.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Identity_V1_CreateResponse, rhs: Appelis_Identity_V1_CreateResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Identity_V1_CreateResponse.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "WRONG_PAYLOAD"),
  ]
}

extension Appelis_Identity_V1_RefreshRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "refreshToken"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Identity_V1_RefreshRequest, rhs: Appelis_Identity_V1_RefreshRequest) -> Bool {
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Identity_V1_RefreshResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_V1_TokenPayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      case 2: try {
        var v: Appelis_Identity_V1_RefreshResponse.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Identity_V1_RefreshResponse, rhs: Appelis_Identity_V1_RefreshResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Identity_V1_RefreshResponse.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "INVALID_TOKEN"),
  ]
}

extension Appelis_Identity_V1_TokenPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "refreshToken"),
    2: .same(proto: "accessToken"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.refreshToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accessToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refreshToken.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshToken, fieldNumber: 1)
    }
    if !self.accessToken.isEmpty {
      try visitor.visitSingularStringField(value: self.accessToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Identity_V1_TokenPayload, rhs: Appelis_Identity_V1_TokenPayload) -> Bool {
    if lhs.refreshToken != rhs.refreshToken {return false}
    if lhs.accessToken != rhs.accessToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
