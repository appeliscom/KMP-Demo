// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: wallet/wallet.data.v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Metro_Wallet_Data_V1_FundActivityType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownActivityType // = 0
  case credited // = 1
  case spending // = 2
  case expiration // = 3
  case correction // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownActivityType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownActivityType
    case 1: self = .credited
    case 2: self = .spending
    case 3: self = .expiration
    case 4: self = .correction
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownActivityType: return 0
    case .credited: return 1
    case .spending: return 2
    case .expiration: return 3
    case .correction: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Wallet_Data_V1_FundActivityType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Wallet_Data_V1_FundActivityType] = [
    .unknownActivityType,
    .credited,
    .spending,
    .expiration,
    .correction,
  ]
}

#endif  // swift(>=4.2)

public enum Metro_Wallet_Data_V1_WalletFundType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownFundType // = 0
  case mania // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownFundType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownFundType
    case 1: self = .mania
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownFundType: return 0
    case .mania: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Wallet_Data_V1_WalletFundType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Wallet_Data_V1_WalletFundType] = [
    .unknownFundType,
    .mania,
  ]
}

#endif  // swift(>=4.2)

public enum Metro_Wallet_Data_V1_SpendResultError: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownSpendResult // = 0
  case insufficientFunds // = 1
  case businessNotFound // = 2
  case fundNotFound // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownSpendResult
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownSpendResult
    case 1: self = .insufficientFunds
    case 2: self = .businessNotFound
    case 3: self = .fundNotFound
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownSpendResult: return 0
    case .insufficientFunds: return 1
    case .businessNotFound: return 2
    case .fundNotFound: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Wallet_Data_V1_SpendResultError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Wallet_Data_V1_SpendResultError] = [
    .unknownSpendResult,
    .insufficientFunds,
    .businessNotFound,
    .fundNotFound,
  ]
}

#endif  // swift(>=4.2)

public enum Metro_Wallet_Data_V1_SpendingReportOutputFormat: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownSpendingReportOutputFormat // = 0
  case csv // = 1
  case rows // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownSpendingReportOutputFormat
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownSpendingReportOutputFormat
    case 1: self = .csv
    case 2: self = .rows
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownSpendingReportOutputFormat: return 0
    case .csv: return 1
    case .rows: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Wallet_Data_V1_SpendingReportOutputFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Wallet_Data_V1_SpendingReportOutputFormat] = [
    .unknownSpendingReportOutputFormat,
    .csv,
    .rows,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Wallet_Data_V1_FundExpiration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: UInt32 = 0

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Wallet_Data_V1_FundActivity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: Metro_Wallet_Data_V1_FundActivityType = .unknownActivityType

  public var fundName: String = String()

  public var amount: Int64 = 0

  public var user: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _user ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var business: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _business ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_business = newValue}
  }
  /// Returns true if `business` has been explicitly set.
  public var hasBusiness: Bool {return self._business != nil}
  /// Clears the value of `business`. Subsequent reads from it will return its default value.
  public mutating func clearBusiness() {self._business = nil}

  public var idCashRegister: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _idCashRegister ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_idCashRegister = newValue}
  }
  /// Returns true if `idCashRegister` has been explicitly set.
  public var hasIDCashRegister: Bool {return self._idCashRegister != nil}
  /// Clears the value of `idCashRegister`. Subsequent reads from it will return its default value.
  public mutating func clearIDCashRegister() {self._idCashRegister = nil}

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expirationDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expirationDate = newValue}
  }
  /// Returns true if `expirationDate` has been explicitly set.
  public var hasExpirationDate: Bool {return self._expirationDate != nil}
  /// Clears the value of `expirationDate`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationDate() {self._expirationDate = nil}

  public var cursor: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _business: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _idCashRegister: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expirationDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Wallet_Data_V1_WalletFund {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var type: Metro_Wallet_Data_V1_WalletFundType = .unknownFundType

  public var name: String = String()

  public var balance: Float = 0

  public var expiration: [Metro_Wallet_Data_V1_FundExpiration] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Wallet_Data_V1_WalletOverview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var totalBalance: Float = 0

  public var funds: [Metro_Wallet_Data_V1_WalletFund] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Wallet_Data_V1_SpendResultData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fundName: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _fundName ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_fundName = newValue}
  }
  /// Returns true if `fundName` has been explicitly set.
  public var hasFundName: Bool {return self._fundName != nil}
  /// Clears the value of `fundName`. Subsequent reads from it will return its default value.
  public mutating func clearFundName() {self._fundName = nil}

  public var amount: UInt32 = 0

  public var business: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _business ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_business = newValue}
  }
  /// Returns true if `business` has been explicitly set.
  public var hasBusiness: Bool {return self._business != nil}
  /// Clears the value of `business`. Subsequent reads from it will return its default value.
  public mutating func clearBusiness() {self._business = nil}

  public var idCashRegister: String = String()

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fundName: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _business: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Wallet_Data_V1_SpendingsReportRow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idCompanyExt: String = String()

  public var idBusinessExt: String = String()

  public var idCardholder: String = String()

  public var amount: UInt32 = 0

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var business: String = String()

  public var idCashRegister: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Metro_Wallet_Data_V1_FundActivityType: @unchecked Sendable {}
extension Metro_Wallet_Data_V1_WalletFundType: @unchecked Sendable {}
extension Metro_Wallet_Data_V1_SpendResultError: @unchecked Sendable {}
extension Metro_Wallet_Data_V1_SpendingReportOutputFormat: @unchecked Sendable {}
extension Metro_Wallet_Data_V1_FundExpiration: @unchecked Sendable {}
extension Metro_Wallet_Data_V1_FundActivity: @unchecked Sendable {}
extension Metro_Wallet_Data_V1_WalletFund: @unchecked Sendable {}
extension Metro_Wallet_Data_V1_WalletOverview: @unchecked Sendable {}
extension Metro_Wallet_Data_V1_SpendResultData: @unchecked Sendable {}
extension Metro_Wallet_Data_V1_SpendingsReportRow: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "metro.wallet.data.v1"

extension Metro_Wallet_Data_V1_FundActivityType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_ACTIVITY_TYPE"),
    1: .same(proto: "CREDITED"),
    2: .same(proto: "SPENDING"),
    3: .same(proto: "EXPIRATION"),
    4: .same(proto: "CORRECTION"),
  ]
}

extension Metro_Wallet_Data_V1_WalletFundType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_FUND_TYPE"),
    1: .same(proto: "MANIA"),
  ]
}

extension Metro_Wallet_Data_V1_SpendResultError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SPEND_RESULT"),
    1: .same(proto: "INSUFFICIENT_FUNDS"),
    2: .same(proto: "BUSINESS_NOT_FOUND"),
    3: .same(proto: "FUND_NOT_FOUND"),
  ]
}

extension Metro_Wallet_Data_V1_SpendingReportOutputFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SPENDING_REPORT_OUTPUT_FORMAT"),
    1: .same(proto: "CSV"),
    2: .same(proto: "ROWS"),
  ]
}

extension Metro_Wallet_Data_V1_FundExpiration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FundExpiration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.value) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.value != 0 {
      try visitor.visitSingularUInt32Field(value: self.value, fieldNumber: 1)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Wallet_Data_V1_FundExpiration, rhs: Metro_Wallet_Data_V1_FundExpiration) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Wallet_Data_V1_FundActivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FundActivity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .standard(proto: "fund_name"),
    4: .same(proto: "amount"),
    5: .same(proto: "user"),
    6: .same(proto: "business"),
    7: .standard(proto: "id_cash_register"),
    8: .same(proto: "date"),
    9: .standard(proto: "expiration_date"),
    10: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fundName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._business) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._idCashRegister) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._expirationDate) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .unknownActivityType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.fundName.isEmpty {
      try visitor.visitSingularStringField(value: self.fundName, fieldNumber: 3)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 4)
    }
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._business {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._idCashRegister {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._expirationDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Wallet_Data_V1_FundActivity, rhs: Metro_Wallet_Data_V1_FundActivity) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.fundName != rhs.fundName {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._user != rhs._user {return false}
    if lhs._business != rhs._business {return false}
    if lhs._idCashRegister != rhs._idCashRegister {return false}
    if lhs._date != rhs._date {return false}
    if lhs._expirationDate != rhs._expirationDate {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Wallet_Data_V1_WalletFund: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WalletFund"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .same(proto: "balance"),
    5: .same(proto: "expiration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.balance) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.expiration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.type != .unknownFundType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.balance != 0 {
      try visitor.visitSingularFloatField(value: self.balance, fieldNumber: 4)
    }
    if !self.expiration.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.expiration, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Wallet_Data_V1_WalletFund, rhs: Metro_Wallet_Data_V1_WalletFund) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.balance != rhs.balance {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Wallet_Data_V1_WalletOverview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WalletOverview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_balance"),
    2: .same(proto: "funds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.totalBalance) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.funds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalBalance != 0 {
      try visitor.visitSingularFloatField(value: self.totalBalance, fieldNumber: 1)
    }
    if !self.funds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.funds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Wallet_Data_V1_WalletOverview, rhs: Metro_Wallet_Data_V1_WalletOverview) -> Bool {
    if lhs.totalBalance != rhs.totalBalance {return false}
    if lhs.funds != rhs.funds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Wallet_Data_V1_SpendResultData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpendResultData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fund_name"),
    2: .same(proto: "amount"),
    3: .same(proto: "business"),
    4: .standard(proto: "id_cash_register"),
    5: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fundName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._business) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.idCashRegister) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fundName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.amount != 0 {
      try visitor.visitSingularUInt32Field(value: self.amount, fieldNumber: 2)
    }
    try { if let v = self._business {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.idCashRegister.isEmpty {
      try visitor.visitSingularStringField(value: self.idCashRegister, fieldNumber: 4)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Wallet_Data_V1_SpendResultData, rhs: Metro_Wallet_Data_V1_SpendResultData) -> Bool {
    if lhs._fundName != rhs._fundName {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._business != rhs._business {return false}
    if lhs.idCashRegister != rhs.idCashRegister {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Wallet_Data_V1_SpendingsReportRow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpendingsReportRow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_company_ext"),
    2: .standard(proto: "id_business_ext"),
    3: .standard(proto: "id_cardholder"),
    4: .same(proto: "amount"),
    5: .same(proto: "date"),
    6: .same(proto: "business"),
    7: .standard(proto: "id_cash_register"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idCompanyExt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.idBusinessExt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.idCardholder) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.business) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.idCashRegister) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.idCompanyExt.isEmpty {
      try visitor.visitSingularStringField(value: self.idCompanyExt, fieldNumber: 1)
    }
    if !self.idBusinessExt.isEmpty {
      try visitor.visitSingularStringField(value: self.idBusinessExt, fieldNumber: 2)
    }
    if !self.idCardholder.isEmpty {
      try visitor.visitSingularStringField(value: self.idCardholder, fieldNumber: 3)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt32Field(value: self.amount, fieldNumber: 4)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.business.isEmpty {
      try visitor.visitSingularStringField(value: self.business, fieldNumber: 6)
    }
    if !self.idCashRegister.isEmpty {
      try visitor.visitSingularStringField(value: self.idCashRegister, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Wallet_Data_V1_SpendingsReportRow, rhs: Metro_Wallet_Data_V1_SpendingsReportRow) -> Bool {
    if lhs.idCompanyExt != rhs.idCompanyExt {return false}
    if lhs.idBusinessExt != rhs.idBusinessExt {return false}
    if lhs.idCardholder != rhs.idCardholder {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs._date != rhs._date {return false}
    if lhs.business != rhs.business {return false}
    if lhs.idCashRegister != rhs.idCashRegister {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
