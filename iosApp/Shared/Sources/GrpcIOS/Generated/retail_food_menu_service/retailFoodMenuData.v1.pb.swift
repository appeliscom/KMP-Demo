// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: retail_food_menu_service/retailFoodMenuData.v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Appelis_Retail_Menu_Data_V1_MealExtras {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var extras: [Appelis_Retail_Menu_Data_V1_MealExtras.Extra] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Extra {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var translationKey: String = String()

    public var mealIds: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Appelis_Retail_Menu_Data_V1_Settings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var timeranges: Dictionary<String,Appelis_TimeRange> = [:]

  public var mealGroups: Dictionary<String,Appelis_Retail_Menu_Data_V1_SettingsMealGroup> = [:]

  public var menuBlocks: Dictionary<String,Int32> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
}

public struct Appelis_Retail_Menu_Data_V1_SettingsMealGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mealGroups: Dictionary<String,Int32> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_Retail_Menu_Data_V1_MenuTimerangeInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timerange: Dictionary<String,Appelis_TimeRange> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_Retail_Menu_Data_V1_MenuTimerange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var translationKey: String = String()

  public var timerange: Appelis_TimeRange {
    get {return _timerange ?? Appelis_TimeRange()}
    set {_timerange = newValue}
  }
  /// Returns true if `timerange` has been explicitly set.
  public var hasTimerange: Bool {return self._timerange != nil}
  /// Clears the value of `timerange`. Subsequent reads from it will return its default value.
  public mutating func clearTimerange() {self._timerange = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timerange: Appelis_TimeRange? = nil
}

public struct Appelis_Retail_Menu_Data_V1_Menu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Utorok 16.11 ...
  public var day: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _day ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_day = newValue}
  }
  /// Returns true if `day` has been explicitly set.
  public var hasDay: Bool {return self._day != nil}
  /// Clears the value of `day`. Subsequent reads from it will return its default value.
  public mutating func clearDay() {self._day = nil}

  /// breakfast, lunch, dinner...
  public var dayTimeGroups: Dictionary<String,Appelis_Retail_Menu_Data_V1_DayTimeGroup> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _day: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Appelis_Retail_Menu_Data_V1_DayMenu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// Utorok 16.11 ...
  public var day: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _day ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_day = newValue}
  }
  /// Returns true if `day` has been explicitly set.
  public var hasDay: Bool {return self._day != nil}
  /// Clears the value of `day`. Subsequent reads from it will return its default value.
  public mutating func clearDay() {self._day = nil}

  /// breakfast, lunch, dinner...
  public var dayTimeGroups: Dictionary<String,Appelis_Retail_Menu_Data_V1_DayTimeGroup> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _day: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Appelis_Retail_Menu_Data_V1_SourceMenuListItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var active: Bool = false

  public var translationKey: String = String()

  /// Utorok 16.11 ...
  public var timerange: Appelis_TimeRange {
    get {return _timerange ?? Appelis_TimeRange()}
    set {_timerange = newValue}
  }
  /// Returns true if `timerange` has been explicitly set.
  public var hasTimerange: Bool {return self._timerange != nil}
  /// Clears the value of `timerange`. Subsequent reads from it will return its default value.
  public mutating func clearTimerange() {self._timerange = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _timerange: Appelis_TimeRange? = nil
}

public struct Appelis_Retail_Menu_Data_V1_SourceMenu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var active: Bool = false

  public var translationKey: String = String()

  /// Utorok 16.11 ...
  public var timerange: Appelis_TimeRange {
    get {return _timerange ?? Appelis_TimeRange()}
    set {_timerange = newValue}
  }
  /// Returns true if `timerange` has been explicitly set.
  public var hasTimerange: Bool {return self._timerange != nil}
  /// Clears the value of `timerange`. Subsequent reads from it will return its default value.
  public mutating func clearTimerange() {self._timerange = nil}

  /// breakfast, lunch, dinner...
  public var dayTimeGroups: Dictionary<String,Appelis_Retail_Menu_Data_V1_DayTimeGroup> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _timerange: Appelis_TimeRange? = nil
}

public struct Appelis_Retail_Menu_Data_V1_DayTimeGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var timerange: Appelis_TimeRange {
    get {return _timerange ?? Appelis_TimeRange()}
    set {_timerange = newValue}
  }
  /// Returns true if `timerange` has been explicitly set.
  public var hasTimerange: Bool {return self._timerange != nil}
  /// Clears the value of `timerange`. Subsequent reads from it will return its default value.
  public mutating func clearTimerange() {self._timerange = nil}

  /// daily menu, weekly Menu, weekend menu...
  public var menuBlocks: Dictionary<String,Appelis_Retail_Menu_Data_V1_MenuBlock> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timerange: Appelis_TimeRange? = nil
}

public struct Appelis_Retail_Menu_Data_V1_MenuBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// soups, main_dishes, desserts...
  public var mealGroups: Dictionary<String,Appelis_Retail_Menu_Data_V1_MealGroup> = [:]

  public var order: Int32 = 0

  public var timerange: Appelis_TimeRange {
    get {return _timerange ?? Appelis_TimeRange()}
    set {_timerange = newValue}
  }
  /// Returns true if `timerange` has been explicitly set.
  public var hasTimerange: Bool {return self._timerange != nil}
  /// Clears the value of `timerange`. Subsequent reads from it will return its default value.
  public mutating func clearTimerange() {self._timerange = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timerange: Appelis_TimeRange? = nil
}

public struct Appelis_Retail_Menu_Data_V1_MealGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// soup_1, soup_2...
  public var mealIds: [String] = []

  public var order: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_Retail_Menu_Data_V1_MenuInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// in day menu should be one day range, in weekly should be set to at least few days.
  public var timerange: Appelis_TimeRange {
    get {return _timerange ?? Appelis_TimeRange()}
    set {_timerange = newValue}
  }
  /// Returns true if `timerange` has been explicitly set.
  public var hasTimerange: Bool {return self._timerange != nil}
  /// Clears the value of `timerange`. Subsequent reads from it will return its default value.
  public mutating func clearTimerange() {self._timerange = nil}

  /// breakfast, lunch, dinner...
  public var dayTimeGroups: Dictionary<String,Appelis_Retail_Menu_Data_V1_DayTimeGroup> = [:]

  public var businessID: String = String()

  /// Denne menu, Tyzdenne menu, Vikendove menu...
  public var translationKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timerange: Appelis_TimeRange? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Appelis_Retail_Menu_Data_V1_MealExtras: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_MealExtras.Extra: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_Settings: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_SettingsMealGroup: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_MenuTimerangeInput: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_MenuTimerange: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_Menu: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_DayMenu: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_SourceMenuListItem: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_SourceMenu: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_DayTimeGroup: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_MenuBlock: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_MealGroup: @unchecked Sendable {}
extension Appelis_Retail_Menu_Data_V1_MenuInput: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "appelis.retail.menu.data.v1"

extension Appelis_Retail_Menu_Data_V1_MealExtras: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MealExtras"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "extras"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.extras) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.extras.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extras, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_MealExtras, rhs: Appelis_Retail_Menu_Data_V1_MealExtras) -> Bool {
    if lhs.extras != rhs.extras {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_MealExtras.Extra: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_Retail_Menu_Data_V1_MealExtras.protoMessageName + ".Extra"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "translation_key"),
    2: .standard(proto: "meal_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.translationKey) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.mealIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.translationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.translationKey, fieldNumber: 1)
    }
    if !self.mealIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mealIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_MealExtras.Extra, rhs: Appelis_Retail_Menu_Data_V1_MealExtras.Extra) -> Bool {
    if lhs.translationKey != rhs.translationKey {return false}
    if lhs.mealIds != rhs.mealIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Settings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "timeranges"),
    3: .standard(proto: "meal_groups"),
    4: .standard(proto: "menu_blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_TimeRange>.self, value: &self.timeranges) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_SettingsMealGroup>.self, value: &self.mealGroups) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.menuBlocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.timeranges.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_TimeRange>.self, value: self.timeranges, fieldNumber: 2)
    }
    if !self.mealGroups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_SettingsMealGroup>.self, value: self.mealGroups, fieldNumber: 3)
    }
    if !self.menuBlocks.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.menuBlocks, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_Settings, rhs: Appelis_Retail_Menu_Data_V1_Settings) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.timeranges != rhs.timeranges {return false}
    if lhs.mealGroups != rhs.mealGroups {return false}
    if lhs.menuBlocks != rhs.menuBlocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_SettingsMealGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SettingsMealGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meal_groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.mealGroups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mealGroups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.mealGroups, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_SettingsMealGroup, rhs: Appelis_Retail_Menu_Data_V1_SettingsMealGroup) -> Bool {
    if lhs.mealGroups != rhs.mealGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_MenuTimerangeInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MenuTimerangeInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timerange"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_TimeRange>.self, value: &self.timerange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timerange.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_TimeRange>.self, value: self.timerange, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_MenuTimerangeInput, rhs: Appelis_Retail_Menu_Data_V1_MenuTimerangeInput) -> Bool {
    if lhs.timerange != rhs.timerange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_MenuTimerange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MenuTimerange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "translation_key"),
    2: .same(proto: "timerange"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.translationKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timerange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.translationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.translationKey, fieldNumber: 1)
    }
    try { if let v = self._timerange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_MenuTimerange, rhs: Appelis_Retail_Menu_Data_V1_MenuTimerange) -> Bool {
    if lhs.translationKey != rhs.translationKey {return false}
    if lhs._timerange != rhs._timerange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_Menu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Menu"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "day"),
    2: .standard(proto: "day_time_groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._day) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_DayTimeGroup>.self, value: &self.dayTimeGroups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._day {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.dayTimeGroups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_DayTimeGroup>.self, value: self.dayTimeGroups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_Menu, rhs: Appelis_Retail_Menu_Data_V1_Menu) -> Bool {
    if lhs._day != rhs._day {return false}
    if lhs.dayTimeGroups != rhs.dayTimeGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_DayMenu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DayMenu"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "day"),
    3: .standard(proto: "day_time_groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._day) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_DayTimeGroup>.self, value: &self.dayTimeGroups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._day {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.dayTimeGroups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_DayTimeGroup>.self, value: self.dayTimeGroups, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_DayMenu, rhs: Appelis_Retail_Menu_Data_V1_DayMenu) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._day != rhs._day {return false}
    if lhs.dayTimeGroups != rhs.dayTimeGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_SourceMenuListItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceMenuListItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "active"),
    3: .standard(proto: "translation_key"),
    4: .same(proto: "timerange"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.translationKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timerange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 2)
    }
    if !self.translationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.translationKey, fieldNumber: 3)
    }
    try { if let v = self._timerange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_SourceMenuListItem, rhs: Appelis_Retail_Menu_Data_V1_SourceMenuListItem) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.active != rhs.active {return false}
    if lhs.translationKey != rhs.translationKey {return false}
    if lhs._timerange != rhs._timerange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_SourceMenu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceMenu"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "active"),
    3: .standard(proto: "translation_key"),
    4: .same(proto: "timerange"),
    5: .standard(proto: "day_time_groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.translationKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timerange) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_DayTimeGroup>.self, value: &self.dayTimeGroups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 2)
    }
    if !self.translationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.translationKey, fieldNumber: 3)
    }
    try { if let v = self._timerange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.dayTimeGroups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_DayTimeGroup>.self, value: self.dayTimeGroups, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_SourceMenu, rhs: Appelis_Retail_Menu_Data_V1_SourceMenu) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.active != rhs.active {return false}
    if lhs.translationKey != rhs.translationKey {return false}
    if lhs._timerange != rhs._timerange {return false}
    if lhs.dayTimeGroups != rhs.dayTimeGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_DayTimeGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DayTimeGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timerange"),
    2: .standard(proto: "menu_blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timerange) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_MenuBlock>.self, value: &self.menuBlocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timerange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.menuBlocks.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_MenuBlock>.self, value: self.menuBlocks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_DayTimeGroup, rhs: Appelis_Retail_Menu_Data_V1_DayTimeGroup) -> Bool {
    if lhs._timerange != rhs._timerange {return false}
    if lhs.menuBlocks != rhs.menuBlocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_MenuBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MenuBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meal_groups"),
    2: .same(proto: "order"),
    3: .same(proto: "timerange"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_MealGroup>.self, value: &self.mealGroups) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.order) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timerange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.mealGroups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_MealGroup>.self, value: self.mealGroups, fieldNumber: 1)
    }
    if self.order != 0 {
      try visitor.visitSingularInt32Field(value: self.order, fieldNumber: 2)
    }
    try { if let v = self._timerange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_MenuBlock, rhs: Appelis_Retail_Menu_Data_V1_MenuBlock) -> Bool {
    if lhs.mealGroups != rhs.mealGroups {return false}
    if lhs.order != rhs.order {return false}
    if lhs._timerange != rhs._timerange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_MealGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MealGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "meal_ids"),
    2: .same(proto: "order"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.mealIds) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.order) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mealIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.mealIds, fieldNumber: 1)
    }
    if self.order != 0 {
      try visitor.visitSingularInt32Field(value: self.order, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_MealGroup, rhs: Appelis_Retail_Menu_Data_V1_MealGroup) -> Bool {
    if lhs.mealIds != rhs.mealIds {return false}
    if lhs.order != rhs.order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Retail_Menu_Data_V1_MenuInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MenuInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timerange"),
    2: .standard(proto: "day_time_groups"),
    3: .standard(proto: "business_id"),
    4: .standard(proto: "translation_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timerange) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_DayTimeGroup>.self, value: &self.dayTimeGroups) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.businessID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.translationKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timerange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.dayTimeGroups.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Appelis_Retail_Menu_Data_V1_DayTimeGroup>.self, value: self.dayTimeGroups, fieldNumber: 2)
    }
    if !self.businessID.isEmpty {
      try visitor.visitSingularStringField(value: self.businessID, fieldNumber: 3)
    }
    if !self.translationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.translationKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Retail_Menu_Data_V1_MenuInput, rhs: Appelis_Retail_Menu_Data_V1_MenuInput) -> Bool {
    if lhs._timerange != rhs._timerange {return false}
    if lhs.dayTimeGroups != rhs.dayTimeGroups {return false}
    if lhs.businessID != rhs.businessID {return false}
    if lhs.translationKey != rhs.translationKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
