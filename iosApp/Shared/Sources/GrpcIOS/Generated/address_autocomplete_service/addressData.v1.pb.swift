// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: address_autocomplete_service/addressData.v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// If we need more type look here: https://developers.google.com/places/web-service/supported_types
public enum Appelis_Address_Autocomplete_V1_PlaceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case route // = 1
  case geocode // = 2

  /// ... Many more on google.apis
  case streetAddress // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .route
    case 2: self = .geocode
    case 3: self = .streetAddress
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .route: return 1
    case .geocode: return 2
    case .streetAddress: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Appelis_Address_Autocomplete_V1_PlaceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_Address_Autocomplete_V1_PlaceType] = [
    .unknown,
    .route,
    .geocode,
    .streetAddress,
  ]
}

#endif  // swift(>=4.2)

public struct Appelis_Address_Autocomplete_V1_AutoCompleteResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var description_p: String = String()

  public var placeID: String = String()

  public var structuredFormatting: Appelis_Address_Autocomplete_V1_StructuredFormatting {
    get {return _structuredFormatting ?? Appelis_Address_Autocomplete_V1_StructuredFormatting()}
    set {_structuredFormatting = newValue}
  }
  /// Returns true if `structuredFormatting` has been explicitly set.
  public var hasStructuredFormatting: Bool {return self._structuredFormatting != nil}
  /// Clears the value of `structuredFormatting`. Subsequent reads from it will return its default value.
  public mutating func clearStructuredFormatting() {self._structuredFormatting = nil}

  public var type: [Appelis_Address_Autocomplete_V1_PlaceType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _structuredFormatting: Appelis_Address_Autocomplete_V1_StructuredFormatting? = nil
}

/// Provides pre-formatted text that can be shown in your autocomplete results, and contains the following subfields:
public struct Appelis_Address_Autocomplete_V1_StructuredFormatting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains the main text of a prediction, usually the name of the place.
  public var mainText: String = String()

  /// Contains the secondary text of a prediction, usually the location of the place.
  public var secondaryText: String = String()

  /// Contains an array with offset value and length.
  /// These describe the location of the entered term in the prediction result text, so that the term can be highlighted if desired.
  public var mainTextMatchedSubstrings: [Appelis_Address_Autocomplete_V1_SubStringMatch] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_Address_Autocomplete_V1_SubStringMatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var offset: Int64 = 0

  public var length: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_Address_Autocomplete_V1_AddressComponent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var shortName: String = String()

  public var longName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_Address_Autocomplete_V1_AddressComponents {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var streetNumber: Appelis_Address_Autocomplete_V1_AddressComponent {
    get {return _streetNumber ?? Appelis_Address_Autocomplete_V1_AddressComponent()}
    set {_streetNumber = newValue}
  }
  /// Returns true if `streetNumber` has been explicitly set.
  public var hasStreetNumber: Bool {return self._streetNumber != nil}
  /// Clears the value of `streetNumber`. Subsequent reads from it will return its default value.
  public mutating func clearStreetNumber() {self._streetNumber = nil}

  public var route: Appelis_Address_Autocomplete_V1_AddressComponent {
    get {return _route ?? Appelis_Address_Autocomplete_V1_AddressComponent()}
    set {_route = newValue}
  }
  /// Returns true if `route` has been explicitly set.
  public var hasRoute: Bool {return self._route != nil}
  /// Clears the value of `route`. Subsequent reads from it will return its default value.
  public mutating func clearRoute() {self._route = nil}

  public var subLocality: Appelis_Address_Autocomplete_V1_AddressComponent {
    get {return _subLocality ?? Appelis_Address_Autocomplete_V1_AddressComponent()}
    set {_subLocality = newValue}
  }
  /// Returns true if `subLocality` has been explicitly set.
  public var hasSubLocality: Bool {return self._subLocality != nil}
  /// Clears the value of `subLocality`. Subsequent reads from it will return its default value.
  public mutating func clearSubLocality() {self._subLocality = nil}

  public var administrativeAreaLv2: Appelis_Address_Autocomplete_V1_AddressComponent {
    get {return _administrativeAreaLv2 ?? Appelis_Address_Autocomplete_V1_AddressComponent()}
    set {_administrativeAreaLv2 = newValue}
  }
  /// Returns true if `administrativeAreaLv2` has been explicitly set.
  public var hasAdministrativeAreaLv2: Bool {return self._administrativeAreaLv2 != nil}
  /// Clears the value of `administrativeAreaLv2`. Subsequent reads from it will return its default value.
  public mutating func clearAdministrativeAreaLv2() {self._administrativeAreaLv2 = nil}

  public var administrativeAreaLv1: Appelis_Address_Autocomplete_V1_AddressComponent {
    get {return _administrativeAreaLv1 ?? Appelis_Address_Autocomplete_V1_AddressComponent()}
    set {_administrativeAreaLv1 = newValue}
  }
  /// Returns true if `administrativeAreaLv1` has been explicitly set.
  public var hasAdministrativeAreaLv1: Bool {return self._administrativeAreaLv1 != nil}
  /// Clears the value of `administrativeAreaLv1`. Subsequent reads from it will return its default value.
  public mutating func clearAdministrativeAreaLv1() {self._administrativeAreaLv1 = nil}

  public var country: Appelis_Address_Autocomplete_V1_AddressComponent {
    get {return _country ?? Appelis_Address_Autocomplete_V1_AddressComponent()}
    set {_country = newValue}
  }
  /// Returns true if `country` has been explicitly set.
  public var hasCountry: Bool {return self._country != nil}
  /// Clears the value of `country`. Subsequent reads from it will return its default value.
  public mutating func clearCountry() {self._country = nil}

  public var postalCode: Appelis_Address_Autocomplete_V1_AddressComponent {
    get {return _postalCode ?? Appelis_Address_Autocomplete_V1_AddressComponent()}
    set {_postalCode = newValue}
  }
  /// Returns true if `postalCode` has been explicitly set.
  public var hasPostalCode: Bool {return self._postalCode != nil}
  /// Clears the value of `postalCode`. Subsequent reads from it will return its default value.
  public mutating func clearPostalCode() {self._postalCode = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _streetNumber: Appelis_Address_Autocomplete_V1_AddressComponent? = nil
  fileprivate var _route: Appelis_Address_Autocomplete_V1_AddressComponent? = nil
  fileprivate var _subLocality: Appelis_Address_Autocomplete_V1_AddressComponent? = nil
  fileprivate var _administrativeAreaLv2: Appelis_Address_Autocomplete_V1_AddressComponent? = nil
  fileprivate var _administrativeAreaLv1: Appelis_Address_Autocomplete_V1_AddressComponent? = nil
  fileprivate var _country: Appelis_Address_Autocomplete_V1_AddressComponent? = nil
  fileprivate var _postalCode: Appelis_Address_Autocomplete_V1_AddressComponent? = nil
}

public struct Appelis_Address_Autocomplete_V1_PlaceDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var placeID: String {
    get {return _storage._placeID}
    set {_uniqueStorage()._placeID = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var addr: Appelis_Address_Autocomplete_V1_AddressComponents {
    get {return _storage._addr ?? Appelis_Address_Autocomplete_V1_AddressComponents()}
    set {_uniqueStorage()._addr = newValue}
  }
  /// Returns true if `addr` has been explicitly set.
  public var hasAddr: Bool {return _storage._addr != nil}
  /// Clears the value of `addr`. Subsequent reads from it will return its default value.
  public mutating func clearAddr() {_uniqueStorage()._addr = nil}

  public var location: Appelis_Location {
    get {return _storage._location ?? Appelis_Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {_uniqueStorage()._location = nil}

  public var types: [Appelis_Address_Autocomplete_V1_PlaceType] {
    get {return _storage._types}
    set {_uniqueStorage()._types = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Appelis_Address_Autocomplete_V1_PlaceType: @unchecked Sendable {}
extension Appelis_Address_Autocomplete_V1_AutoCompleteResult: @unchecked Sendable {}
extension Appelis_Address_Autocomplete_V1_StructuredFormatting: @unchecked Sendable {}
extension Appelis_Address_Autocomplete_V1_SubStringMatch: @unchecked Sendable {}
extension Appelis_Address_Autocomplete_V1_AddressComponent: @unchecked Sendable {}
extension Appelis_Address_Autocomplete_V1_AddressComponents: @unchecked Sendable {}
extension Appelis_Address_Autocomplete_V1_PlaceDetails: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "appelis.address.autocomplete.v1"

extension Appelis_Address_Autocomplete_V1_PlaceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PLACE_TYPE_UNKNOWN"),
    1: .same(proto: "ROUTE"),
    2: .same(proto: "GEOCODE"),
    3: .same(proto: "STREET_ADDRESS"),
  ]
}

extension Appelis_Address_Autocomplete_V1_AutoCompleteResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutoCompleteResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "placeId"),
    3: .same(proto: "structuredFormatting"),
    4: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.placeID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._structuredFormatting) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    if !self.placeID.isEmpty {
      try visitor.visitSingularStringField(value: self.placeID, fieldNumber: 2)
    }
    try { if let v = self._structuredFormatting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.type.isEmpty {
      try visitor.visitPackedEnumField(value: self.type, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Address_Autocomplete_V1_AutoCompleteResult, rhs: Appelis_Address_Autocomplete_V1_AutoCompleteResult) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.placeID != rhs.placeID {return false}
    if lhs._structuredFormatting != rhs._structuredFormatting {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Address_Autocomplete_V1_StructuredFormatting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StructuredFormatting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mainText"),
    2: .same(proto: "secondaryText"),
    3: .same(proto: "mainTextMatchedSubstrings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mainText) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secondaryText) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mainTextMatchedSubstrings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mainText.isEmpty {
      try visitor.visitSingularStringField(value: self.mainText, fieldNumber: 1)
    }
    if !self.secondaryText.isEmpty {
      try visitor.visitSingularStringField(value: self.secondaryText, fieldNumber: 2)
    }
    if !self.mainTextMatchedSubstrings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mainTextMatchedSubstrings, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Address_Autocomplete_V1_StructuredFormatting, rhs: Appelis_Address_Autocomplete_V1_StructuredFormatting) -> Bool {
    if lhs.mainText != rhs.mainText {return false}
    if lhs.secondaryText != rhs.secondaryText {return false}
    if lhs.mainTextMatchedSubstrings != rhs.mainTextMatchedSubstrings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Address_Autocomplete_V1_SubStringMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubStringMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
    2: .same(proto: "length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.length) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 1)
    }
    if self.length != 0 {
      try visitor.visitSingularInt32Field(value: self.length, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Address_Autocomplete_V1_SubStringMatch, rhs: Appelis_Address_Autocomplete_V1_SubStringMatch) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.length != rhs.length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Address_Autocomplete_V1_AddressComponent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressComponent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shortName"),
    2: .same(proto: "longName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.shortName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.longName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.shortName.isEmpty {
      try visitor.visitSingularStringField(value: self.shortName, fieldNumber: 1)
    }
    if !self.longName.isEmpty {
      try visitor.visitSingularStringField(value: self.longName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Address_Autocomplete_V1_AddressComponent, rhs: Appelis_Address_Autocomplete_V1_AddressComponent) -> Bool {
    if lhs.shortName != rhs.shortName {return false}
    if lhs.longName != rhs.longName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Address_Autocomplete_V1_AddressComponents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressComponents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streetNumber"),
    2: .same(proto: "route"),
    3: .same(proto: "subLocality"),
    4: .same(proto: "administrativeAreaLv2"),
    5: .same(proto: "administrativeAreaLv1"),
    6: .same(proto: "country"),
    7: .same(proto: "postalCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._streetNumber) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._route) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._subLocality) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._administrativeAreaLv2) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._administrativeAreaLv1) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._country) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._postalCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._streetNumber {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._route {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._subLocality {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._administrativeAreaLv2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._administrativeAreaLv1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._country {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._postalCode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Address_Autocomplete_V1_AddressComponents, rhs: Appelis_Address_Autocomplete_V1_AddressComponents) -> Bool {
    if lhs._streetNumber != rhs._streetNumber {return false}
    if lhs._route != rhs._route {return false}
    if lhs._subLocality != rhs._subLocality {return false}
    if lhs._administrativeAreaLv2 != rhs._administrativeAreaLv2 {return false}
    if lhs._administrativeAreaLv1 != rhs._administrativeAreaLv1 {return false}
    if lhs._country != rhs._country {return false}
    if lhs._postalCode != rhs._postalCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Address_Autocomplete_V1_PlaceDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlaceDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "placeId"),
    2: .same(proto: "name"),
    3: .same(proto: "addr"),
    4: .same(proto: "location"),
    5: .same(proto: "types"),
  ]

  fileprivate class _StorageClass {
    var _placeID: String = String()
    var _name: String = String()
    var _addr: Appelis_Address_Autocomplete_V1_AddressComponents? = nil
    var _location: Appelis_Location? = nil
    var _types: [Appelis_Address_Autocomplete_V1_PlaceType] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _placeID = source._placeID
      _name = source._name
      _addr = source._addr
      _location = source._location
      _types = source._types
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._placeID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._addr) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 5: try { try decoder.decodeRepeatedEnumField(value: &_storage._types) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._placeID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._placeID, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._addr {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._types.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._types, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Address_Autocomplete_V1_PlaceDetails, rhs: Appelis_Address_Autocomplete_V1_PlaceDetails) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._placeID != rhs_storage._placeID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._addr != rhs_storage._addr {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._types != rhs_storage._types {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
