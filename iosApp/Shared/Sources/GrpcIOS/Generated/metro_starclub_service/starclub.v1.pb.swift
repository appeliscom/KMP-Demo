// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: metro_starclub_service/starclub.v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Metro_Starclub_V1_ApplyError: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case insufficientPoints // = 1
  case userBlocked // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .insufficientPoints
    case 2: self = .userBlocked
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .insufficientPoints: return 1
    case .userBlocked: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Starclub_V1_ApplyError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Starclub_V1_ApplyError] = [
    .unknown,
    .insufficientPoints,
    .userBlocked,
  ]
}

#endif  // swift(>=4.2)

public enum Metro_Starclub_V1_ApplicationIdentifier: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownApplicationIdentifier // = 0
  case voucher // = 1
  case itemDiscount // = 2
  case voucherAndItemDiscount // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownApplicationIdentifier
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownApplicationIdentifier
    case 1: self = .voucher
    case 2: self = .itemDiscount
    case 3: self = .voucherAndItemDiscount
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownApplicationIdentifier: return 0
    case .voucher: return 1
    case .itemDiscount: return 2
    case .voucherAndItemDiscount: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Starclub_V1_ApplicationIdentifier: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Starclub_V1_ApplicationIdentifier] = [
    .unknownApplicationIdentifier,
    .voucher,
    .itemDiscount,
    .voucherAndItemDiscount,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Starclub_V1_GetCompanyCampaignRuleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V1_GetCompanyCampaignRuleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_GetCompanyCampaignRuleResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var rule: Metro_Starclub_V1_CampaignRule {
    get {
      if case .rule(let v)? = payload {return v}
      return Metro_Starclub_V1_CampaignRule()
    }
    set {payload = .rule(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case rule(Metro_Starclub_V1_CampaignRule)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_GetCompanyCampaignRuleResponse.OneOf_Payload, rhs: Metro_Starclub_V1_GetCompanyCampaignRuleResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rule, .rule): return {
        guard case .rule(let l) = lhs, case .rule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V1_GetCampaignDescriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var lang: Appelis_Language = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V1_GetCampaignDescriptionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_GetCampaignDescriptionResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var data: Data {
    get {
      if case .data(let v)? = payload {return v}
      return Data()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case data(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_GetCampaignDescriptionResponse.OneOf_Payload, rhs: Metro_Starclub_V1_GetCampaignDescriptionResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V1_GetPointsSummaryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V1_PointsSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var totalCollectedPoints: UInt32 = 0

  public var spentPoints: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V1_GetPointsSummaryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_GetPointsSummaryResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var summary: Metro_Starclub_V1_PointsSummary {
    get {
      if case .summary(let v)? = payload {return v}
      return Metro_Starclub_V1_PointsSummary()
    }
    set {payload = .summary(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case summary(Metro_Starclub_V1_PointsSummary)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_GetPointsSummaryResponse.OneOf_Payload, rhs: Metro_Starclub_V1_GetPointsSummaryResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.summary, .summary): return {
        guard case .summary(let l) = lhs, case .summary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V1_ApplyCouponRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var couponID: Appelis_UUID {
    get {return _couponID ?? Appelis_UUID()}
    set {_couponID = newValue}
  }
  /// Returns true if `couponID` has been explicitly set.
  public var hasCouponID: Bool {return self._couponID != nil}
  /// Clears the value of `couponID`. Subsequent reads from it will return its default value.
  public mutating func clearCouponID() {self._couponID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _couponID: Appelis_UUID? = nil
}

public struct Metro_Starclub_V1_ApplyCouponResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_ApplyCouponResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var applyErr: Metro_Starclub_V1_ApplyError {
    get {
      if case .applyErr(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .applyErr(newValue)}
  }

  /// When user swipe usage with ean code will be returned.
  public var usage: Metro_Starclub_V1_Usage {
    get {
      if case .usage(let v)? = payload {return v}
      return Metro_Starclub_V1_Usage()
    }
    set {payload = .usage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case applyErr(Metro_Starclub_V1_ApplyError)
    /// When user swipe usage with ean code will be returned.
    case usage(Metro_Starclub_V1_Usage)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_ApplyCouponResponse.OneOf_Payload, rhs: Metro_Starclub_V1_ApplyCouponResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applyErr, .applyErr): return {
        guard case .applyErr(let l) = lhs, case .applyErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.usage, .usage): return {
        guard case .usage(let l) = lhs, case .usage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V1_GetCouponByIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var couponID: Appelis_UUID {
    get {return _couponID ?? Appelis_UUID()}
    set {_couponID = newValue}
  }
  /// Returns true if `couponID` has been explicitly set.
  public var hasCouponID: Bool {return self._couponID != nil}
  /// Clears the value of `couponID`. Subsequent reads from it will return its default value.
  public mutating func clearCouponID() {self._couponID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _couponID: Appelis_UUID? = nil
}

public struct Metro_Starclub_V1_GetCouponByIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_GetCouponByIdResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var data: Metro_Starclub_V1_CompanyCoupon {
    get {
      if case .data(let v)? = payload {return v}
      return Metro_Starclub_V1_CompanyCoupon()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case data(Metro_Starclub_V1_CompanyCoupon)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_GetCouponByIdResponse.OneOf_Payload, rhs: Metro_Starclub_V1_GetCouponByIdResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V1_GetCouponsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V1_GetCouponsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_GetCouponsResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var data: Metro_Starclub_V1_CompanyCouponArray {
    get {
      if case .data(let v)? = payload {return v}
      return Metro_Starclub_V1_CompanyCouponArray()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case data(Metro_Starclub_V1_CompanyCouponArray)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_GetCouponsResponse.OneOf_Payload, rhs: Metro_Starclub_V1_GetCouponsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V1_CompanyCouponArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Metro_Starclub_V1_CompanyCoupon] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V1_CompanyCoupon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coupon: Metro_Starclub_V1_Coupon {
    get {return _storage._coupon ?? Metro_Starclub_V1_Coupon()}
    set {_uniqueStorage()._coupon = newValue}
  }
  /// Returns true if `coupon` has been explicitly set.
  public var hasCoupon: Bool {return _storage._coupon != nil}
  /// Clears the value of `coupon`. Subsequent reads from it will return its default value.
  public mutating func clearCoupon() {_uniqueStorage()._coupon = nil}

  /// This is valid usage of user logged in token, can be null.
  public var usage: Metro_Starclub_V1_Usage {
    get {return _storage._usage ?? Metro_Starclub_V1_Usage()}
    set {_uniqueStorage()._usage = newValue}
  }
  /// Returns true if `usage` has been explicitly set.
  public var hasUsage: Bool {return _storage._usage != nil}
  /// Clears the value of `usage`. Subsequent reads from it will return its default value.
  public mutating func clearUsage() {_uniqueStorage()._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Metro_Starclub_V1_Usage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var validUntil: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _validUntil ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_validUntil = newValue}
  }
  /// Returns true if `validUntil` has been explicitly set.
  public var hasValidUntil: Bool {return self._validUntil != nil}
  /// Clears the value of `validUntil`. Subsequent reads from it will return its default value.
  public mutating func clearValidUntil() {self._validUntil = nil}

  /// Ean will be populated only when now < validUntil
  public var ean: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _validUntil: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V1_Coupon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var name: String = String()

  public var pictureURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _pictureURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_pictureURL = newValue}
  }
  /// Returns true if `pictureURL` has been explicitly set.
  public var hasPictureURL: Bool {return self._pictureURL != nil}
  /// Clears the value of `pictureURL`. Subsequent reads from it will return its default value.
  public mutating func clearPictureURL() {self._pictureURL = nil}

  public var standardPrice: Metro_Starclub_V1_Price {
    get {return _standardPrice ?? Metro_Starclub_V1_Price()}
    set {_standardPrice = newValue}
  }
  /// Returns true if `standardPrice` has been explicitly set.
  public var hasStandardPrice: Bool {return self._standardPrice != nil}
  /// Clears the value of `standardPrice`. Subsequent reads from it will return its default value.
  public mutating func clearStandardPrice() {self._standardPrice = nil}

  public var starclubPrice: Metro_Starclub_V1_Price {
    get {return _starclubPrice ?? Metro_Starclub_V1_Price()}
    set {_starclubPrice = newValue}
  }
  /// Returns true if `starclubPrice` has been explicitly set.
  public var hasStarclubPrice: Bool {return self._starclubPrice != nil}
  /// Clears the value of `starclubPrice`. Subsequent reads from it will return its default value.
  public mutating func clearStarclubPrice() {self._starclubPrice = nil}

  public var actionPercentage: UInt32 = 0

  public var starPointPrice: UInt32 = 0

  public var description_p: Data = Data()

  public var validTo: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _validTo ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_validTo = newValue}
  }
  /// Returns true if `validTo` has been explicitly set.
  public var hasValidTo: Bool {return self._validTo != nil}
  /// Clears the value of `validTo`. Subsequent reads from it will return its default value.
  public mutating func clearValidTo() {self._validTo = nil}

  public var application: Metro_Starclub_V1_ApplicationIdentifier = .unknownApplicationIdentifier

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _pictureURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _standardPrice: Metro_Starclub_V1_Price? = nil
  fileprivate var _starclubPrice: Metro_Starclub_V1_Price? = nil
  fileprivate var _validTo: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V1_Price {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Double = 0

  public var valueTax: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V1_GetPointMovementsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V1_GetPointMovementsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_GetPointMovementsResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var data: Metro_Starclub_V1_PointMovementArray {
    get {
      if case .data(let v)? = payload {return v}
      return Metro_Starclub_V1_PointMovementArray()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case data(Metro_Starclub_V1_PointMovementArray)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_GetPointMovementsResponse.OneOf_Payload, rhs: Metro_Starclub_V1_GetPointMovementsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V1_GetStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V1_GetStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_GetStatusResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var statusErr: Metro_Starclub_V1_GetStatusResponse.StatusError {
    get {
      if case .statusErr(let v)? = payload {return v}
      return .statusUnknown
    }
    set {payload = .statusErr(newValue)}
  }

  public var status: Metro_Starclub_V1_CampaignStatus {
    get {
      if case .status(let v)? = payload {return v}
      return Metro_Starclub_V1_CampaignStatus()
    }
    set {payload = .status(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case statusErr(Metro_Starclub_V1_GetStatusResponse.StatusError)
    case status(Metro_Starclub_V1_CampaignStatus)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_GetStatusResponse.OneOf_Payload, rhs: Metro_Starclub_V1_GetStatusResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statusErr, .statusErr): return {
        guard case .statusErr(let l) = lhs, case .statusErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.status, .status): return {
        guard case .status(let l) = lhs, case .status(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum StatusError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case statusUnknown // = 0
    case userBlocked // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .statusUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .statusUnknown
      case 1: self = .userBlocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .statusUnknown: return 0
      case .userBlocked: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Metro_Starclub_V1_GetStatusResponse.StatusError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Starclub_V1_GetStatusResponse.StatusError] = [
    .statusUnknown,
    .userBlocked,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Starclub_V1_CampaignStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var campaign: Metro_Starclub_V1_Campaign {
    get {return _storage._campaign ?? Metro_Starclub_V1_Campaign()}
    set {_uniqueStorage()._campaign = newValue}
  }
  /// Returns true if `campaign` has been explicitly set.
  public var hasCampaign: Bool {return _storage._campaign != nil}
  /// Clears the value of `campaign`. Subsequent reads from it will return its default value.
  public mutating func clearCampaign() {_uniqueStorage()._campaign = nil}

  /// Balance can be null.
  public var balance: Metro_Starclub_V1_CompanyBalance {
    get {return _storage._balance ?? Metro_Starclub_V1_CompanyBalance()}
    set {_uniqueStorage()._balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return _storage._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {_uniqueStorage()._balance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Metro_Starclub_V1_Campaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var range: Metro_Starclub_V1_CampaignRange {
    get {return _range ?? Metro_Starclub_V1_CampaignRange()}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  public var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  public mutating func clearRange() {self._range = nil}

  public var pictureURL: String = String()

  public var rules: [Metro_Starclub_V1_CampaignRule] = []

  public var fullRulesURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _range: Metro_Starclub_V1_CampaignRange? = nil
}

public struct Metro_Starclub_V1_CampaignRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var invoiceAmount: Double = 0

  public var clubPoints: Int32 = 0

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V1_CampaignRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var start: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {self._start = nil}

  public var collectingStart: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _collectingStart ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_collectingStart = newValue}
  }
  /// Returns true if `collectingStart` has been explicitly set.
  public var hasCollectingStart: Bool {return self._collectingStart != nil}
  /// Clears the value of `collectingStart`. Subsequent reads from it will return its default value.
  public mutating func clearCollectingStart() {self._collectingStart = nil}

  public var collectingEnd: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _collectingEnd ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_collectingEnd = newValue}
  }
  /// Returns true if `collectingEnd` has been explicitly set.
  public var hasCollectingEnd: Bool {return self._collectingEnd != nil}
  /// Clears the value of `collectingEnd`. Subsequent reads from it will return its default value.
  public mutating func clearCollectingEnd() {self._collectingEnd = nil}

  public var end: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _end ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {self._end = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _collectingStart: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _collectingEnd: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _end: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V1_CompanyBalance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var companyID: Int64 = 0

  /// Balance of starpoints...
  public var actualBalance: Int32 = 0

  public var movementsCount: Int32 = 0

  public var companyName: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V1_PointMovementArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Metro_Starclub_V1_PointMovement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V1_PointMovement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var data: Metro_Starclub_V1_PointMovement.OneOf_Data? = nil

  public var collect: Metro_Starclub_V1_PointMovement.CollectingData {
    get {
      if case .collect(let v)? = data {return v}
      return Metro_Starclub_V1_PointMovement.CollectingData()
    }
    set {data = .collect(newValue)}
  }

  public var spending: Metro_Starclub_V1_PointMovement.SpendingData {
    get {
      if case .spending(let v)? = data {return v}
      return Metro_Starclub_V1_PointMovement.SpendingData()
    }
    set {data = .spending(newValue)}
  }

  public var correction: Metro_Starclub_V1_PointMovement.CorrectionData {
    get {
      if case .correction(let v)? = data {return v}
      return Metro_Starclub_V1_PointMovement.CorrectionData()
    }
    set {data = .correction(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    case collect(Metro_Starclub_V1_PointMovement.CollectingData)
    case spending(Metro_Starclub_V1_PointMovement.SpendingData)
    case correction(Metro_Starclub_V1_PointMovement.CorrectionData)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_PointMovement.OneOf_Data, rhs: Metro_Starclub_V1_PointMovement.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.collect, .collect): return {
        guard case .collect(let l) = lhs, case .collect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.spending, .spending): return {
        guard case .spending(let l) = lhs, case .spending(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.correction, .correction): return {
        guard case .correction(let l) = lhs, case .correction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct CollectingData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pointsCollected: Int32 = 0

    public var invoiceID: String = String()

    public var invoiceAmount: Double = 0

    /// Optional, because invoice have user optional.
    public var invoiceUser: SwiftProtobuf.Google_Protobuf_Int64Value {
      get {return _invoiceUser ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
      set {_invoiceUser = newValue}
    }
    /// Returns true if `invoiceUser` has been explicitly set.
    public var hasInvoiceUser: Bool {return self._invoiceUser != nil}
    /// Clears the value of `invoiceUser`. Subsequent reads from it will return its default value.
    public mutating func clearInvoiceUser() {self._invoiceUser = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _invoiceUser: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  }

  public struct SpendingData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pointsSpent: Int32 = 0

    public var couponID: Appelis_UUID {
      get {return _couponID ?? Appelis_UUID()}
      set {_couponID = newValue}
    }
    /// Returns true if `couponID` has been explicitly set.
    public var hasCouponID: Bool {return self._couponID != nil}
    /// Clears the value of `couponID`. Subsequent reads from it will return its default value.
    public mutating func clearCouponID() {self._couponID = nil}

    public var couponName: String = String()

    public var userID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _couponID: Appelis_UUID? = nil
  }

  public struct CorrectionData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var points: Int32 = 0

    public var description_p: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Metro_Starclub_V1_ApplyError: @unchecked Sendable {}
extension Metro_Starclub_V1_ApplicationIdentifier: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCompanyCampaignRuleRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCompanyCampaignRuleResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCompanyCampaignRuleResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignDescriptionRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignDescriptionResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignDescriptionResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_GetPointsSummaryRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_PointsSummary: @unchecked Sendable {}
extension Metro_Starclub_V1_GetPointsSummaryResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_GetPointsSummaryResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_ApplyCouponRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_ApplyCouponResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_ApplyCouponResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCouponByIdRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCouponByIdResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCouponByIdResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCouponsRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCouponsResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCouponsResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_CompanyCouponArray: @unchecked Sendable {}
extension Metro_Starclub_V1_CompanyCoupon: @unchecked Sendable {}
extension Metro_Starclub_V1_Usage: @unchecked Sendable {}
extension Metro_Starclub_V1_Coupon: @unchecked Sendable {}
extension Metro_Starclub_V1_Price: @unchecked Sendable {}
extension Metro_Starclub_V1_GetPointMovementsRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_GetPointMovementsResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_GetPointMovementsResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_GetStatusRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_GetStatusResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_GetStatusResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_GetStatusResponse.StatusError: @unchecked Sendable {}
extension Metro_Starclub_V1_CampaignStatus: @unchecked Sendable {}
extension Metro_Starclub_V1_Campaign: @unchecked Sendable {}
extension Metro_Starclub_V1_CampaignRule: @unchecked Sendable {}
extension Metro_Starclub_V1_CampaignRange: @unchecked Sendable {}
extension Metro_Starclub_V1_CompanyBalance: @unchecked Sendable {}
extension Metro_Starclub_V1_PointMovementArray: @unchecked Sendable {}
extension Metro_Starclub_V1_PointMovement: @unchecked Sendable {}
extension Metro_Starclub_V1_PointMovement.OneOf_Data: @unchecked Sendable {}
extension Metro_Starclub_V1_PointMovement.CollectingData: @unchecked Sendable {}
extension Metro_Starclub_V1_PointMovement.SpendingData: @unchecked Sendable {}
extension Metro_Starclub_V1_PointMovement.CorrectionData: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "metro.starclub.v1"

extension Metro_Starclub_V1_ApplyError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INSUFFICIENT_POINTS"),
    2: .same(proto: "USER_BLOCKED"),
  ]
}

extension Metro_Starclub_V1_ApplicationIdentifier: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_APPLICATION_IDENTIFIER"),
    1: .same(proto: "VOUCHER"),
    2: .same(proto: "ITEM_DISCOUNT"),
    3: .same(proto: "VOUCHER_AND_ITEM_DISCOUNT"),
  ]
}

extension Metro_Starclub_V1_GetCompanyCampaignRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCompanyCampaignRuleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCompanyCampaignRuleRequest, rhs: Metro_Starclub_V1_GetCompanyCampaignRuleRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCompanyCampaignRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCompanyCampaignRuleResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "rule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V1_CampaignRule?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .rule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .rule(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .rule?: try {
      guard case .rule(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCompanyCampaignRuleResponse, rhs: Metro_Starclub_V1_GetCompanyCampaignRuleResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCampaignDescriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignDescriptionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "lang"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.lang) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.lang != .unknown {
      try visitor.visitSingularEnumField(value: self.lang, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCampaignDescriptionRequest, rhs: Metro_Starclub_V1_GetCampaignDescriptionRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.lang != rhs.lang {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCampaignDescriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignDescriptionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCampaignDescriptionResponse, rhs: Metro_Starclub_V1_GetCampaignDescriptionResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetPointsSummaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPointsSummaryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetPointsSummaryRequest, rhs: Metro_Starclub_V1_GetPointsSummaryRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_PointsSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointsSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totalCollectedPoints"),
    2: .same(proto: "spentPoints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.totalCollectedPoints) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.spentPoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalCollectedPoints != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalCollectedPoints, fieldNumber: 1)
    }
    if self.spentPoints != 0 {
      try visitor.visitSingularUInt32Field(value: self.spentPoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_PointsSummary, rhs: Metro_Starclub_V1_PointsSummary) -> Bool {
    if lhs.totalCollectedPoints != rhs.totalCollectedPoints {return false}
    if lhs.spentPoints != rhs.spentPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetPointsSummaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPointsSummaryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "summary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V1_PointsSummary?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .summary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .summary(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .summary?: try {
      guard case .summary(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetPointsSummaryResponse, rhs: Metro_Starclub_V1_GetPointsSummaryResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_ApplyCouponRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplyCouponRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "couponId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._couponID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._couponID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_ApplyCouponRequest, rhs: Metro_Starclub_V1_ApplyCouponRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._couponID != rhs._couponID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_ApplyCouponResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplyCouponResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "applyErr"),
    3: .same(proto: "usage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V1_ApplyError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .applyErr(v)
        }
      }()
      case 3: try {
        var v: Metro_Starclub_V1_Usage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .usage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .usage(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .applyErr?: try {
      guard case .applyErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .usage?: try {
      guard case .usage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_ApplyCouponResponse, rhs: Metro_Starclub_V1_ApplyCouponResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCouponByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCouponByIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "couponId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._couponID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._couponID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCouponByIdRequest, rhs: Metro_Starclub_V1_GetCouponByIdRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._couponID != rhs._couponID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCouponByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCouponByIdResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V1_CompanyCoupon?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCouponByIdResponse, rhs: Metro_Starclub_V1_GetCouponByIdResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCouponsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCouponsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCouponsRequest, rhs: Metro_Starclub_V1_GetCouponsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCouponsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCouponsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V1_CompanyCouponArray?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCouponsResponse, rhs: Metro_Starclub_V1_GetCouponsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_CompanyCouponArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyCouponArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_CompanyCouponArray, rhs: Metro_Starclub_V1_CompanyCouponArray) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_CompanyCoupon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyCoupon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coupon"),
    2: .same(proto: "usage"),
  ]

  fileprivate class _StorageClass {
    var _coupon: Metro_Starclub_V1_Coupon? = nil
    var _usage: Metro_Starclub_V1_Usage? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _coupon = source._coupon
      _usage = source._usage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._coupon) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._usage) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._coupon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._usage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_CompanyCoupon, rhs: Metro_Starclub_V1_CompanyCoupon) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coupon != rhs_storage._coupon {return false}
        if _storage._usage != rhs_storage._usage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_Usage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Usage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "createdAt"),
    2: .same(proto: "validUntil"),
    3: .same(proto: "ean"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validUntil) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ean) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._validUntil {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.ean.isEmpty {
      try visitor.visitSingularStringField(value: self.ean, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_Usage, rhs: Metro_Starclub_V1_Usage) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._validUntil != rhs._validUntil {return false}
    if lhs.ean != rhs.ean {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_Coupon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Coupon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "pictureUrl"),
    4: .same(proto: "standardPrice"),
    5: .same(proto: "starclubPrice"),
    6: .same(proto: "actionPercentage"),
    7: .same(proto: "starPointPrice"),
    8: .same(proto: "description"),
    9: .same(proto: "validTo"),
    10: .same(proto: "application"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pictureURL) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._standardPrice) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._starclubPrice) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.actionPercentage) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.starPointPrice) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.description_p) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._validTo) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.application) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._pictureURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._standardPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._starclubPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.actionPercentage != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionPercentage, fieldNumber: 6)
    }
    if self.starPointPrice != 0 {
      try visitor.visitSingularUInt32Field(value: self.starPointPrice, fieldNumber: 7)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularBytesField(value: self.description_p, fieldNumber: 8)
    }
    try { if let v = self._validTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if self.application != .unknownApplicationIdentifier {
      try visitor.visitSingularEnumField(value: self.application, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_Coupon, rhs: Metro_Starclub_V1_Coupon) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._pictureURL != rhs._pictureURL {return false}
    if lhs._standardPrice != rhs._standardPrice {return false}
    if lhs._starclubPrice != rhs._starclubPrice {return false}
    if lhs.actionPercentage != rhs.actionPercentage {return false}
    if lhs.starPointPrice != rhs.starPointPrice {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._validTo != rhs._validTo {return false}
    if lhs.application != rhs.application {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_Price: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Price"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "valueTax"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.valueTax) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if self.valueTax != 0 {
      try visitor.visitSingularDoubleField(value: self.valueTax, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_Price, rhs: Metro_Starclub_V1_Price) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.valueTax != rhs.valueTax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetPointMovementsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPointMovementsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetPointMovementsRequest, rhs: Metro_Starclub_V1_GetPointMovementsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetPointMovementsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPointMovementsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V1_PointMovementArray?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetPointMovementsResponse, rhs: Metro_Starclub_V1_GetPointMovementsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetStatusRequest, rhs: Metro_Starclub_V1_GetStatusRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "statusErr"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V1_CampaignStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .status(v)
        }
      }()
      case 3: try {
        var v: Metro_Starclub_V1_GetStatusResponse.StatusError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .statusErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .status?: try {
      guard case .status(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .statusErr?: try {
      guard case .statusErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetStatusResponse, rhs: Metro_Starclub_V1_GetStatusResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetStatusResponse.StatusError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "USER_BLOCKED"),
  ]
}

extension Metro_Starclub_V1_CampaignStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CampaignStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "campaign"),
    2: .same(proto: "balance"),
  ]

  fileprivate class _StorageClass {
    var _campaign: Metro_Starclub_V1_Campaign? = nil
    var _balance: Metro_Starclub_V1_CompanyBalance? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _campaign = source._campaign
      _balance = source._balance
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._campaign) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._balance) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._campaign {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._balance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_CampaignStatus, rhs: Metro_Starclub_V1_CampaignStatus) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._campaign != rhs_storage._campaign {return false}
        if _storage._balance != rhs_storage._balance {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_Campaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Campaign"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "range"),
    3: .same(proto: "pictureUrl"),
    4: .same(proto: "rules"),
    5: .same(proto: "fullRulesUrl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pictureURL) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.fullRulesURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.pictureURL.isEmpty {
      try visitor.visitSingularStringField(value: self.pictureURL, fieldNumber: 3)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 4)
    }
    if !self.fullRulesURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fullRulesURL, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_Campaign, rhs: Metro_Starclub_V1_Campaign) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._range != rhs._range {return false}
    if lhs.pictureURL != rhs.pictureURL {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.fullRulesURL != rhs.fullRulesURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_CampaignRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CampaignRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invoiceAmount"),
    2: .same(proto: "clubPoints"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.invoiceAmount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.clubPoints) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.invoiceAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.invoiceAmount, fieldNumber: 1)
    }
    if self.clubPoints != 0 {
      try visitor.visitSingularInt32Field(value: self.clubPoints, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_CampaignRule, rhs: Metro_Starclub_V1_CampaignRule) -> Bool {
    if lhs.invoiceAmount != rhs.invoiceAmount {return false}
    if lhs.clubPoints != rhs.clubPoints {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_CampaignRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CampaignRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    4: .same(proto: "collectingStart"),
    2: .same(proto: "collectingEnd"),
    3: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._collectingEnd) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._collectingStart) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._collectingEnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._collectingStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_CampaignRange, rhs: Metro_Starclub_V1_CampaignRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._collectingStart != rhs._collectingStart {return false}
    if lhs._collectingEnd != rhs._collectingEnd {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_CompanyBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyBalance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "companyId"),
    2: .same(proto: "actualBalance"),
    5: .same(proto: "movementsCount"),
    3: .same(proto: "companyName"),
    4: .same(proto: "updatedAt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.companyID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.actualBalance) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.companyName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.movementsCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.companyID != 0 {
      try visitor.visitSingularInt64Field(value: self.companyID, fieldNumber: 1)
    }
    if self.actualBalance != 0 {
      try visitor.visitSingularInt32Field(value: self.actualBalance, fieldNumber: 2)
    }
    if !self.companyName.isEmpty {
      try visitor.visitSingularStringField(value: self.companyName, fieldNumber: 3)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.movementsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.movementsCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_CompanyBalance, rhs: Metro_Starclub_V1_CompanyBalance) -> Bool {
    if lhs.companyID != rhs.companyID {return false}
    if lhs.actualBalance != rhs.actualBalance {return false}
    if lhs.movementsCount != rhs.movementsCount {return false}
    if lhs.companyName != rhs.companyName {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_PointMovementArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointMovementArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_PointMovementArray, rhs: Metro_Starclub_V1_PointMovementArray) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_PointMovement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointMovement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "createdAt"),
    3: .same(proto: "collect"),
    4: .same(proto: "spending"),
    5: .same(proto: "correction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try {
        var v: Metro_Starclub_V1_PointMovement.CollectingData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .collect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .collect(v)
        }
      }()
      case 4: try {
        var v: Metro_Starclub_V1_PointMovement.SpendingData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .spending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .spending(v)
        }
      }()
      case 5: try {
        var v: Metro_Starclub_V1_PointMovement.CorrectionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .correction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .correction(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.data {
    case .collect?: try {
      guard case .collect(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .spending?: try {
      guard case .spending(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .correction?: try {
      guard case .correction(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_PointMovement, rhs: Metro_Starclub_V1_PointMovement) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_PointMovement.CollectingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V1_PointMovement.protoMessageName + ".CollectingData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pointsCollected"),
    2: .same(proto: "invoiceId"),
    3: .same(proto: "invoiceAmount"),
    4: .same(proto: "invoiceUser"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pointsCollected) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.invoiceID) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.invoiceAmount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._invoiceUser) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pointsCollected != 0 {
      try visitor.visitSingularInt32Field(value: self.pointsCollected, fieldNumber: 1)
    }
    if !self.invoiceID.isEmpty {
      try visitor.visitSingularStringField(value: self.invoiceID, fieldNumber: 2)
    }
    if self.invoiceAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.invoiceAmount, fieldNumber: 3)
    }
    try { if let v = self._invoiceUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_PointMovement.CollectingData, rhs: Metro_Starclub_V1_PointMovement.CollectingData) -> Bool {
    if lhs.pointsCollected != rhs.pointsCollected {return false}
    if lhs.invoiceID != rhs.invoiceID {return false}
    if lhs.invoiceAmount != rhs.invoiceAmount {return false}
    if lhs._invoiceUser != rhs._invoiceUser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_PointMovement.SpendingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V1_PointMovement.protoMessageName + ".SpendingData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pointsSpent"),
    2: .same(proto: "couponId"),
    3: .same(proto: "couponName"),
    4: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pointsSpent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._couponID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.couponName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pointsSpent != 0 {
      try visitor.visitSingularInt32Field(value: self.pointsSpent, fieldNumber: 1)
    }
    try { if let v = self._couponID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.couponName.isEmpty {
      try visitor.visitSingularStringField(value: self.couponName, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_PointMovement.SpendingData, rhs: Metro_Starclub_V1_PointMovement.SpendingData) -> Bool {
    if lhs.pointsSpent != rhs.pointsSpent {return false}
    if lhs._couponID != rhs._couponID {return false}
    if lhs.couponName != rhs.couponName {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_PointMovement.CorrectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V1_PointMovement.protoMessageName + ".CorrectionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_PointMovement.CorrectionData, rhs: Metro_Starclub_V1_PointMovement.CorrectionData) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
