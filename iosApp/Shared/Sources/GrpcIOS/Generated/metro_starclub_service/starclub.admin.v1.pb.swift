// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: metro_starclub_service/starclub.admin.v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Metro_Starclub_V1_AddAccountCorrectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var accountID: Appelis_UUID {
    get {return _accountID ?? Appelis_UUID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  public var data: Metro_Starclub_V1_AddAccountCorrectionRequest.CorrectionData {
    get {return _data ?? Metro_Starclub_V1_AddAccountCorrectionRequest.CorrectionData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct CorrectionData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var points: Int32 = 0

    public var description_p: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _accountID: Appelis_UUID? = nil
  fileprivate var _data: Metro_Starclub_V1_AddAccountCorrectionRequest.CorrectionData? = nil
}

/// If all was ok payload will be returned nil.
public struct Metro_Starclub_V1_AddAccountCorrectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_AddAccountCorrectionResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_AddAccountCorrectionResponse.OneOf_Payload, rhs: Metro_Starclub_V1_AddAccountCorrectionResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V1_GetAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var accountID: Appelis_UUID {
    get {return _accountID ?? Appelis_UUID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _accountID: Appelis_UUID? = nil
}

public struct Metro_Starclub_V1_GetAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_GetAccountResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var account: Metro_Starclub_V1_CompanyAccount {
    get {
      if case .account(let v)? = payload {return v}
      return Metro_Starclub_V1_CompanyAccount()
    }
    set {payload = .account(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)
    case account(Metro_Starclub_V1_CompanyAccount)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_GetAccountResponse.OneOf_Payload, rhs: Metro_Starclub_V1_GetAccountResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.account, .account): return {
        guard case .account(let l) = lhs, case .account(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V1_PagedAccountsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var campaignID: Appelis_UUID {
    get {return _campaignID ?? Appelis_UUID()}
    set {_campaignID = newValue}
  }
  /// Returns true if `campaignID` has been explicitly set.
  public var hasCampaignID: Bool {return self._campaignID != nil}
  /// Clears the value of `campaignID`. Subsequent reads from it will return its default value.
  public mutating func clearCampaignID() {self._campaignID = nil}

  public var first: Int64 = 0

  public var cursor: Metro_Starclub_V1_PagedAccountsRequest.OneOf_Cursor? = nil

  public var after: String {
    get {
      if case .after(let v)? = cursor {return v}
      return String()
    }
    set {cursor = .after(newValue)}
  }

  /// If filterKeyword will be provided. Results will be filtered by registrationNo using prefix search from "filterKeyword". Field is optional.
  public var filterKeyword: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _filterKeyword ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_filterKeyword = newValue}
  }
  /// Returns true if `filterKeyword` has been explicitly set.
  public var hasFilterKeyword: Bool {return self._filterKeyword != nil}
  /// Clears the value of `filterKeyword`. Subsequent reads from it will return its default value.
  public mutating func clearFilterKeyword() {self._filterKeyword = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Cursor: Equatable {
    case after(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_PagedAccountsRequest.OneOf_Cursor, rhs: Metro_Starclub_V1_PagedAccountsRequest.OneOf_Cursor) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.after, .after): return {
        guard case .after(let l) = lhs, case .after(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _campaignID: Appelis_UUID? = nil
  fileprivate var _filterKeyword: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

public struct Metro_Starclub_V1_PagedAccountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_PagedAccountsResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var page: Metro_Starclub_V1_PagedAccountsResponse.NodesPage {
    get {
      if case .page(let v)? = payload {return v}
      return Metro_Starclub_V1_PagedAccountsResponse.NodesPage()
    }
    set {payload = .page(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)
    case page(Metro_Starclub_V1_PagedAccountsResponse.NodesPage)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_PagedAccountsResponse.OneOf_Payload, rhs: Metro_Starclub_V1_PagedAccountsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.page, .page): return {
        guard case .page(let l) = lhs, case .page(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct NodesPage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var nodes: [Metro_Starclub_V1_PagedAccountsResponse.Node] = []

    public var totalCount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Node {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: Metro_Starclub_V1_CompanyAccountPreview {
      get {return _data ?? Metro_Starclub_V1_CompanyAccountPreview()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    public var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    public mutating func clearData() {self._data = nil}

    public var cursor: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _data: Metro_Starclub_V1_CompanyAccountPreview? = nil
  }

  public init() {}
}

public struct Metro_Starclub_V1_CompanyAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var companyID: Int64 = 0

  public var companyName: String = String()

  public var actualBalance: Int32 = 0

  public var totalCollected: UInt32 = 0

  public var totalSpent: UInt32 = 0

  public var registrationNo: String = String()

  public var movements: [Metro_Starclub_V1_AdminPointMovement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V1_AdminPointMovement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var data: Metro_Starclub_V1_AdminPointMovement.OneOf_Data? = nil

  public var collect: Metro_Starclub_V1_AdminPointMovement.CollectingData {
    get {
      if case .collect(let v)? = data {return v}
      return Metro_Starclub_V1_AdminPointMovement.CollectingData()
    }
    set {data = .collect(newValue)}
  }

  public var spending: Metro_Starclub_V1_AdminPointMovement.SpendingData {
    get {
      if case .spending(let v)? = data {return v}
      return Metro_Starclub_V1_AdminPointMovement.SpendingData()
    }
    set {data = .spending(newValue)}
  }

  public var correction: Metro_Starclub_V1_AdminPointMovement.CorrectionData {
    get {
      if case .correction(let v)? = data {return v}
      return Metro_Starclub_V1_AdminPointMovement.CorrectionData()
    }
    set {data = .correction(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    case collect(Metro_Starclub_V1_AdminPointMovement.CollectingData)
    case spending(Metro_Starclub_V1_AdminPointMovement.SpendingData)
    case correction(Metro_Starclub_V1_AdminPointMovement.CorrectionData)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_AdminPointMovement.OneOf_Data, rhs: Metro_Starclub_V1_AdminPointMovement.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.collect, .collect): return {
        guard case .collect(let l) = lhs, case .collect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.spending, .spending): return {
        guard case .spending(let l) = lhs, case .spending(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.correction, .correction): return {
        guard case .correction(let l) = lhs, case .correction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct CollectingData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pointsCollected: Int32 = 0

    public var invoiceID: String = String()

    public var invoiceAmount: Double = 0

    /// Optional, because invoice have user optional.
    public var invoiceUser: SwiftProtobuf.Google_Protobuf_Int64Value {
      get {return _invoiceUser ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
      set {_invoiceUser = newValue}
    }
    /// Returns true if `invoiceUser` has been explicitly set.
    public var hasInvoiceUser: Bool {return self._invoiceUser != nil}
    /// Clears the value of `invoiceUser`. Subsequent reads from it will return its default value.
    public mutating func clearInvoiceUser() {self._invoiceUser = nil}

    /// If invoiceUser is not nil, then userName will be populated.
    public var userName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _invoiceUser: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  }

  public struct SpendingData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pointsSpent: Int32 = 0

    public var couponID: Appelis_UUID {
      get {return _couponID ?? Appelis_UUID()}
      set {_couponID = newValue}
    }
    /// Returns true if `couponID` has been explicitly set.
    public var hasCouponID: Bool {return self._couponID != nil}
    /// Clears the value of `couponID`. Subsequent reads from it will return its default value.
    public mutating func clearCouponID() {self._couponID = nil}

    public var couponName: String = String()

    public var userID: Int64 = 0

    public var username: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _couponID: Appelis_UUID? = nil
  }

  public struct CorrectionData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var points: Int32 = 0

    public var description_p: String = String()

    public var adminName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V1_CompanyAccountPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var companyID: Int64 = 0

  public var companyName: String = String()

  public var actualBalance: Int32 = 0

  public var totalCollected: UInt32 = 0

  public var totalSpent: UInt32 = 0

  public var registrationNo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V1_GetCampaignsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var first: Int64 = 0

  public var cursor: Metro_Starclub_V1_GetCampaignsRequest.OneOf_Cursor? = nil

  public var after: String {
    get {
      if case .after(let v)? = cursor {return v}
      return String()
    }
    set {cursor = .after(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Cursor: Equatable {
    case after(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_GetCampaignsRequest.OneOf_Cursor, rhs: Metro_Starclub_V1_GetCampaignsRequest.OneOf_Cursor) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.after, .after): return {
        guard case .after(let l) = lhs, case .after(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V1_GetCampaignsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_GetCampaignsResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var page: Metro_Starclub_V1_GetCampaignsResponse.NodesPage {
    get {
      if case .page(let v)? = payload {return v}
      return Metro_Starclub_V1_GetCampaignsResponse.NodesPage()
    }
    set {payload = .page(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)
    case page(Metro_Starclub_V1_GetCampaignsResponse.NodesPage)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_GetCampaignsResponse.OneOf_Payload, rhs: Metro_Starclub_V1_GetCampaignsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.page, .page): return {
        guard case .page(let l) = lhs, case .page(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct NodesPage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var nodes: [Metro_Starclub_V1_GetCampaignsResponse.Node] = []

    public var totalCount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Node {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: Metro_Starclub_V1_AdminCampaignPreview {
      get {return _data ?? Metro_Starclub_V1_AdminCampaignPreview()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    public var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    public mutating func clearData() {self._data = nil}

    public var cursor: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _data: Metro_Starclub_V1_AdminCampaignPreview? = nil
  }

  public init() {}
}

public struct Metro_Starclub_V1_GetActiveCampaignRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V1_GetCampaignByIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _id: Appelis_UUID? = nil
}

/// If payload is not set campaign doesn't exist.
public struct Metro_Starclub_V1_GetCampaignByIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_GetCampaignByIdResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var campaign: Metro_Starclub_V1_AdminCampaign {
    get {
      if case .campaign(let v)? = payload {return v}
      return Metro_Starclub_V1_AdminCampaign()
    }
    set {payload = .campaign(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)
    case campaign(Metro_Starclub_V1_AdminCampaign)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_GetCampaignByIdResponse.OneOf_Payload, rhs: Metro_Starclub_V1_GetCampaignByIdResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.campaign, .campaign): return {
        guard case .campaign(let l) = lhs, case .campaign(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V1_SetCampaignRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _storage._token ?? Appelis_Identity_Common_V1_Token()}
    set {_uniqueStorage()._token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return _storage._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {_uniqueStorage()._token = nil}

  public var data: Metro_Starclub_V1_AdminCampaign {
    get {return _storage._data ?? Metro_Starclub_V1_AdminCampaign()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Metro_Starclub_V1_AdminCampaignPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var name: String = String()

  public var validity: Metro_Starclub_V1_CampaignRange {
    get {return _validity ?? Metro_Starclub_V1_CampaignRange()}
    set {_validity = newValue}
  }
  /// Returns true if `validity` has been explicitly set.
  public var hasValidity: Bool {return self._validity != nil}
  /// Clears the value of `validity`. Subsequent reads from it will return its default value.
  public mutating func clearValidity() {self._validity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _validity: Metro_Starclub_V1_CampaignRange? = nil
}

public struct Metro_Starclub_V1_AdminCampaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var data: Metro_Starclub_V1_CampaignData {
    get {return _data ?? Metro_Starclub_V1_CampaignData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _data: Metro_Starclub_V1_CampaignData? = nil
}

public struct Metro_Starclub_V1_SetCampaignResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V1_SetCampaignResponse.OneOf_Payload? = nil

  public var err: Metro_Starclub_V1_SetCampaignResponse.SetError {
    get {
      if case .err(let v)? = payload {return v}
      return .unknownSetError
    }
    set {payload = .err(newValue)}
  }

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case err(Metro_Starclub_V1_SetCampaignResponse.SetError)
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V1_SetCampaignResponse.OneOf_Payload, rhs: Metro_Starclub_V1_SetCampaignResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.err, .err): return {
        guard case .err(let l) = lhs, case .err(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum SetError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownSetError // = 0
    case invalidRules // = 1
    case invalidValidity // = 2
    case emptyCoupons // = 3
    case emptyPictureURL // = 4
    case invalidConditions // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownSetError
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownSetError
      case 1: self = .invalidRules
      case 2: self = .invalidValidity
      case 3: self = .emptyCoupons
      case 4: self = .emptyPictureURL
      case 5: self = .invalidConditions
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownSetError: return 0
      case .invalidRules: return 1
      case .invalidValidity: return 2
      case .emptyCoupons: return 3
      case .emptyPictureURL: return 4
      case .invalidConditions: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Metro_Starclub_V1_SetCampaignResponse.SetError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Starclub_V1_SetCampaignResponse.SetError] = [
    .unknownSetError,
    .invalidRules,
    .invalidValidity,
    .emptyCoupons,
    .emptyPictureURL,
    .invalidConditions,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Starclub_V1_CampaignData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  /// Must be sent not null. Or error will be returned.
  public var pictureURL: String = String()

  /// Url with full rules of campaign.
  public var rulesURL: String = String()

  /// Time validity of campaign.
  public var validity: Metro_Starclub_V1_CampaignRange {
    get {return _validity ?? Metro_Starclub_V1_CampaignRange()}
    set {_validity = newValue}
  }
  /// Returns true if `validity` has been explicitly set.
  public var hasValidity: Bool {return self._validity != nil}
  /// Clears the value of `validity`. Subsequent reads from it will return its default value.
  public mutating func clearValidity() {self._validity = nil}

  /// Translated description of campaign in HTML text.
  public var descriptions: [Metro_Starclub_V1_TranslatedContent] = []

  public var rules: [Metro_Starclub_V1_Rule] = []

  public var rewardCatalog: [Metro_Starclub_V1_RewardCoupon] = []

  public var userGroups: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _validity: Metro_Starclub_V1_CampaignRange? = nil
}

public struct Metro_Starclub_V1_RewardCoupon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var name: String = String()

  public var ean: String = String()

  public var eanValiditySeconds: Int32 = 0

  public var pictureURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _pictureURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_pictureURL = newValue}
  }
  /// Returns true if `pictureURL` has been explicitly set.
  public var hasPictureURL: Bool {return self._pictureURL != nil}
  /// Clears the value of `pictureURL`. Subsequent reads from it will return its default value.
  public mutating func clearPictureURL() {self._pictureURL = nil}

  public var standardPrice: Metro_Starclub_V1_Price {
    get {return _standardPrice ?? Metro_Starclub_V1_Price()}
    set {_standardPrice = newValue}
  }
  /// Returns true if `standardPrice` has been explicitly set.
  public var hasStandardPrice: Bool {return self._standardPrice != nil}
  /// Clears the value of `standardPrice`. Subsequent reads from it will return its default value.
  public mutating func clearStandardPrice() {self._standardPrice = nil}

  public var starclubPrice: Metro_Starclub_V1_Price {
    get {return _starclubPrice ?? Metro_Starclub_V1_Price()}
    set {_starclubPrice = newValue}
  }
  /// Returns true if `starclubPrice` has been explicitly set.
  public var hasStarclubPrice: Bool {return self._starclubPrice != nil}
  /// Clears the value of `starclubPrice`. Subsequent reads from it will return its default value.
  public mutating func clearStarclubPrice() {self._starclubPrice = nil}

  public var starpointsPrice: UInt32 = 0

  public var actionPercentage: UInt32 = 0

  public var description_p: Data = Data()

  public var applicationIdentified: Metro_Starclub_V1_ApplicationIdentifier = .unknownApplicationIdentifier

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _pictureURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _standardPrice: Metro_Starclub_V1_Price? = nil
  fileprivate var _starclubPrice: Metro_Starclub_V1_Price? = nil
}

public struct Metro_Starclub_V1_Rule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var invoiceAmount: Double = 0

  public var clubPoints: Int32 = 0

  public var description_p: String = String()

  /// Optional condition, if not set rule will be applied to all companies.
  public var condition: Metro_Starclub_V1_Condition {
    get {return _condition ?? Metro_Starclub_V1_Condition()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _condition: Metro_Starclub_V1_Condition? = nil
}

public struct Metro_Starclub_V1_Condition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional
  public var companyType: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _companyType ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_companyType = newValue}
  }
  /// Returns true if `companyType` has been explicitly set.
  public var hasCompanyType: Bool {return self._companyType != nil}
  /// Clears the value of `companyType`. Subsequent reads from it will return its default value.
  public mutating func clearCompanyType() {self._companyType = nil}

  /// Optional
  public var branchID: Metro_Starclub_V1_Range {
    get {return _branchID ?? Metro_Starclub_V1_Range()}
    set {_branchID = newValue}
  }
  /// Returns true if `branchID` has been explicitly set.
  public var hasBranchID: Bool {return self._branchID != nil}
  /// Clears the value of `branchID`. Subsequent reads from it will return its default value.
  public mutating func clearBranchID() {self._branchID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _companyType: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _branchID: Metro_Starclub_V1_Range? = nil
}

public struct Metro_Starclub_V1_Range {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: Int64 = 0

  public var to: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V1_TranslatedContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lang: Appelis_Language = .unknown

  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Metro_Starclub_V1_AddAccountCorrectionRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_AddAccountCorrectionRequest.CorrectionData: @unchecked Sendable {}
extension Metro_Starclub_V1_AddAccountCorrectionResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_AddAccountCorrectionResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_GetAccountRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_GetAccountResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_GetAccountResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_PagedAccountsRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_PagedAccountsRequest.OneOf_Cursor: @unchecked Sendable {}
extension Metro_Starclub_V1_PagedAccountsResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_PagedAccountsResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_PagedAccountsResponse.NodesPage: @unchecked Sendable {}
extension Metro_Starclub_V1_PagedAccountsResponse.Node: @unchecked Sendable {}
extension Metro_Starclub_V1_CompanyAccount: @unchecked Sendable {}
extension Metro_Starclub_V1_AdminPointMovement: @unchecked Sendable {}
extension Metro_Starclub_V1_AdminPointMovement.OneOf_Data: @unchecked Sendable {}
extension Metro_Starclub_V1_AdminPointMovement.CollectingData: @unchecked Sendable {}
extension Metro_Starclub_V1_AdminPointMovement.SpendingData: @unchecked Sendable {}
extension Metro_Starclub_V1_AdminPointMovement.CorrectionData: @unchecked Sendable {}
extension Metro_Starclub_V1_CompanyAccountPreview: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignsRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignsRequest.OneOf_Cursor: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignsResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignsResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignsResponse.NodesPage: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignsResponse.Node: @unchecked Sendable {}
extension Metro_Starclub_V1_GetActiveCampaignRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignByIdRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignByIdResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_GetCampaignByIdResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_SetCampaignRequest: @unchecked Sendable {}
extension Metro_Starclub_V1_AdminCampaignPreview: @unchecked Sendable {}
extension Metro_Starclub_V1_AdminCampaign: @unchecked Sendable {}
extension Metro_Starclub_V1_SetCampaignResponse: @unchecked Sendable {}
extension Metro_Starclub_V1_SetCampaignResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V1_SetCampaignResponse.SetError: @unchecked Sendable {}
extension Metro_Starclub_V1_CampaignData: @unchecked Sendable {}
extension Metro_Starclub_V1_RewardCoupon: @unchecked Sendable {}
extension Metro_Starclub_V1_Rule: @unchecked Sendable {}
extension Metro_Starclub_V1_Condition: @unchecked Sendable {}
extension Metro_Starclub_V1_Range: @unchecked Sendable {}
extension Metro_Starclub_V1_TranslatedContent: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "metro.starclub.v1"

extension Metro_Starclub_V1_AddAccountCorrectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddAccountCorrectionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "accountId"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_AddAccountCorrectionRequest, rhs: Metro_Starclub_V1_AddAccountCorrectionRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._accountID != rhs._accountID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_AddAccountCorrectionRequest.CorrectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V1_AddAccountCorrectionRequest.protoMessageName + ".CorrectionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_AddAccountCorrectionRequest.CorrectionData, rhs: Metro_Starclub_V1_AddAccountCorrectionRequest.CorrectionData) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_AddAccountCorrectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddAccountCorrectionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_AddAccountCorrectionResponse, rhs: Metro_Starclub_V1_AddAccountCorrectionResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "accountId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetAccountRequest, rhs: Metro_Starclub_V1_GetAccountRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._accountID != rhs._accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
    4: .same(proto: "account"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      case 4: try {
        var v: Metro_Starclub_V1_CompanyAccount?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .account(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .account(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case .account?: try {
      guard case .account(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetAccountResponse, rhs: Metro_Starclub_V1_GetAccountResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_PagedAccountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PagedAccountsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "campaignId"),
    3: .same(proto: "first"),
    4: .same(proto: "after"),
    5: .same(proto: "filterKeyword"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._campaignID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.first) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.cursor != nil {try decoder.handleConflictingOneOf()}
          self.cursor = .after(v)
        }
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._filterKeyword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._campaignID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.first != 0 {
      try visitor.visitSingularInt64Field(value: self.first, fieldNumber: 3)
    }
    try { if case .after(let v)? = self.cursor {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._filterKeyword {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_PagedAccountsRequest, rhs: Metro_Starclub_V1_PagedAccountsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._campaignID != rhs._campaignID {return false}
    if lhs.first != rhs.first {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs._filterKeyword != rhs._filterKeyword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_PagedAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PagedAccountsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V1_PagedAccountsResponse.NodesPage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .page(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .page(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .page?: try {
      guard case .page(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_PagedAccountsResponse, rhs: Metro_Starclub_V1_PagedAccountsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_PagedAccountsResponse.NodesPage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V1_PagedAccountsResponse.protoMessageName + ".NodesPage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "totalCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_PagedAccountsResponse.NodesPage, rhs: Metro_Starclub_V1_PagedAccountsResponse.NodesPage) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_PagedAccountsResponse.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V1_PagedAccountsResponse.protoMessageName + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_PagedAccountsResponse.Node, rhs: Metro_Starclub_V1_PagedAccountsResponse.Node) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_CompanyAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "updatedAt"),
    3: .same(proto: "companyId"),
    4: .same(proto: "companyName"),
    5: .same(proto: "actualBalance"),
    6: .same(proto: "totalCollected"),
    7: .same(proto: "totalSpent"),
    8: .same(proto: "registrationNo"),
    9: .same(proto: "movements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.companyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.companyName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.actualBalance) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalCollected) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.totalSpent) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.registrationNo) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.movements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.companyID != 0 {
      try visitor.visitSingularInt64Field(value: self.companyID, fieldNumber: 3)
    }
    if !self.companyName.isEmpty {
      try visitor.visitSingularStringField(value: self.companyName, fieldNumber: 4)
    }
    if self.actualBalance != 0 {
      try visitor.visitSingularInt32Field(value: self.actualBalance, fieldNumber: 5)
    }
    if self.totalCollected != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalCollected, fieldNumber: 6)
    }
    if self.totalSpent != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSpent, fieldNumber: 7)
    }
    if !self.registrationNo.isEmpty {
      try visitor.visitSingularStringField(value: self.registrationNo, fieldNumber: 8)
    }
    if !self.movements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.movements, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_CompanyAccount, rhs: Metro_Starclub_V1_CompanyAccount) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.companyID != rhs.companyID {return false}
    if lhs.companyName != rhs.companyName {return false}
    if lhs.actualBalance != rhs.actualBalance {return false}
    if lhs.totalCollected != rhs.totalCollected {return false}
    if lhs.totalSpent != rhs.totalSpent {return false}
    if lhs.registrationNo != rhs.registrationNo {return false}
    if lhs.movements != rhs.movements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_AdminPointMovement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminPointMovement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "createdAt"),
    3: .same(proto: "collect"),
    4: .same(proto: "spending"),
    5: .same(proto: "correction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try {
        var v: Metro_Starclub_V1_AdminPointMovement.CollectingData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .collect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .collect(v)
        }
      }()
      case 4: try {
        var v: Metro_Starclub_V1_AdminPointMovement.SpendingData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .spending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .spending(v)
        }
      }()
      case 5: try {
        var v: Metro_Starclub_V1_AdminPointMovement.CorrectionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .correction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .correction(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.data {
    case .collect?: try {
      guard case .collect(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .spending?: try {
      guard case .spending(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .correction?: try {
      guard case .correction(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_AdminPointMovement, rhs: Metro_Starclub_V1_AdminPointMovement) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_AdminPointMovement.CollectingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V1_AdminPointMovement.protoMessageName + ".CollectingData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pointsCollected"),
    2: .same(proto: "invoiceId"),
    3: .same(proto: "invoiceAmount"),
    4: .same(proto: "invoiceUser"),
    5: .same(proto: "userName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pointsCollected) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.invoiceID) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.invoiceAmount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._invoiceUser) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pointsCollected != 0 {
      try visitor.visitSingularInt32Field(value: self.pointsCollected, fieldNumber: 1)
    }
    if !self.invoiceID.isEmpty {
      try visitor.visitSingularStringField(value: self.invoiceID, fieldNumber: 2)
    }
    if self.invoiceAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.invoiceAmount, fieldNumber: 3)
    }
    try { if let v = self._invoiceUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_AdminPointMovement.CollectingData, rhs: Metro_Starclub_V1_AdminPointMovement.CollectingData) -> Bool {
    if lhs.pointsCollected != rhs.pointsCollected {return false}
    if lhs.invoiceID != rhs.invoiceID {return false}
    if lhs.invoiceAmount != rhs.invoiceAmount {return false}
    if lhs._invoiceUser != rhs._invoiceUser {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_AdminPointMovement.SpendingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V1_AdminPointMovement.protoMessageName + ".SpendingData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pointsSpent"),
    2: .same(proto: "couponId"),
    3: .same(proto: "couponName"),
    4: .same(proto: "userId"),
    5: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pointsSpent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._couponID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.couponName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pointsSpent != 0 {
      try visitor.visitSingularInt32Field(value: self.pointsSpent, fieldNumber: 1)
    }
    try { if let v = self._couponID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.couponName.isEmpty {
      try visitor.visitSingularStringField(value: self.couponName, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_AdminPointMovement.SpendingData, rhs: Metro_Starclub_V1_AdminPointMovement.SpendingData) -> Bool {
    if lhs.pointsSpent != rhs.pointsSpent {return false}
    if lhs._couponID != rhs._couponID {return false}
    if lhs.couponName != rhs.couponName {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_AdminPointMovement.CorrectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V1_AdminPointMovement.protoMessageName + ".CorrectionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "description"),
    3: .same(proto: "adminName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.adminName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.adminName.isEmpty {
      try visitor.visitSingularStringField(value: self.adminName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_AdminPointMovement.CorrectionData, rhs: Metro_Starclub_V1_AdminPointMovement.CorrectionData) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.adminName != rhs.adminName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_CompanyAccountPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyAccountPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "updatedAt"),
    3: .same(proto: "companyId"),
    4: .same(proto: "companyName"),
    5: .same(proto: "actualBalance"),
    6: .same(proto: "totalCollected"),
    7: .same(proto: "totalSpent"),
    8: .same(proto: "registrationNo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.companyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.companyName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.actualBalance) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalCollected) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.totalSpent) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.registrationNo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.companyID != 0 {
      try visitor.visitSingularInt64Field(value: self.companyID, fieldNumber: 3)
    }
    if !self.companyName.isEmpty {
      try visitor.visitSingularStringField(value: self.companyName, fieldNumber: 4)
    }
    if self.actualBalance != 0 {
      try visitor.visitSingularInt32Field(value: self.actualBalance, fieldNumber: 5)
    }
    if self.totalCollected != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalCollected, fieldNumber: 6)
    }
    if self.totalSpent != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSpent, fieldNumber: 7)
    }
    if !self.registrationNo.isEmpty {
      try visitor.visitSingularStringField(value: self.registrationNo, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_CompanyAccountPreview, rhs: Metro_Starclub_V1_CompanyAccountPreview) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.companyID != rhs.companyID {return false}
    if lhs.companyName != rhs.companyName {return false}
    if lhs.actualBalance != rhs.actualBalance {return false}
    if lhs.totalCollected != rhs.totalCollected {return false}
    if lhs.totalSpent != rhs.totalSpent {return false}
    if lhs.registrationNo != rhs.registrationNo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCampaignsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "first"),
    3: .same(proto: "after"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.first) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.cursor != nil {try decoder.handleConflictingOneOf()}
          self.cursor = .after(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.first != 0 {
      try visitor.visitSingularInt64Field(value: self.first, fieldNumber: 2)
    }
    try { if case .after(let v)? = self.cursor {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCampaignsRequest, rhs: Metro_Starclub_V1_GetCampaignsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.first != rhs.first {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCampaignsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V1_GetCampaignsResponse.NodesPage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .page(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .page(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .page?: try {
      guard case .page(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCampaignsResponse, rhs: Metro_Starclub_V1_GetCampaignsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCampaignsResponse.NodesPage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V1_GetCampaignsResponse.protoMessageName + ".NodesPage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "totalCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCampaignsResponse.NodesPage, rhs: Metro_Starclub_V1_GetCampaignsResponse.NodesPage) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCampaignsResponse.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V1_GetCampaignsResponse.protoMessageName + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCampaignsResponse.Node, rhs: Metro_Starclub_V1_GetCampaignsResponse.Node) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetActiveCampaignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetActiveCampaignRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetActiveCampaignRequest, rhs: Metro_Starclub_V1_GetActiveCampaignRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCampaignByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignByIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCampaignByIdRequest, rhs: Metro_Starclub_V1_GetCampaignByIdRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_GetCampaignByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignByIdResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
    2: .same(proto: "campaign"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V1_AdminCampaign?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .campaign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .campaign(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .campaign?: try {
      guard case .campaign(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_GetCampaignByIdResponse, rhs: Metro_Starclub_V1_GetCampaignByIdResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_SetCampaignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCampaignRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "data"),
  ]

  fileprivate class _StorageClass {
    var _token: Appelis_Identity_Common_V1_Token? = nil
    var _data: Metro_Starclub_V1_AdminCampaign? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _token = source._token
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._token) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._token {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_SetCampaignRequest, rhs: Metro_Starclub_V1_SetCampaignRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._token != rhs_storage._token {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_AdminCampaignPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminCampaignPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "validity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._validity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._validity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_AdminCampaignPreview, rhs: Metro_Starclub_V1_AdminCampaignPreview) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._validity != rhs._validity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_AdminCampaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminCampaign"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_AdminCampaign, rhs: Metro_Starclub_V1_AdminCampaign) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_SetCampaignResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCampaignResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "err"),
    2: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Metro_Starclub_V1_SetCampaignResponse.SetError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .err(v)
        }
      }()
      case 2: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .err?: try {
      guard case .err(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_SetCampaignResponse, rhs: Metro_Starclub_V1_SetCampaignResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_SetCampaignResponse.SetError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SET_ERROR"),
    1: .same(proto: "INVALID_RULES"),
    2: .same(proto: "INVALID_VALIDITY"),
    3: .same(proto: "EMPTY_COUPONS"),
    4: .same(proto: "EMPTY_PICTURE_URL"),
    5: .same(proto: "INVALID_CONDITIONS"),
  ]
}

extension Metro_Starclub_V1_CampaignData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CampaignData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "pictureUrl"),
    3: .same(proto: "rulesUrl"),
    4: .same(proto: "validity"),
    5: .same(proto: "descriptions"),
    6: .same(proto: "rules"),
    7: .same(proto: "rewardCatalog"),
    8: .same(proto: "userGroups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pictureURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.rulesURL) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._validity) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.descriptions) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.rewardCatalog) }()
      case 8: try { try decoder.decodeRepeatedInt64Field(value: &self.userGroups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.pictureURL.isEmpty {
      try visitor.visitSingularStringField(value: self.pictureURL, fieldNumber: 2)
    }
    if !self.rulesURL.isEmpty {
      try visitor.visitSingularStringField(value: self.rulesURL, fieldNumber: 3)
    }
    try { if let v = self._validity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.descriptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.descriptions, fieldNumber: 5)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 6)
    }
    if !self.rewardCatalog.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewardCatalog, fieldNumber: 7)
    }
    if !self.userGroups.isEmpty {
      try visitor.visitPackedInt64Field(value: self.userGroups, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_CampaignData, rhs: Metro_Starclub_V1_CampaignData) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.pictureURL != rhs.pictureURL {return false}
    if lhs.rulesURL != rhs.rulesURL {return false}
    if lhs._validity != rhs._validity {return false}
    if lhs.descriptions != rhs.descriptions {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.rewardCatalog != rhs.rewardCatalog {return false}
    if lhs.userGroups != rhs.userGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_RewardCoupon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RewardCoupon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "ean"),
    4: .same(proto: "eanValiditySeconds"),
    5: .same(proto: "pictureUrl"),
    6: .same(proto: "standardPrice"),
    7: .same(proto: "starclubPrice"),
    8: .same(proto: "starpointsPrice"),
    9: .same(proto: "actionPercentage"),
    10: .same(proto: "description"),
    11: .same(proto: "applicationIdentified"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ean) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.eanValiditySeconds) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._pictureURL) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._standardPrice) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._starclubPrice) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.starpointsPrice) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.actionPercentage) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.description_p) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.applicationIdentified) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.ean.isEmpty {
      try visitor.visitSingularStringField(value: self.ean, fieldNumber: 3)
    }
    if self.eanValiditySeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.eanValiditySeconds, fieldNumber: 4)
    }
    try { if let v = self._pictureURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._standardPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._starclubPrice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.starpointsPrice != 0 {
      try visitor.visitSingularUInt32Field(value: self.starpointsPrice, fieldNumber: 8)
    }
    if self.actionPercentage != 0 {
      try visitor.visitSingularUInt32Field(value: self.actionPercentage, fieldNumber: 9)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularBytesField(value: self.description_p, fieldNumber: 10)
    }
    if self.applicationIdentified != .unknownApplicationIdentifier {
      try visitor.visitSingularEnumField(value: self.applicationIdentified, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_RewardCoupon, rhs: Metro_Starclub_V1_RewardCoupon) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.ean != rhs.ean {return false}
    if lhs.eanValiditySeconds != rhs.eanValiditySeconds {return false}
    if lhs._pictureURL != rhs._pictureURL {return false}
    if lhs._standardPrice != rhs._standardPrice {return false}
    if lhs._starclubPrice != rhs._starclubPrice {return false}
    if lhs.starpointsPrice != rhs.starpointsPrice {return false}
    if lhs.actionPercentage != rhs.actionPercentage {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.applicationIdentified != rhs.applicationIdentified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invoiceAmount"),
    2: .same(proto: "clubPoints"),
    3: .same(proto: "description"),
    4: .same(proto: "condition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.invoiceAmount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.clubPoints) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.invoiceAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.invoiceAmount, fieldNumber: 1)
    }
    if self.clubPoints != 0 {
      try visitor.visitSingularInt32Field(value: self.clubPoints, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try { if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_Rule, rhs: Metro_Starclub_V1_Rule) -> Bool {
    if lhs.invoiceAmount != rhs.invoiceAmount {return false}
    if lhs.clubPoints != rhs.clubPoints {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._condition != rhs._condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_Condition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Condition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "companyType"),
    2: .same(proto: "branchId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._companyType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._branchID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._companyType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._branchID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_Condition, rhs: Metro_Starclub_V1_Condition) -> Bool {
    if lhs._companyType != rhs._companyType {return false}
    if lhs._branchID != rhs._branchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Range"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.from) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.to) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.from != 0 {
      try visitor.visitSingularInt64Field(value: self.from, fieldNumber: 1)
    }
    if self.to != 0 {
      try visitor.visitSingularInt64Field(value: self.to, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_Range, rhs: Metro_Starclub_V1_Range) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V1_TranslatedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TranslatedContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lang"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.lang) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lang != .unknown {
      try visitor.visitSingularEnumField(value: self.lang, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V1_TranslatedContent, rhs: Metro_Starclub_V1_TranslatedContent) -> Bool {
    if lhs.lang != rhs.lang {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
