// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: business_service/business.data.v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Days enumeration for opening/delivery hours.
public enum Appelis_Business_V1_WeekDay: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownWeekDay // = 0
  case monday // = 1
  case tuesday // = 2
  case wednesday // = 3
  case thursday // = 4
  case friday // = 5
  case saturday // = 6
  case sunday // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownWeekDay
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownWeekDay
    case 1: self = .monday
    case 2: self = .tuesday
    case 3: self = .wednesday
    case 4: self = .thursday
    case 5: self = .friday
    case 6: self = .saturday
    case 7: self = .sunday
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownWeekDay: return 0
    case .monday: return 1
    case .tuesday: return 2
    case .wednesday: return 3
    case .thursday: return 4
    case .friday: return 5
    case .saturday: return 6
    case .sunday: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Appelis_Business_V1_WeekDay: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_Business_V1_WeekDay] = [
    .unknownWeekDay,
    .monday,
    .tuesday,
    .wednesday,
    .thursday,
    .friday,
    .saturday,
    .sunday,
  ]
}

#endif  // swift(>=4.2)

public enum Appelis_Business_V1_SortKey: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownKey // = 0
  case identifier // = 1
  case name // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownKey
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownKey
    case 1: self = .identifier
    case 2: self = .name
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownKey: return 0
    case .identifier: return 1
    case .name: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Appelis_Business_V1_SortKey: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_Business_V1_SortKey] = [
    .unknownKey,
    .identifier,
    .name,
  ]
}

#endif  // swift(>=4.2)

public struct Appelis_Business_V1_BusinessArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Appelis_Business_V1_Business] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_Business_V1_Business {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idBusiness: String {
    get {return _storage._idBusiness}
    set {_uniqueStorage()._idBusiness = newValue}
  }

  /// external id of business. optional id.
  public var externalID: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._externalID ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._externalID = newValue}
  }
  /// Returns true if `externalID` has been explicitly set.
  public var hasExternalID: Bool {return _storage._externalID != nil}
  /// Clears the value of `externalID`. Subsequent reads from it will return its default value.
  public mutating func clearExternalID() {_uniqueStorage()._externalID = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var address: Appelis_Address {
    get {return _storage._address ?? Appelis_Address()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {_uniqueStorage()._address = nil}

  /// Static map image of business location
  public var staticMap: Appelis_Picture {
    get {return _storage._staticMap ?? Appelis_Picture()}
    set {_uniqueStorage()._staticMap = newValue}
  }
  /// Returns true if `staticMap` has been explicitly set.
  public var hasStaticMap: Bool {return _storage._staticMap != nil}
  /// Clears the value of `staticMap`. Subsequent reads from it will return its default value.
  public mutating func clearStaticMap() {_uniqueStorage()._staticMap = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// Selected first picture from pictures field.
  public var topPicture: Appelis_Picture {
    get {return _storage._topPicture ?? Appelis_Picture()}
    set {_uniqueStorage()._topPicture = newValue}
  }
  /// Returns true if `topPicture` has been explicitly set.
  public var hasTopPicture: Bool {return _storage._topPicture != nil}
  /// Clears the value of `topPicture`. Subsequent reads from it will return its default value.
  public mutating func clearTopPicture() {_uniqueStorage()._topPicture = nil}

  /// Pictures of business.
  public var pictures: [Appelis_Picture] {
    get {return _storage._pictures}
    set {_uniqueStorage()._pictures = newValue}
  }

  /// Open hours of business.
  public var openHours: [Appelis_Business_V1_HoursRange] {
    get {return _storage._openHours}
    set {_uniqueStorage()._openHours = newValue}
  }

  /// OpenHour for today or null
  public var todayOpenHour: Appelis_Business_V1_HoursRange {
    get {return _storage._todayOpenHour ?? Appelis_Business_V1_HoursRange()}
    set {_uniqueStorage()._todayOpenHour = newValue}
  }
  /// Returns true if `todayOpenHour` has been explicitly set.
  public var hasTodayOpenHour: Bool {return _storage._todayOpenHour != nil}
  /// Clears the value of `todayOpenHour`. Subsequent reads from it will return its default value.
  public mutating func clearTodayOpenHour() {_uniqueStorage()._todayOpenHour = nil}

  /// Limited opening hours due to vacation, holidays etc.
  public var limitedOpenHours: [Appelis_Business_V1_LimitedOpenHours] {
    get {return _storage._limitedOpenHours}
    set {_uniqueStorage()._limitedOpenHours = newValue}
  }

  /// Contacts for business
  public var contacts: [Appelis_Business_V1_BusinessContact] {
    get {return _storage._contacts}
    set {_uniqueStorage()._contacts = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// OpenHour describes opening hours of business
public struct Appelis_Business_V1_HoursRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var day: Appelis_Business_V1_WeekDay = .unknownWeekDay

  public var openFrom: String = String()

  public var openTo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_Business_V1_BusinessContact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var key: String = String()

  public var email: String = String()

  public var phone: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_Business_V1_LimitedOpenHours {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var limitRange: Appelis_TimeRange {
    get {return _limitRange ?? Appelis_TimeRange()}
    set {_limitRange = newValue}
  }
  /// Returns true if `limitRange` has been explicitly set.
  public var hasLimitRange: Bool {return self._limitRange != nil}
  /// Clears the value of `limitRange`. Subsequent reads from it will return its default value.
  public mutating func clearLimitRange() {self._limitRange = nil}

  public var openFrom: String = String()

  public var openTo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _limitRange: Appelis_TimeRange? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Appelis_Business_V1_WeekDay: @unchecked Sendable {}
extension Appelis_Business_V1_SortKey: @unchecked Sendable {}
extension Appelis_Business_V1_BusinessArray: @unchecked Sendable {}
extension Appelis_Business_V1_Business: @unchecked Sendable {}
extension Appelis_Business_V1_HoursRange: @unchecked Sendable {}
extension Appelis_Business_V1_BusinessContact: @unchecked Sendable {}
extension Appelis_Business_V1_LimitedOpenHours: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "appelis.business.v1"

extension Appelis_Business_V1_WeekDay: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_WEEK_DAY"),
    1: .same(proto: "MONDAY"),
    2: .same(proto: "TUESDAY"),
    3: .same(proto: "WEDNESDAY"),
    4: .same(proto: "THURSDAY"),
    5: .same(proto: "FRIDAY"),
    6: .same(proto: "SATURDAY"),
    7: .same(proto: "SUNDAY"),
  ]
}

extension Appelis_Business_V1_SortKey: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_KEY"),
    1: .same(proto: "IDENTIFIER"),
    2: .same(proto: "NAME"),
  ]
}

extension Appelis_Business_V1_BusinessArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BusinessArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Business_V1_BusinessArray, rhs: Appelis_Business_V1_BusinessArray) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Business_V1_Business: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Business"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "idBusiness"),
    2: .same(proto: "externalId"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .same(proto: "address"),
    6: .same(proto: "staticMap"),
    7: .same(proto: "createdAt"),
    8: .same(proto: "topPicture"),
    9: .same(proto: "pictures"),
    10: .same(proto: "openHours"),
    11: .same(proto: "todayOpenHour"),
    12: .same(proto: "limitedOpenHours"),
    13: .same(proto: "contacts"),
  ]

  fileprivate class _StorageClass {
    var _idBusiness: String = String()
    var _externalID: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _name: String = String()
    var _description_p: String = String()
    var _address: Appelis_Address? = nil
    var _staticMap: Appelis_Picture? = nil
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _topPicture: Appelis_Picture? = nil
    var _pictures: [Appelis_Picture] = []
    var _openHours: [Appelis_Business_V1_HoursRange] = []
    var _todayOpenHour: Appelis_Business_V1_HoursRange? = nil
    var _limitedOpenHours: [Appelis_Business_V1_LimitedOpenHours] = []
    var _contacts: [Appelis_Business_V1_BusinessContact] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _idBusiness = source._idBusiness
      _externalID = source._externalID
      _name = source._name
      _description_p = source._description_p
      _address = source._address
      _staticMap = source._staticMap
      _createdAt = source._createdAt
      _topPicture = source._topPicture
      _pictures = source._pictures
      _openHours = source._openHours
      _todayOpenHour = source._todayOpenHour
      _limitedOpenHours = source._limitedOpenHours
      _contacts = source._contacts
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._idBusiness) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._externalID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._address) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._staticMap) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._topPicture) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._pictures) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._openHours) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._todayOpenHour) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._limitedOpenHours) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._contacts) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._idBusiness.isEmpty {
        try visitor.visitSingularStringField(value: _storage._idBusiness, fieldNumber: 1)
      }
      try { if let v = _storage._externalID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 3)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 4)
      }
      try { if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._staticMap {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._topPicture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._pictures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pictures, fieldNumber: 9)
      }
      if !_storage._openHours.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._openHours, fieldNumber: 10)
      }
      try { if let v = _storage._todayOpenHour {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._limitedOpenHours.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._limitedOpenHours, fieldNumber: 12)
      }
      if !_storage._contacts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._contacts, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Business_V1_Business, rhs: Appelis_Business_V1_Business) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._idBusiness != rhs_storage._idBusiness {return false}
        if _storage._externalID != rhs_storage._externalID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._staticMap != rhs_storage._staticMap {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._topPicture != rhs_storage._topPicture {return false}
        if _storage._pictures != rhs_storage._pictures {return false}
        if _storage._openHours != rhs_storage._openHours {return false}
        if _storage._todayOpenHour != rhs_storage._todayOpenHour {return false}
        if _storage._limitedOpenHours != rhs_storage._limitedOpenHours {return false}
        if _storage._contacts != rhs_storage._contacts {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Business_V1_HoursRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HoursRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "day"),
    2: .same(proto: "openFrom"),
    3: .same(proto: "openTo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.day) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.openFrom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.openTo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.day != .unknownWeekDay {
      try visitor.visitSingularEnumField(value: self.day, fieldNumber: 1)
    }
    if !self.openFrom.isEmpty {
      try visitor.visitSingularStringField(value: self.openFrom, fieldNumber: 2)
    }
    if !self.openTo.isEmpty {
      try visitor.visitSingularStringField(value: self.openTo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Business_V1_HoursRange, rhs: Appelis_Business_V1_HoursRange) -> Bool {
    if lhs.day != rhs.day {return false}
    if lhs.openFrom != rhs.openFrom {return false}
    if lhs.openTo != rhs.openTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Business_V1_BusinessContact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BusinessContact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "key"),
    4: .same(proto: "email"),
    5: .same(proto: "phone"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.phone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 3)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 4)
    }
    if !self.phone.isEmpty {
      try visitor.visitSingularStringField(value: self.phone, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Business_V1_BusinessContact, rhs: Appelis_Business_V1_BusinessContact) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.key != rhs.key {return false}
    if lhs.email != rhs.email {return false}
    if lhs.phone != rhs.phone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Business_V1_LimitedOpenHours: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LimitedOpenHours"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "limitRange"),
    2: .same(proto: "openFrom"),
    3: .same(proto: "openTo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._limitRange) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.openFrom) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.openTo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._limitRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.openFrom.isEmpty {
      try visitor.visitSingularStringField(value: self.openFrom, fieldNumber: 2)
    }
    if !self.openTo.isEmpty {
      try visitor.visitSingularStringField(value: self.openTo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Business_V1_LimitedOpenHours, rhs: Appelis_Business_V1_LimitedOpenHours) -> Bool {
    if lhs._limitRange != rhs._limitRange {return false}
    if lhs.openFrom != rhs.openFrom {return false}
    if lhs.openTo != rhs.openTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
