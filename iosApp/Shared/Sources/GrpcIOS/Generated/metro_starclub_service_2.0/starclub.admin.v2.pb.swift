// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: metro_starclub_service_2.0/starclub.admin.v2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Metro_Starclub_V2_AdminSpendingMovement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var pointsSpent: Int32 = 0

  public var couponName: String = String()

  public var couponEan: String = String()

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var companyID: Int64 = 0

  public var userID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V2_AdminSpendingMovementsArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Metro_Starclub_V2_AdminSpendingMovement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_StreamSpendingMovementsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_StreamSpendingMovementsResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var data: Metro_Starclub_V2_AdminSpendingMovementsArray {
    get {
      if case .data(let v)? = payload {return v}
      return Metro_Starclub_V2_AdminSpendingMovementsArray()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case data(Metro_Starclub_V2_AdminSpendingMovementsArray)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_StreamSpendingMovementsResponse.OneOf_Payload, rhs: Metro_Starclub_V2_StreamSpendingMovementsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V2_PolicyApproveArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Metro_Starclub_V2_PolicyApprove] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_PolicyApprove {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var policyID: String = String()

  public var companyID: Int64 = 0

  public var mobileUserID: Int64 = 0

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V2_StreamPolicyApprovesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V2_StreamSpendingMovementsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V2_StreamPolicyApprovesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_StreamPolicyApprovesResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var data: Metro_Starclub_V2_PolicyApproveArray {
    get {
      if case .data(let v)? = payload {return v}
      return Metro_Starclub_V2_PolicyApproveArray()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case data(Metro_Starclub_V2_PolicyApproveArray)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_StreamPolicyApprovesResponse.OneOf_Payload, rhs: Metro_Starclub_V2_StreamPolicyApprovesResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V2_AddAccountCorrectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var accountID: Appelis_UUID {
    get {return _accountID ?? Appelis_UUID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  public var data: Metro_Starclub_V2_AddAccountCorrectionRequest.CorrectionData {
    get {return _data ?? Metro_Starclub_V2_AddAccountCorrectionRequest.CorrectionData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct CorrectionData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var points: Int32 = 0

    public var description_p: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _accountID: Appelis_UUID? = nil
  fileprivate var _data: Metro_Starclub_V2_AddAccountCorrectionRequest.CorrectionData? = nil
}

/// If all was ok payload will be returned nil.
public struct Metro_Starclub_V2_AddAccountCorrectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_AddAccountCorrectionResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_AddAccountCorrectionResponse.OneOf_Payload, rhs: Metro_Starclub_V2_AddAccountCorrectionResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V2_GetAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var accountID: Appelis_UUID {
    get {return _accountID ?? Appelis_UUID()}
    set {_accountID = newValue}
  }
  /// Returns true if `accountID` has been explicitly set.
  public var hasAccountID: Bool {return self._accountID != nil}
  /// Clears the value of `accountID`. Subsequent reads from it will return its default value.
  public mutating func clearAccountID() {self._accountID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _accountID: Appelis_UUID? = nil
}

public struct Metro_Starclub_V2_GetAccountResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_GetAccountResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var account: Metro_Starclub_V2_CompanyAccount {
    get {
      if case .account(let v)? = payload {return v}
      return Metro_Starclub_V2_CompanyAccount()
    }
    set {payload = .account(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)
    case account(Metro_Starclub_V2_CompanyAccount)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_GetAccountResponse.OneOf_Payload, rhs: Metro_Starclub_V2_GetAccountResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.account, .account): return {
        guard case .account(let l) = lhs, case .account(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V2_PagedAccountsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var campaignID: Appelis_UUID {
    get {return _campaignID ?? Appelis_UUID()}
    set {_campaignID = newValue}
  }
  /// Returns true if `campaignID` has been explicitly set.
  public var hasCampaignID: Bool {return self._campaignID != nil}
  /// Clears the value of `campaignID`. Subsequent reads from it will return its default value.
  public mutating func clearCampaignID() {self._campaignID = nil}

  public var first: Int64 = 0

  public var cursor: Metro_Starclub_V2_PagedAccountsRequest.OneOf_Cursor? = nil

  public var after: String {
    get {
      if case .after(let v)? = cursor {return v}
      return String()
    }
    set {cursor = .after(newValue)}
  }

  /// If filterKeyword will be provided. Results will be filtered by registrationNo using prefix search from "filterKeyword". Field is optional.
  public var filterKeyword: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _filterKeyword ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_filterKeyword = newValue}
  }
  /// Returns true if `filterKeyword` has been explicitly set.
  public var hasFilterKeyword: Bool {return self._filterKeyword != nil}
  /// Clears the value of `filterKeyword`. Subsequent reads from it will return its default value.
  public mutating func clearFilterKeyword() {self._filterKeyword = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Cursor: Equatable {
    case after(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_PagedAccountsRequest.OneOf_Cursor, rhs: Metro_Starclub_V2_PagedAccountsRequest.OneOf_Cursor) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.after, .after): return {
        guard case .after(let l) = lhs, case .after(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _campaignID: Appelis_UUID? = nil
  fileprivate var _filterKeyword: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

public struct Metro_Starclub_V2_PagedAccountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_PagedAccountsResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var page: Metro_Starclub_V2_PagedAccountsResponse.NodesPage {
    get {
      if case .page(let v)? = payload {return v}
      return Metro_Starclub_V2_PagedAccountsResponse.NodesPage()
    }
    set {payload = .page(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)
    case page(Metro_Starclub_V2_PagedAccountsResponse.NodesPage)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_PagedAccountsResponse.OneOf_Payload, rhs: Metro_Starclub_V2_PagedAccountsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.page, .page): return {
        guard case .page(let l) = lhs, case .page(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct NodesPage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var nodes: [Metro_Starclub_V2_PagedAccountsResponse.Node] = []

    public var totalCount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Node {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: Metro_Starclub_V2_CompanyAccountPreview {
      get {return _data ?? Metro_Starclub_V2_CompanyAccountPreview()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    public var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    public mutating func clearData() {self._data = nil}

    public var cursor: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _data: Metro_Starclub_V2_CompanyAccountPreview? = nil
  }

  public init() {}
}

public struct Metro_Starclub_V2_CompanyAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var companyID: Int64 = 0

  public var companyName: String = String()

  public var actualBalance: Int32 = 0

  public var totalCollected: UInt32 = 0

  public var totalSpent: UInt32 = 0

  public var registrationNo: String = String()

  public var movements: [Metro_Starclub_V2_AdminPointMovement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V2_AdminPointMovement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var data: Metro_Starclub_V2_AdminPointMovement.OneOf_Data? = nil

  public var collect: Metro_Starclub_V2_AdminPointMovement.CollectingData {
    get {
      if case .collect(let v)? = data {return v}
      return Metro_Starclub_V2_AdminPointMovement.CollectingData()
    }
    set {data = .collect(newValue)}
  }

  public var spending: Metro_Starclub_V2_AdminPointMovement.SpendingData {
    get {
      if case .spending(let v)? = data {return v}
      return Metro_Starclub_V2_AdminPointMovement.SpendingData()
    }
    set {data = .spending(newValue)}
  }

  public var correction: Metro_Starclub_V2_AdminPointMovement.CorrectionData {
    get {
      if case .correction(let v)? = data {return v}
      return Metro_Starclub_V2_AdminPointMovement.CorrectionData()
    }
    set {data = .correction(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    case collect(Metro_Starclub_V2_AdminPointMovement.CollectingData)
    case spending(Metro_Starclub_V2_AdminPointMovement.SpendingData)
    case correction(Metro_Starclub_V2_AdminPointMovement.CorrectionData)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_AdminPointMovement.OneOf_Data, rhs: Metro_Starclub_V2_AdminPointMovement.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.collect, .collect): return {
        guard case .collect(let l) = lhs, case .collect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.spending, .spending): return {
        guard case .spending(let l) = lhs, case .spending(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.correction, .correction): return {
        guard case .correction(let l) = lhs, case .correction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct CollectingData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pointsCollected: Int32 = 0

    public var amount: Double = 0

    public var data: Metro_Starclub_V2_AdminPointMovement.CollectingData.OneOf_Data? = nil

    public var fileData: Metro_Starclub_V2_PointMovement.CollectingData.File {
      get {
        if case .fileData(let v)? = data {return v}
        return Metro_Starclub_V2_PointMovement.CollectingData.File()
      }
      set {data = .fileData(newValue)}
    }

    public var invoiceData: Metro_Starclub_V2_PointMovement.CollectingData.Invoice {
      get {
        if case .invoiceData(let v)? = data {return v}
        return Metro_Starclub_V2_PointMovement.CollectingData.Invoice()
      }
      set {data = .invoiceData(newValue)}
    }

    public var userName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Data: Equatable {
      case fileData(Metro_Starclub_V2_PointMovement.CollectingData.File)
      case invoiceData(Metro_Starclub_V2_PointMovement.CollectingData.Invoice)

    #if !swift(>=4.1)
      public static func ==(lhs: Metro_Starclub_V2_AdminPointMovement.CollectingData.OneOf_Data, rhs: Metro_Starclub_V2_AdminPointMovement.CollectingData.OneOf_Data) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.fileData, .fileData): return {
          guard case .fileData(let l) = lhs, case .fileData(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.invoiceData, .invoiceData): return {
          guard case .invoiceData(let l) = lhs, case .invoiceData(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct SpendingData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pointsSpent: Int32 = 0

    public var couponID: Appelis_UUID {
      get {return _couponID ?? Appelis_UUID()}
      set {_couponID = newValue}
    }
    /// Returns true if `couponID` has been explicitly set.
    public var hasCouponID: Bool {return self._couponID != nil}
    /// Clears the value of `couponID`. Subsequent reads from it will return its default value.
    public mutating func clearCouponID() {self._couponID = nil}

    public var couponName: String = String()

    public var userID: Int64 = 0

    public var username: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _couponID: Appelis_UUID? = nil
  }

  public struct CorrectionData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var points: Int32 = 0

    public var description_p: String = String()

    public var adminName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V2_CompanyAccountPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var companyID: Int64 = 0

  public var companyName: String = String()

  public var actualBalance: Int32 = 0

  public var totalCollected: UInt32 = 0

  public var totalSpent: UInt32 = 0

  public var registrationNo: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V2_GetCampaignsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var first: Int64 = 0

  public var cursor: Metro_Starclub_V2_GetCampaignsRequest.OneOf_Cursor? = nil

  public var after: String {
    get {
      if case .after(let v)? = cursor {return v}
      return String()
    }
    set {cursor = .after(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Cursor: Equatable {
    case after(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_GetCampaignsRequest.OneOf_Cursor, rhs: Metro_Starclub_V2_GetCampaignsRequest.OneOf_Cursor) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.after, .after): return {
        guard case .after(let l) = lhs, case .after(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V2_GetCampaignsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_GetCampaignsResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var page: Metro_Starclub_V2_GetCampaignsResponse.NodesPage {
    get {
      if case .page(let v)? = payload {return v}
      return Metro_Starclub_V2_GetCampaignsResponse.NodesPage()
    }
    set {payload = .page(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)
    case page(Metro_Starclub_V2_GetCampaignsResponse.NodesPage)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_GetCampaignsResponse.OneOf_Payload, rhs: Metro_Starclub_V2_GetCampaignsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.page, .page): return {
        guard case .page(let l) = lhs, case .page(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct NodesPage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var nodes: [Metro_Starclub_V2_GetCampaignsResponse.Node] = []

    public var totalCount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Node {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: Metro_Starclub_V2_AdminCampaignPreview {
      get {return _data ?? Metro_Starclub_V2_AdminCampaignPreview()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    public var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    public mutating func clearData() {self._data = nil}

    public var cursor: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _data: Metro_Starclub_V2_AdminCampaignPreview? = nil
  }

  public init() {}
}

public struct Metro_Starclub_V2_GetActiveCampaignRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V2_GetCampaignByIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _id: Appelis_UUID? = nil
}

/// If payload is not set campaign doesn't exist.
public struct Metro_Starclub_V2_GetCampaignByIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_GetCampaignByIdResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var campaign: Metro_Starclub_V2_AdminCampaign {
    get {
      if case .campaign(let v)? = payload {return v}
      return Metro_Starclub_V2_AdminCampaign()
    }
    set {payload = .campaign(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)
    case campaign(Metro_Starclub_V2_AdminCampaign)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_GetCampaignByIdResponse.OneOf_Payload, rhs: Metro_Starclub_V2_GetCampaignByIdResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.campaign, .campaign): return {
        guard case .campaign(let l) = lhs, case .campaign(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V2_AdminCampaignPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var name: String = String()

  public var validity: Metro_Starclub_V2_CampaignRange {
    get {return _validity ?? Metro_Starclub_V2_CampaignRange()}
    set {_validity = newValue}
  }
  /// Returns true if `validity` has been explicitly set.
  public var hasValidity: Bool {return self._validity != nil}
  /// Clears the value of `validity`. Subsequent reads from it will return its default value.
  public mutating func clearValidity() {self._validity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _validity: Metro_Starclub_V2_CampaignRange? = nil
}

public struct Metro_Starclub_V2_AdminCampaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var data: Metro_Starclub_V2_CampaignData {
    get {return _data ?? Metro_Starclub_V2_CampaignData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _data: Metro_Starclub_V2_CampaignData? = nil
}

public struct Metro_Starclub_V2_SetCampaignRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var data: Metro_Starclub_V2_AdminCampaign {
    get {return _data ?? Metro_Starclub_V2_AdminCampaign()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _data: Metro_Starclub_V2_AdminCampaign? = nil
}

public struct Metro_Starclub_V2_SetCampaignResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_SetCampaignResponse.OneOf_Payload? = nil

  public var err: Metro_Starclub_V2_SetCampaignResponse.SetError {
    get {
      if case .err(let v)? = payload {return v}
      return .unknownSetError
    }
    set {payload = .err(newValue)}
  }

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var permErr: Appelis_Identity_Common_V1_PermissionError {
    get {
      if case .permErr(let v)? = payload {return v}
      return .unknownPermissionError
    }
    set {payload = .permErr(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case err(Metro_Starclub_V2_SetCampaignResponse.SetError)
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case permErr(Appelis_Identity_Common_V1_PermissionError)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_SetCampaignResponse.OneOf_Payload, rhs: Metro_Starclub_V2_SetCampaignResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.err, .err): return {
        guard case .err(let l) = lhs, case .err(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permErr, .permErr): return {
        guard case .permErr(let l) = lhs, case .permErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum SetError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownSetError // = 0
    case invalidRules // = 1
    case invalidValidity // = 2
    case emptyCoupons // = 3
    case emptyPictureURL // = 4
    case invalidConditions // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownSetError
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownSetError
      case 1: self = .invalidRules
      case 2: self = .invalidValidity
      case 3: self = .emptyCoupons
      case 4: self = .emptyPictureURL
      case 5: self = .invalidConditions
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownSetError: return 0
      case .invalidRules: return 1
      case .invalidValidity: return 2
      case .emptyCoupons: return 3
      case .emptyPictureURL: return 4
      case .invalidConditions: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Metro_Starclub_V2_SetCampaignResponse.SetError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Starclub_V2_SetCampaignResponse.SetError] = [
    .unknownSetError,
    .invalidRules,
    .invalidValidity,
    .emptyCoupons,
    .emptyPictureURL,
    .invalidConditions,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Starclub_V2_CampaignData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Must be sent not null. Or error will be returned.
  public var pictureURL: String {
    get {return _storage._pictureURL}
    set {_uniqueStorage()._pictureURL = newValue}
  }

  /// Url with full rules of campaign.
  public var rulesURL: String {
    get {return _storage._rulesURL}
    set {_uniqueStorage()._rulesURL = newValue}
  }

  /// Time validity of campaign.
  public var validity: Metro_Starclub_V2_CampaignRange {
    get {return _storage._validity ?? Metro_Starclub_V2_CampaignRange()}
    set {_uniqueStorage()._validity = newValue}
  }
  /// Returns true if `validity` has been explicitly set.
  public var hasValidity: Bool {return _storage._validity != nil}
  /// Clears the value of `validity`. Subsequent reads from it will return its default value.
  public mutating func clearValidity() {_uniqueStorage()._validity = nil}

  /// Translated description of campaign in HTML text.
  public var descriptions: [Metro_Starclub_V2_TranslatedContent] {
    get {return _storage._descriptions}
    set {_uniqueStorage()._descriptions = newValue}
  }

  public var rule: Metro_Starclub_V2_Rule {
    get {return _storage._rule ?? Metro_Starclub_V2_Rule()}
    set {_uniqueStorage()._rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  public var hasRule: Bool {return _storage._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  public mutating func clearRule() {_uniqueStorage()._rule = nil}

  public var rewardCatalog: [Metro_Starclub_V2_RewardCoupon] {
    get {return _storage._rewardCatalog}
    set {_uniqueStorage()._rewardCatalog = newValue}
  }

  public var userGroup: Int64 {
    get {return _storage._userGroup}
    set {_uniqueStorage()._userGroup = newValue}
  }

  public var datasource: OneOf_Datasource? {
    get {return _storage._datasource}
    set {_uniqueStorage()._datasource = newValue}
  }

  public var files: Metro_Starclub_V2_FileDataSource {
    get {
      if case .files(let v)? = _storage._datasource {return v}
      return Metro_Starclub_V2_FileDataSource()
    }
    set {_uniqueStorage()._datasource = .files(newValue)}
  }

  public var invoice: Metro_Starclub_V2_InvoiceDataSource {
    get {
      if case .invoice(let v)? = _storage._datasource {return v}
      return Metro_Starclub_V2_InvoiceDataSource()
    }
    set {_uniqueStorage()._datasource = .invoice(newValue)}
  }

  public var notifConfig: Metro_Starclub_V2_NotificationTexts {
    get {return _storage._notifConfig ?? Metro_Starclub_V2_NotificationTexts()}
    set {_uniqueStorage()._notifConfig = newValue}
  }
  /// Returns true if `notifConfig` has been explicitly set.
  public var hasNotifConfig: Bool {return _storage._notifConfig != nil}
  /// Clears the value of `notifConfig`. Subsequent reads from it will return its default value.
  public mutating func clearNotifConfig() {_uniqueStorage()._notifConfig = nil}

  public var minCollectedThreshold: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._minCollectedThreshold ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._minCollectedThreshold = newValue}
  }
  /// Returns true if `minCollectedThreshold` has been explicitly set.
  public var hasMinCollectedThreshold: Bool {return _storage._minCollectedThreshold != nil}
  /// Clears the value of `minCollectedThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearMinCollectedThreshold() {_uniqueStorage()._minCollectedThreshold = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Datasource: Equatable {
    case files(Metro_Starclub_V2_FileDataSource)
    case invoice(Metro_Starclub_V2_InvoiceDataSource)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_CampaignData.OneOf_Datasource, rhs: Metro_Starclub_V2_CampaignData.OneOf_Datasource) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.files, .files): return {
        guard case .files(let l) = lhs, case .files(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.invoice, .invoice): return {
        guard case .invoice(let l) = lhs, case .invoice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Metro_Starclub_V2_NotificationTexts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var purchase: Metro_Starclub_V2_NotificationData {
    get {return _purchase ?? Metro_Starclub_V2_NotificationData()}
    set {_purchase = newValue}
  }
  /// Returns true if `purchase` has been explicitly set.
  public var hasPurchase: Bool {return self._purchase != nil}
  /// Clears the value of `purchase`. Subsequent reads from it will return its default value.
  public mutating func clearPurchase() {self._purchase = nil}

  public var couponHit: Metro_Starclub_V2_NotificationData {
    get {return _couponHit ?? Metro_Starclub_V2_NotificationData()}
    set {_couponHit = newValue}
  }
  /// Returns true if `couponHit` has been explicitly set.
  public var hasCouponHit: Bool {return self._couponHit != nil}
  /// Clears the value of `couponHit`. Subsequent reads from it will return its default value.
  public mutating func clearCouponHit() {self._couponHit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _purchase: Metro_Starclub_V2_NotificationData? = nil
  fileprivate var _couponHit: Metro_Starclub_V2_NotificationData? = nil
}

public struct Metro_Starclub_V2_NotificationData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String = String()

  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_FileDataSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fileType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_InvoiceDataSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_RewardCoupon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _storage._id ?? Appelis_UUID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var ean: String {
    get {return _storage._ean}
    set {_uniqueStorage()._ean = newValue}
  }

  public var eanValiditySeconds: Int32 {
    get {return _storage._eanValiditySeconds}
    set {_uniqueStorage()._eanValiditySeconds = newValue}
  }

  public var pictureURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._pictureURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._pictureURL = newValue}
  }
  /// Returns true if `pictureURL` has been explicitly set.
  public var hasPictureURL: Bool {return _storage._pictureURL != nil}
  /// Clears the value of `pictureURL`. Subsequent reads from it will return its default value.
  public mutating func clearPictureURL() {_uniqueStorage()._pictureURL = nil}

  public var standardPrice: Metro_Starclub_V2_Price {
    get {return _storage._standardPrice ?? Metro_Starclub_V2_Price()}
    set {_uniqueStorage()._standardPrice = newValue}
  }
  /// Returns true if `standardPrice` has been explicitly set.
  public var hasStandardPrice: Bool {return _storage._standardPrice != nil}
  /// Clears the value of `standardPrice`. Subsequent reads from it will return its default value.
  public mutating func clearStandardPrice() {_uniqueStorage()._standardPrice = nil}

  public var starclubPrice: Metro_Starclub_V2_Price {
    get {return _storage._starclubPrice ?? Metro_Starclub_V2_Price()}
    set {_uniqueStorage()._starclubPrice = newValue}
  }
  /// Returns true if `starclubPrice` has been explicitly set.
  public var hasStarclubPrice: Bool {return _storage._starclubPrice != nil}
  /// Clears the value of `starclubPrice`. Subsequent reads from it will return its default value.
  public mutating func clearStarclubPrice() {_uniqueStorage()._starclubPrice = nil}

  public var starpointsPrice: UInt32 {
    get {return _storage._starpointsPrice}
    set {_uniqueStorage()._starpointsPrice = newValue}
  }

  public var actionText: String {
    get {return _storage._actionText}
    set {_uniqueStorage()._actionText = newValue}
  }

  public var description_p: Data {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var applicationIdentified: Metro_Starclub_V2_ApplicationIdentifier {
    get {return _storage._applicationIdentified}
    set {_uniqueStorage()._applicationIdentified = newValue}
  }

  public var usageType: Metro_Starclub_V2_CouponUsageType {
    get {return _storage._usageType}
    set {_uniqueStorage()._usageType = newValue}
  }

  public var maximalUse: UInt32 {
    get {return _storage._maximalUse}
    set {_uniqueStorage()._maximalUse = newValue}
  }

  /// Optional usage place
  public var usagePlace: Metro_Starclub_V2_CouponUsagePlace {
    get {return _storage._usagePlace ?? Metro_Starclub_V2_CouponUsagePlace()}
    set {_uniqueStorage()._usagePlace = newValue}
  }
  /// Returns true if `usagePlace` has been explicitly set.
  public var hasUsagePlace: Bool {return _storage._usagePlace != nil}
  /// Clears the value of `usagePlace`. Subsequent reads from it will return its default value.
  public mutating func clearUsagePlace() {_uniqueStorage()._usagePlace = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Metro_Starclub_V2_Rule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var invoiceAmount: Double = 0

  public var clubPoints: Int32 = 0

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_TranslatedContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lang: Appelis_Language = .unknown

  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Metro_Starclub_V2_AdminSpendingMovement: @unchecked Sendable {}
extension Metro_Starclub_V2_AdminSpendingMovementsArray: @unchecked Sendable {}
extension Metro_Starclub_V2_StreamSpendingMovementsResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_StreamSpendingMovementsResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_PolicyApproveArray: @unchecked Sendable {}
extension Metro_Starclub_V2_PolicyApprove: @unchecked Sendable {}
extension Metro_Starclub_V2_StreamPolicyApprovesRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_StreamSpendingMovementsRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_StreamPolicyApprovesResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_StreamPolicyApprovesResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_AddAccountCorrectionRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_AddAccountCorrectionRequest.CorrectionData: @unchecked Sendable {}
extension Metro_Starclub_V2_AddAccountCorrectionResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_AddAccountCorrectionResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_GetAccountRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_GetAccountResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_GetAccountResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_PagedAccountsRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_PagedAccountsRequest.OneOf_Cursor: @unchecked Sendable {}
extension Metro_Starclub_V2_PagedAccountsResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_PagedAccountsResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_PagedAccountsResponse.NodesPage: @unchecked Sendable {}
extension Metro_Starclub_V2_PagedAccountsResponse.Node: @unchecked Sendable {}
extension Metro_Starclub_V2_CompanyAccount: @unchecked Sendable {}
extension Metro_Starclub_V2_AdminPointMovement: @unchecked Sendable {}
extension Metro_Starclub_V2_AdminPointMovement.OneOf_Data: @unchecked Sendable {}
extension Metro_Starclub_V2_AdminPointMovement.CollectingData: @unchecked Sendable {}
extension Metro_Starclub_V2_AdminPointMovement.CollectingData.OneOf_Data: @unchecked Sendable {}
extension Metro_Starclub_V2_AdminPointMovement.SpendingData: @unchecked Sendable {}
extension Metro_Starclub_V2_AdminPointMovement.CorrectionData: @unchecked Sendable {}
extension Metro_Starclub_V2_CompanyAccountPreview: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignsRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignsRequest.OneOf_Cursor: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignsResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignsResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignsResponse.NodesPage: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignsResponse.Node: @unchecked Sendable {}
extension Metro_Starclub_V2_GetActiveCampaignRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignByIdRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignByIdResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignByIdResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_AdminCampaignPreview: @unchecked Sendable {}
extension Metro_Starclub_V2_AdminCampaign: @unchecked Sendable {}
extension Metro_Starclub_V2_SetCampaignRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_SetCampaignResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_SetCampaignResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_SetCampaignResponse.SetError: @unchecked Sendable {}
extension Metro_Starclub_V2_CampaignData: @unchecked Sendable {}
extension Metro_Starclub_V2_CampaignData.OneOf_Datasource: @unchecked Sendable {}
extension Metro_Starclub_V2_NotificationTexts: @unchecked Sendable {}
extension Metro_Starclub_V2_NotificationData: @unchecked Sendable {}
extension Metro_Starclub_V2_FileDataSource: @unchecked Sendable {}
extension Metro_Starclub_V2_InvoiceDataSource: @unchecked Sendable {}
extension Metro_Starclub_V2_RewardCoupon: @unchecked Sendable {}
extension Metro_Starclub_V2_Rule: @unchecked Sendable {}
extension Metro_Starclub_V2_TranslatedContent: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "metro.starclub.v2"

extension Metro_Starclub_V2_AdminSpendingMovement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminSpendingMovement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "pointsSpent"),
    3: .same(proto: "couponName"),
    4: .same(proto: "couponEan"),
    5: .same(proto: "createdAt"),
    6: .same(proto: "companyId"),
    7: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pointsSpent) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.couponName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.couponEan) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.companyID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.pointsSpent != 0 {
      try visitor.visitSingularInt32Field(value: self.pointsSpent, fieldNumber: 2)
    }
    if !self.couponName.isEmpty {
      try visitor.visitSingularStringField(value: self.couponName, fieldNumber: 3)
    }
    if !self.couponEan.isEmpty {
      try visitor.visitSingularStringField(value: self.couponEan, fieldNumber: 4)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.companyID != 0 {
      try visitor.visitSingularInt64Field(value: self.companyID, fieldNumber: 6)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_AdminSpendingMovement, rhs: Metro_Starclub_V2_AdminSpendingMovement) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.pointsSpent != rhs.pointsSpent {return false}
    if lhs.couponName != rhs.couponName {return false}
    if lhs.couponEan != rhs.couponEan {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.companyID != rhs.companyID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_AdminSpendingMovementsArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminSpendingMovementsArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_AdminSpendingMovementsArray, rhs: Metro_Starclub_V2_AdminSpendingMovementsArray) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_StreamSpendingMovementsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamSpendingMovementsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V2_AdminSpendingMovementsArray?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_StreamSpendingMovementsResponse, rhs: Metro_Starclub_V2_StreamSpendingMovementsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PolicyApproveArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PolicyApproveArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PolicyApproveArray, rhs: Metro_Starclub_V2_PolicyApproveArray) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PolicyApprove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PolicyApprove"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "policyId"),
    3: .same(proto: "companyId"),
    4: .same(proto: "mobileUserId"),
    5: .same(proto: "createdAt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.policyID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.companyID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.mobileUserID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.policyID.isEmpty {
      try visitor.visitSingularStringField(value: self.policyID, fieldNumber: 2)
    }
    if self.companyID != 0 {
      try visitor.visitSingularInt64Field(value: self.companyID, fieldNumber: 3)
    }
    if self.mobileUserID != 0 {
      try visitor.visitSingularInt64Field(value: self.mobileUserID, fieldNumber: 4)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PolicyApprove, rhs: Metro_Starclub_V2_PolicyApprove) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.policyID != rhs.policyID {return false}
    if lhs.companyID != rhs.companyID {return false}
    if lhs.mobileUserID != rhs.mobileUserID {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_StreamPolicyApprovesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamPolicyApprovesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_StreamPolicyApprovesRequest, rhs: Metro_Starclub_V2_StreamPolicyApprovesRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_StreamSpendingMovementsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamSpendingMovementsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_StreamSpendingMovementsRequest, rhs: Metro_Starclub_V2_StreamSpendingMovementsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_StreamPolicyApprovesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamPolicyApprovesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V2_PolicyApproveArray?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_StreamPolicyApprovesResponse, rhs: Metro_Starclub_V2_StreamPolicyApprovesResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_AddAccountCorrectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddAccountCorrectionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "accountId"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_AddAccountCorrectionRequest, rhs: Metro_Starclub_V2_AddAccountCorrectionRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._accountID != rhs._accountID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_AddAccountCorrectionRequest.CorrectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_AddAccountCorrectionRequest.protoMessageName + ".CorrectionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_AddAccountCorrectionRequest.CorrectionData, rhs: Metro_Starclub_V2_AddAccountCorrectionRequest.CorrectionData) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_AddAccountCorrectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddAccountCorrectionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_AddAccountCorrectionResponse, rhs: Metro_Starclub_V2_AddAccountCorrectionResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "accountId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accountID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetAccountRequest, rhs: Metro_Starclub_V2_GetAccountRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._accountID != rhs._accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
    4: .same(proto: "account"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      case 4: try {
        var v: Metro_Starclub_V2_CompanyAccount?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .account(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .account(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case .account?: try {
      guard case .account(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetAccountResponse, rhs: Metro_Starclub_V2_GetAccountResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PagedAccountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PagedAccountsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "campaignId"),
    3: .same(proto: "first"),
    4: .same(proto: "after"),
    5: .same(proto: "filterKeyword"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._campaignID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.first) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.cursor != nil {try decoder.handleConflictingOneOf()}
          self.cursor = .after(v)
        }
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._filterKeyword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._campaignID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.first != 0 {
      try visitor.visitSingularInt64Field(value: self.first, fieldNumber: 3)
    }
    try { if case .after(let v)? = self.cursor {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._filterKeyword {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PagedAccountsRequest, rhs: Metro_Starclub_V2_PagedAccountsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._campaignID != rhs._campaignID {return false}
    if lhs.first != rhs.first {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs._filterKeyword != rhs._filterKeyword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PagedAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PagedAccountsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V2_PagedAccountsResponse.NodesPage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .page(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .page(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .page?: try {
      guard case .page(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PagedAccountsResponse, rhs: Metro_Starclub_V2_PagedAccountsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PagedAccountsResponse.NodesPage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_PagedAccountsResponse.protoMessageName + ".NodesPage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "totalCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PagedAccountsResponse.NodesPage, rhs: Metro_Starclub_V2_PagedAccountsResponse.NodesPage) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PagedAccountsResponse.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_PagedAccountsResponse.protoMessageName + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PagedAccountsResponse.Node, rhs: Metro_Starclub_V2_PagedAccountsResponse.Node) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_CompanyAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "updatedAt"),
    3: .same(proto: "companyId"),
    4: .same(proto: "companyName"),
    5: .same(proto: "actualBalance"),
    6: .same(proto: "totalCollected"),
    7: .same(proto: "totalSpent"),
    8: .same(proto: "registrationNo"),
    9: .same(proto: "movements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.companyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.companyName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.actualBalance) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalCollected) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.totalSpent) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.registrationNo) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.movements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.companyID != 0 {
      try visitor.visitSingularInt64Field(value: self.companyID, fieldNumber: 3)
    }
    if !self.companyName.isEmpty {
      try visitor.visitSingularStringField(value: self.companyName, fieldNumber: 4)
    }
    if self.actualBalance != 0 {
      try visitor.visitSingularInt32Field(value: self.actualBalance, fieldNumber: 5)
    }
    if self.totalCollected != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalCollected, fieldNumber: 6)
    }
    if self.totalSpent != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSpent, fieldNumber: 7)
    }
    if !self.registrationNo.isEmpty {
      try visitor.visitSingularStringField(value: self.registrationNo, fieldNumber: 8)
    }
    if !self.movements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.movements, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_CompanyAccount, rhs: Metro_Starclub_V2_CompanyAccount) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.companyID != rhs.companyID {return false}
    if lhs.companyName != rhs.companyName {return false}
    if lhs.actualBalance != rhs.actualBalance {return false}
    if lhs.totalCollected != rhs.totalCollected {return false}
    if lhs.totalSpent != rhs.totalSpent {return false}
    if lhs.registrationNo != rhs.registrationNo {return false}
    if lhs.movements != rhs.movements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_AdminPointMovement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminPointMovement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "createdAt"),
    3: .same(proto: "collect"),
    4: .same(proto: "spending"),
    5: .same(proto: "correction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try {
        var v: Metro_Starclub_V2_AdminPointMovement.CollectingData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .collect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .collect(v)
        }
      }()
      case 4: try {
        var v: Metro_Starclub_V2_AdminPointMovement.SpendingData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .spending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .spending(v)
        }
      }()
      case 5: try {
        var v: Metro_Starclub_V2_AdminPointMovement.CorrectionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .correction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .correction(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.data {
    case .collect?: try {
      guard case .collect(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .spending?: try {
      guard case .spending(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .correction?: try {
      guard case .correction(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_AdminPointMovement, rhs: Metro_Starclub_V2_AdminPointMovement) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_AdminPointMovement.CollectingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_AdminPointMovement.protoMessageName + ".CollectingData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pointsCollected"),
    2: .same(proto: "amount"),
    3: .same(proto: "fileData"),
    4: .same(proto: "invoiceData"),
    5: .same(proto: "userName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pointsCollected) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.amount) }()
      case 3: try {
        var v: Metro_Starclub_V2_PointMovement.CollectingData.File?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .fileData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .fileData(v)
        }
      }()
      case 4: try {
        var v: Metro_Starclub_V2_PointMovement.CollectingData.Invoice?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .invoiceData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .invoiceData(v)
        }
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pointsCollected != 0 {
      try visitor.visitSingularInt32Field(value: self.pointsCollected, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularDoubleField(value: self.amount, fieldNumber: 2)
    }
    switch self.data {
    case .fileData?: try {
      guard case .fileData(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .invoiceData?: try {
      guard case .invoiceData(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.userName.isEmpty {
      try visitor.visitSingularStringField(value: self.userName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_AdminPointMovement.CollectingData, rhs: Metro_Starclub_V2_AdminPointMovement.CollectingData) -> Bool {
    if lhs.pointsCollected != rhs.pointsCollected {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.data != rhs.data {return false}
    if lhs.userName != rhs.userName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_AdminPointMovement.SpendingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_AdminPointMovement.protoMessageName + ".SpendingData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pointsSpent"),
    2: .same(proto: "couponId"),
    3: .same(proto: "couponName"),
    4: .same(proto: "userId"),
    5: .same(proto: "username"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pointsSpent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._couponID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.couponName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pointsSpent != 0 {
      try visitor.visitSingularInt32Field(value: self.pointsSpent, fieldNumber: 1)
    }
    try { if let v = self._couponID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.couponName.isEmpty {
      try visitor.visitSingularStringField(value: self.couponName, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_AdminPointMovement.SpendingData, rhs: Metro_Starclub_V2_AdminPointMovement.SpendingData) -> Bool {
    if lhs.pointsSpent != rhs.pointsSpent {return false}
    if lhs._couponID != rhs._couponID {return false}
    if lhs.couponName != rhs.couponName {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_AdminPointMovement.CorrectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_AdminPointMovement.protoMessageName + ".CorrectionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "description"),
    3: .same(proto: "adminName"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.adminName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.adminName.isEmpty {
      try visitor.visitSingularStringField(value: self.adminName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_AdminPointMovement.CorrectionData, rhs: Metro_Starclub_V2_AdminPointMovement.CorrectionData) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.adminName != rhs.adminName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_CompanyAccountPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyAccountPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "updatedAt"),
    3: .same(proto: "companyId"),
    4: .same(proto: "companyName"),
    5: .same(proto: "actualBalance"),
    6: .same(proto: "totalCollected"),
    7: .same(proto: "totalSpent"),
    8: .same(proto: "registrationNo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.companyID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.companyName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.actualBalance) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.totalCollected) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self.totalSpent) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.registrationNo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.companyID != 0 {
      try visitor.visitSingularInt64Field(value: self.companyID, fieldNumber: 3)
    }
    if !self.companyName.isEmpty {
      try visitor.visitSingularStringField(value: self.companyName, fieldNumber: 4)
    }
    if self.actualBalance != 0 {
      try visitor.visitSingularInt32Field(value: self.actualBalance, fieldNumber: 5)
    }
    if self.totalCollected != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalCollected, fieldNumber: 6)
    }
    if self.totalSpent != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalSpent, fieldNumber: 7)
    }
    if !self.registrationNo.isEmpty {
      try visitor.visitSingularStringField(value: self.registrationNo, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_CompanyAccountPreview, rhs: Metro_Starclub_V2_CompanyAccountPreview) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.companyID != rhs.companyID {return false}
    if lhs.companyName != rhs.companyName {return false}
    if lhs.actualBalance != rhs.actualBalance {return false}
    if lhs.totalCollected != rhs.totalCollected {return false}
    if lhs.totalSpent != rhs.totalSpent {return false}
    if lhs.registrationNo != rhs.registrationNo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetCampaignsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "first"),
    3: .same(proto: "after"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.first) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.cursor != nil {try decoder.handleConflictingOneOf()}
          self.cursor = .after(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.first != 0 {
      try visitor.visitSingularInt64Field(value: self.first, fieldNumber: 2)
    }
    try { if case .after(let v)? = self.cursor {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCampaignsRequest, rhs: Metro_Starclub_V2_GetCampaignsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.first != rhs.first {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetCampaignsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V2_GetCampaignsResponse.NodesPage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .page(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .page(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .page?: try {
      guard case .page(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCampaignsResponse, rhs: Metro_Starclub_V2_GetCampaignsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetCampaignsResponse.NodesPage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_GetCampaignsResponse.protoMessageName + ".NodesPage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nodes"),
    2: .same(proto: "totalCount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 1)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCampaignsResponse.NodesPage, rhs: Metro_Starclub_V2_GetCampaignsResponse.NodesPage) -> Bool {
    if lhs.nodes != rhs.nodes {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetCampaignsResponse.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_GetCampaignsResponse.protoMessageName + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCampaignsResponse.Node, rhs: Metro_Starclub_V2_GetCampaignsResponse.Node) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.cursor != rhs.cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetActiveCampaignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetActiveCampaignRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetActiveCampaignRequest, rhs: Metro_Starclub_V2_GetActiveCampaignRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetCampaignByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignByIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCampaignByIdRequest, rhs: Metro_Starclub_V2_GetCampaignByIdRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetCampaignByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignByIdResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
    2: .same(proto: "campaign"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V2_AdminCampaign?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .campaign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .campaign(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .campaign?: try {
      guard case .campaign(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCampaignByIdResponse, rhs: Metro_Starclub_V2_GetCampaignByIdResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_AdminCampaignPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminCampaignPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "validity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._validity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._validity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_AdminCampaignPreview, rhs: Metro_Starclub_V2_AdminCampaignPreview) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._validity != rhs._validity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_AdminCampaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdminCampaign"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_AdminCampaign, rhs: Metro_Starclub_V2_AdminCampaign) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_SetCampaignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCampaignRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_SetCampaignRequest, rhs: Metro_Starclub_V2_SetCampaignRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_SetCampaignResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCampaignResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "err"),
    2: .same(proto: "tokenErr"),
    3: .same(proto: "permErr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Metro_Starclub_V2_SetCampaignResponse.SetError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .err(v)
        }
      }()
      case 2: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 3: try {
        var v: Appelis_Identity_Common_V1_PermissionError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .permErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .err?: try {
      guard case .err(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .permErr?: try {
      guard case .permErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_SetCampaignResponse, rhs: Metro_Starclub_V2_SetCampaignResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_SetCampaignResponse.SetError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SET_ERROR"),
    1: .same(proto: "INVALID_RULES"),
    2: .same(proto: "INVALID_VALIDITY"),
    3: .same(proto: "EMPTY_COUPONS"),
    4: .same(proto: "EMPTY_PICTURE_URL"),
    5: .same(proto: "INVALID_CONDITIONS"),
  ]
}

extension Metro_Starclub_V2_CampaignData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CampaignData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "pictureUrl"),
    3: .same(proto: "rulesUrl"),
    4: .same(proto: "validity"),
    5: .same(proto: "descriptions"),
    6: .same(proto: "rule"),
    7: .same(proto: "rewardCatalog"),
    8: .same(proto: "userGroup"),
    9: .same(proto: "files"),
    10: .same(proto: "invoice"),
    11: .same(proto: "notifConfig"),
    12: .same(proto: "minCollectedThreshold"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _pictureURL: String = String()
    var _rulesURL: String = String()
    var _validity: Metro_Starclub_V2_CampaignRange? = nil
    var _descriptions: [Metro_Starclub_V2_TranslatedContent] = []
    var _rule: Metro_Starclub_V2_Rule? = nil
    var _rewardCatalog: [Metro_Starclub_V2_RewardCoupon] = []
    var _userGroup: Int64 = 0
    var _datasource: Metro_Starclub_V2_CampaignData.OneOf_Datasource?
    var _notifConfig: Metro_Starclub_V2_NotificationTexts? = nil
    var _minCollectedThreshold: SwiftProtobuf.Google_Protobuf_Int64Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _pictureURL = source._pictureURL
      _rulesURL = source._rulesURL
      _validity = source._validity
      _descriptions = source._descriptions
      _rule = source._rule
      _rewardCatalog = source._rewardCatalog
      _userGroup = source._userGroup
      _datasource = source._datasource
      _notifConfig = source._notifConfig
      _minCollectedThreshold = source._minCollectedThreshold
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._pictureURL) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._rulesURL) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._validity) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._descriptions) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._rule) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._rewardCatalog) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._userGroup) }()
        case 9: try {
          var v: Metro_Starclub_V2_FileDataSource?
          var hadOneofValue = false
          if let current = _storage._datasource {
            hadOneofValue = true
            if case .files(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._datasource = .files(v)
          }
        }()
        case 10: try {
          var v: Metro_Starclub_V2_InvoiceDataSource?
          var hadOneofValue = false
          if let current = _storage._datasource {
            hadOneofValue = true
            if case .invoice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._datasource = .invoice(v)
          }
        }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._notifConfig) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._minCollectedThreshold) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._pictureURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pictureURL, fieldNumber: 2)
      }
      if !_storage._rulesURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rulesURL, fieldNumber: 3)
      }
      try { if let v = _storage._validity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._descriptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._descriptions, fieldNumber: 5)
      }
      try { if let v = _storage._rule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._rewardCatalog.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rewardCatalog, fieldNumber: 7)
      }
      if _storage._userGroup != 0 {
        try visitor.visitSingularInt64Field(value: _storage._userGroup, fieldNumber: 8)
      }
      switch _storage._datasource {
      case .files?: try {
        guard case .files(let v)? = _storage._datasource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .invoice?: try {
        guard case .invoice(let v)? = _storage._datasource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case nil: break
      }
      try { if let v = _storage._notifConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._minCollectedThreshold {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_CampaignData, rhs: Metro_Starclub_V2_CampaignData) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._pictureURL != rhs_storage._pictureURL {return false}
        if _storage._rulesURL != rhs_storage._rulesURL {return false}
        if _storage._validity != rhs_storage._validity {return false}
        if _storage._descriptions != rhs_storage._descriptions {return false}
        if _storage._rule != rhs_storage._rule {return false}
        if _storage._rewardCatalog != rhs_storage._rewardCatalog {return false}
        if _storage._userGroup != rhs_storage._userGroup {return false}
        if _storage._datasource != rhs_storage._datasource {return false}
        if _storage._notifConfig != rhs_storage._notifConfig {return false}
        if _storage._minCollectedThreshold != rhs_storage._minCollectedThreshold {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_NotificationTexts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationTexts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "purchase"),
    2: .same(proto: "couponHit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._purchase) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._couponHit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._purchase {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._couponHit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_NotificationTexts, rhs: Metro_Starclub_V2_NotificationTexts) -> Bool {
    if lhs._purchase != rhs._purchase {return false}
    if lhs._couponHit != rhs._couponHit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_NotificationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_NotificationData, rhs: Metro_Starclub_V2_NotificationData) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_FileDataSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileDataSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fileType"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileType.isEmpty {
      try visitor.visitSingularStringField(value: self.fileType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_FileDataSource, rhs: Metro_Starclub_V2_FileDataSource) -> Bool {
    if lhs.fileType != rhs.fileType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_InvoiceDataSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvoiceDataSource"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_InvoiceDataSource, rhs: Metro_Starclub_V2_InvoiceDataSource) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_RewardCoupon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RewardCoupon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "ean"),
    4: .same(proto: "eanValiditySeconds"),
    5: .same(proto: "pictureUrl"),
    6: .same(proto: "standardPrice"),
    7: .same(proto: "starclubPrice"),
    8: .same(proto: "starpointsPrice"),
    9: .same(proto: "actionText"),
    10: .same(proto: "description"),
    11: .same(proto: "applicationIdentified"),
    12: .same(proto: "usageType"),
    13: .same(proto: "maximalUse"),
    14: .same(proto: "usagePlace"),
  ]

  fileprivate class _StorageClass {
    var _id: Appelis_UUID? = nil
    var _name: String = String()
    var _ean: String = String()
    var _eanValiditySeconds: Int32 = 0
    var _pictureURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _standardPrice: Metro_Starclub_V2_Price? = nil
    var _starclubPrice: Metro_Starclub_V2_Price? = nil
    var _starpointsPrice: UInt32 = 0
    var _actionText: String = String()
    var _description_p: Data = Data()
    var _applicationIdentified: Metro_Starclub_V2_ApplicationIdentifier = .unknownApplicationIdentifier
    var _usageType: Metro_Starclub_V2_CouponUsageType = .unknownCouponUsage
    var _maximalUse: UInt32 = 0
    var _usagePlace: Metro_Starclub_V2_CouponUsagePlace? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _ean = source._ean
      _eanValiditySeconds = source._eanValiditySeconds
      _pictureURL = source._pictureURL
      _standardPrice = source._standardPrice
      _starclubPrice = source._starclubPrice
      _starpointsPrice = source._starpointsPrice
      _actionText = source._actionText
      _description_p = source._description_p
      _applicationIdentified = source._applicationIdentified
      _usageType = source._usageType
      _maximalUse = source._maximalUse
      _usagePlace = source._usagePlace
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._ean) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._eanValiditySeconds) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._pictureURL) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._standardPrice) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._starclubPrice) }()
        case 8: try { try decoder.decodeSingularUInt32Field(value: &_storage._starpointsPrice) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._actionText) }()
        case 10: try { try decoder.decodeSingularBytesField(value: &_storage._description_p) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._applicationIdentified) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._usageType) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._maximalUse) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._usagePlace) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if !_storage._ean.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ean, fieldNumber: 3)
      }
      if _storage._eanValiditySeconds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._eanValiditySeconds, fieldNumber: 4)
      }
      try { if let v = _storage._pictureURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._standardPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._starclubPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._starpointsPrice != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._starpointsPrice, fieldNumber: 8)
      }
      if !_storage._actionText.isEmpty {
        try visitor.visitSingularStringField(value: _storage._actionText, fieldNumber: 9)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._description_p, fieldNumber: 10)
      }
      if _storage._applicationIdentified != .unknownApplicationIdentifier {
        try visitor.visitSingularEnumField(value: _storage._applicationIdentified, fieldNumber: 11)
      }
      if _storage._usageType != .unknownCouponUsage {
        try visitor.visitSingularEnumField(value: _storage._usageType, fieldNumber: 12)
      }
      if _storage._maximalUse != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maximalUse, fieldNumber: 13)
      }
      try { if let v = _storage._usagePlace {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_RewardCoupon, rhs: Metro_Starclub_V2_RewardCoupon) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._ean != rhs_storage._ean {return false}
        if _storage._eanValiditySeconds != rhs_storage._eanValiditySeconds {return false}
        if _storage._pictureURL != rhs_storage._pictureURL {return false}
        if _storage._standardPrice != rhs_storage._standardPrice {return false}
        if _storage._starclubPrice != rhs_storage._starclubPrice {return false}
        if _storage._starpointsPrice != rhs_storage._starpointsPrice {return false}
        if _storage._actionText != rhs_storage._actionText {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._applicationIdentified != rhs_storage._applicationIdentified {return false}
        if _storage._usageType != rhs_storage._usageType {return false}
        if _storage._maximalUse != rhs_storage._maximalUse {return false}
        if _storage._usagePlace != rhs_storage._usagePlace {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invoiceAmount"),
    2: .same(proto: "clubPoints"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.invoiceAmount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.clubPoints) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.invoiceAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.invoiceAmount, fieldNumber: 1)
    }
    if self.clubPoints != 0 {
      try visitor.visitSingularInt32Field(value: self.clubPoints, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_Rule, rhs: Metro_Starclub_V2_Rule) -> Bool {
    if lhs.invoiceAmount != rhs.invoiceAmount {return false}
    if lhs.clubPoints != rhs.clubPoints {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_TranslatedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TranslatedContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lang"),
    2: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.lang) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lang != .unknown {
      try visitor.visitSingularEnumField(value: self.lang, fieldNumber: 1)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_TranslatedContent, rhs: Metro_Starclub_V2_TranslatedContent) -> Bool {
    if lhs.lang != rhs.lang {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
