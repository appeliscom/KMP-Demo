// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: metro_starclub_service_2.0/starclub.v2.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Metro_Starclub_V2_ApplyError: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0
  case insufficientPoints // = 1
  case userBlocked // = 2
  case thresholdNotHit // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .insufficientPoints
    case 2: self = .userBlocked
    case 3: self = .thresholdNotHit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .insufficientPoints: return 1
    case .userBlocked: return 2
    case .thresholdNotHit: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Starclub_V2_ApplyError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Starclub_V2_ApplyError] = [
    .unknown,
    .insufficientPoints,
    .userBlocked,
    .thresholdNotHit,
  ]
}

#endif  // swift(>=4.2)

public enum Metro_Starclub_V2_CouponUsageType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownCouponUsage // = 0
  case unlimited // = 1
  case limited // = 2
  case persistent // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownCouponUsage
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownCouponUsage
    case 1: self = .unlimited
    case 2: self = .limited
    case 3: self = .persistent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownCouponUsage: return 0
    case .unlimited: return 1
    case .limited: return 2
    case .persistent: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Starclub_V2_CouponUsageType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Starclub_V2_CouponUsageType] = [
    .unknownCouponUsage,
    .unlimited,
    .limited,
    .persistent,
  ]
}

#endif  // swift(>=4.2)

public enum Metro_Starclub_V2_ApplicationIdentifier: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownApplicationIdentifier // = 0
  case voucher // = 1
  case itemDiscount // = 2
  case voucherAndItemDiscount // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownApplicationIdentifier
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownApplicationIdentifier
    case 1: self = .voucher
    case 2: self = .itemDiscount
    case 3: self = .voucherAndItemDiscount
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownApplicationIdentifier: return 0
    case .voucher: return 1
    case .itemDiscount: return 2
    case .voucherAndItemDiscount: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Starclub_V2_ApplicationIdentifier: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Starclub_V2_ApplicationIdentifier] = [
    .unknownApplicationIdentifier,
    .voucher,
    .itemDiscount,
    .voucherAndItemDiscount,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Starclub_V2_GetCampaignDescriptionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var lang: Appelis_Language = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V2_GetCampaignDescriptionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_GetCampaignDescriptionResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var data: Data {
    get {
      if case .data(let v)? = payload {return v}
      return Data()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case data(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_GetCampaignDescriptionResponse.OneOf_Payload, rhs: Metro_Starclub_V2_GetCampaignDescriptionResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V2_GetPointsSummaryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V2_GetPointsSummaryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_GetPointsSummaryResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var summary: Metro_Starclub_V2_PointsSummary {
    get {
      if case .summary(let v)? = payload {return v}
      return Metro_Starclub_V2_PointsSummary()
    }
    set {payload = .summary(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case summary(Metro_Starclub_V2_PointsSummary)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_GetPointsSummaryResponse.OneOf_Payload, rhs: Metro_Starclub_V2_GetPointsSummaryResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.summary, .summary): return {
        guard case .summary(let l) = lhs, case .summary(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V2_PointsSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var totalCollectedPoints: UInt32 = 0

  public var spentPoints: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_ApplyCouponRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var couponID: Appelis_UUID {
    get {return _couponID ?? Appelis_UUID()}
    set {_couponID = newValue}
  }
  /// Returns true if `couponID` has been explicitly set.
  public var hasCouponID: Bool {return self._couponID != nil}
  /// Clears the value of `couponID`. Subsequent reads from it will return its default value.
  public mutating func clearCouponID() {self._couponID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _couponID: Appelis_UUID? = nil
}

public struct Metro_Starclub_V2_ApplyCouponResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_ApplyCouponResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var applyErr: Metro_Starclub_V2_ApplyError {
    get {
      if case .applyErr(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .applyErr(newValue)}
  }

  /// When user swipe usage with ean code will be returned.
  public var usage: Metro_Starclub_V2_Usage {
    get {
      if case .usage(let v)? = payload {return v}
      return Metro_Starclub_V2_Usage()
    }
    set {payload = .usage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case applyErr(Metro_Starclub_V2_ApplyError)
    /// When user swipe usage with ean code will be returned.
    case usage(Metro_Starclub_V2_Usage)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_ApplyCouponResponse.OneOf_Payload, rhs: Metro_Starclub_V2_ApplyCouponResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applyErr, .applyErr): return {
        guard case .applyErr(let l) = lhs, case .applyErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.usage, .usage): return {
        guard case .usage(let l) = lhs, case .usage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V2_GetCouponByIdRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var couponID: Appelis_UUID {
    get {return _couponID ?? Appelis_UUID()}
    set {_couponID = newValue}
  }
  /// Returns true if `couponID` has been explicitly set.
  public var hasCouponID: Bool {return self._couponID != nil}
  /// Clears the value of `couponID`. Subsequent reads from it will return its default value.
  public mutating func clearCouponID() {self._couponID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
  fileprivate var _couponID: Appelis_UUID? = nil
}

public struct Metro_Starclub_V2_GetCouponByIdResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_GetCouponByIdResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var data: Metro_Starclub_V2_CompanyCoupon {
    get {
      if case .data(let v)? = payload {return v}
      return Metro_Starclub_V2_CompanyCoupon()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case data(Metro_Starclub_V2_CompanyCoupon)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_GetCouponByIdResponse.OneOf_Payload, rhs: Metro_Starclub_V2_GetCouponByIdResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V2_GetCouponsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V2_GetCouponsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_GetCouponsResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var data: Metro_Starclub_V2_CompanyCouponArray {
    get {
      if case .data(let v)? = payload {return v}
      return Metro_Starclub_V2_CompanyCouponArray()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case data(Metro_Starclub_V2_CompanyCouponArray)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_GetCouponsResponse.OneOf_Payload, rhs: Metro_Starclub_V2_GetCouponsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V2_CompanyCouponArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Metro_Starclub_V2_CompanyCoupon] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_CompanyCoupon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coupon: Metro_Starclub_V2_Coupon {
    get {return _coupon ?? Metro_Starclub_V2_Coupon()}
    set {_coupon = newValue}
  }
  /// Returns true if `coupon` has been explicitly set.
  public var hasCoupon: Bool {return self._coupon != nil}
  /// Clears the value of `coupon`. Subsequent reads from it will return its default value.
  public mutating func clearCoupon() {self._coupon = nil}

  /// This is valid usage of user logged in token, can be null.
  public var usage: Metro_Starclub_V2_Usage {
    get {return _usage ?? Metro_Starclub_V2_Usage()}
    set {_usage = newValue}
  }
  /// Returns true if `usage` has been explicitly set.
  public var hasUsage: Bool {return self._usage != nil}
  /// Clears the value of `usage`. Subsequent reads from it will return its default value.
  public mutating func clearUsage() {self._usage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coupon: Metro_Starclub_V2_Coupon? = nil
  fileprivate var _usage: Metro_Starclub_V2_Usage? = nil
}

public struct Metro_Starclub_V2_Usage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var validUntil: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _validUntil ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_validUntil = newValue}
  }
  /// Returns true if `validUntil` has been explicitly set.
  public var hasValidUntil: Bool {return self._validUntil != nil}
  /// Clears the value of `validUntil`. Subsequent reads from it will return its default value.
  public mutating func clearValidUntil() {self._validUntil = nil}

  /// Ean will be populated only when now < validUntil
  public var ean: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _validUntil: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V2_Coupon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _storage._id ?? Appelis_UUID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var pictureURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._pictureURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._pictureURL = newValue}
  }
  /// Returns true if `pictureURL` has been explicitly set.
  public var hasPictureURL: Bool {return _storage._pictureURL != nil}
  /// Clears the value of `pictureURL`. Subsequent reads from it will return its default value.
  public mutating func clearPictureURL() {_uniqueStorage()._pictureURL = nil}

  public var standardPrice: Metro_Starclub_V2_Price {
    get {return _storage._standardPrice ?? Metro_Starclub_V2_Price()}
    set {_uniqueStorage()._standardPrice = newValue}
  }
  /// Returns true if `standardPrice` has been explicitly set.
  public var hasStandardPrice: Bool {return _storage._standardPrice != nil}
  /// Clears the value of `standardPrice`. Subsequent reads from it will return its default value.
  public mutating func clearStandardPrice() {_uniqueStorage()._standardPrice = nil}

  public var starclubPrice: Metro_Starclub_V2_Price {
    get {return _storage._starclubPrice ?? Metro_Starclub_V2_Price()}
    set {_uniqueStorage()._starclubPrice = newValue}
  }
  /// Returns true if `starclubPrice` has been explicitly set.
  public var hasStarclubPrice: Bool {return _storage._starclubPrice != nil}
  /// Clears the value of `starclubPrice`. Subsequent reads from it will return its default value.
  public mutating func clearStarclubPrice() {_uniqueStorage()._starclubPrice = nil}

  public var actionText: String {
    get {return _storage._actionText}
    set {_uniqueStorage()._actionText = newValue}
  }

  public var starPointPrice: UInt32 {
    get {return _storage._starPointPrice}
    set {_uniqueStorage()._starPointPrice = newValue}
  }

  public var description_p: Data {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var validTo: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._validTo ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._validTo = newValue}
  }
  /// Returns true if `validTo` has been explicitly set.
  public var hasValidTo: Bool {return _storage._validTo != nil}
  /// Clears the value of `validTo`. Subsequent reads from it will return its default value.
  public mutating func clearValidTo() {_uniqueStorage()._validTo = nil}

  public var application: Metro_Starclub_V2_ApplicationIdentifier {
    get {return _storage._application}
    set {_uniqueStorage()._application = newValue}
  }

  public var usageType: Metro_Starclub_V2_CouponUsageType {
    get {return _storage._usageType}
    set {_uniqueStorage()._usageType = newValue}
  }

  public var maximalUse: UInt32 {
    get {return _storage._maximalUse}
    set {_uniqueStorage()._maximalUse = newValue}
  }

  public var alreadyUsed: UInt32 {
    get {return _storage._alreadyUsed}
    set {_uniqueStorage()._alreadyUsed = newValue}
  }

  /// Optional usage place
  public var usagePlace: Metro_Starclub_V2_CouponUsagePlace {
    get {return _storage._usagePlace ?? Metro_Starclub_V2_CouponUsagePlace()}
    set {_uniqueStorage()._usagePlace = newValue}
  }
  /// Returns true if `usagePlace` has been explicitly set.
  public var hasUsagePlace: Bool {return _storage._usagePlace != nil}
  /// Clears the value of `usagePlace`. Subsequent reads from it will return its default value.
  public mutating func clearUsagePlace() {_uniqueStorage()._usagePlace = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Metro_Starclub_V2_CouponUsagePlace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pictureURL: String = String()

  public var translation: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_Price {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Double = 0

  public var valueTax: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_GetPointMovementsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V2_GetPointMovementsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_GetPointMovementsResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var data: Metro_Starclub_V2_PointMovementArray {
    get {
      if case .data(let v)? = payload {return v}
      return Metro_Starclub_V2_PointMovementArray()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case data(Metro_Starclub_V2_PointMovementArray)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_GetPointMovementsResponse.OneOf_Payload, rhs: Metro_Starclub_V2_GetPointMovementsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Metro_Starclub_V2_GetStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Identity_Common_V1_Token {
    get {return _token ?? Appelis_Identity_Common_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Identity_Common_V1_Token? = nil
}

public struct Metro_Starclub_V2_GetStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Starclub_V2_GetStatusResponse.OneOf_Payload? = nil

  public var tokenErr: Appelis_Identity_Common_V1_TokenError {
    get {
      if case .tokenErr(let v)? = payload {return v}
      return .unknownTokenError
    }
    set {payload = .tokenErr(newValue)}
  }

  public var statusErr: Metro_Starclub_V2_GetStatusResponse.StatusError {
    get {
      if case .statusErr(let v)? = payload {return v}
      return .statusUnknown
    }
    set {payload = .statusErr(newValue)}
  }

  public var status: Metro_Starclub_V2_CampaignStatus {
    get {
      if case .status(let v)? = payload {return v}
      return Metro_Starclub_V2_CampaignStatus()
    }
    set {payload = .status(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case tokenErr(Appelis_Identity_Common_V1_TokenError)
    case statusErr(Metro_Starclub_V2_GetStatusResponse.StatusError)
    case status(Metro_Starclub_V2_CampaignStatus)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_GetStatusResponse.OneOf_Payload, rhs: Metro_Starclub_V2_GetStatusResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.tokenErr, .tokenErr): return {
        guard case .tokenErr(let l) = lhs, case .tokenErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statusErr, .statusErr): return {
        guard case .statusErr(let l) = lhs, case .statusErr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.status, .status): return {
        guard case .status(let l) = lhs, case .status(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum StatusError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case statusUnknown // = 0
    case userBlocked // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .statusUnknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .statusUnknown
      case 1: self = .userBlocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .statusUnknown: return 0
      case .userBlocked: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Metro_Starclub_V2_GetStatusResponse.StatusError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Starclub_V2_GetStatusResponse.StatusError] = [
    .statusUnknown,
    .userBlocked,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Starclub_V2_CampaignStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var campaign: Metro_Starclub_V2_Campaign {
    get {return _campaign ?? Metro_Starclub_V2_Campaign()}
    set {_campaign = newValue}
  }
  /// Returns true if `campaign` has been explicitly set.
  public var hasCampaign: Bool {return self._campaign != nil}
  /// Clears the value of `campaign`. Subsequent reads from it will return its default value.
  public mutating func clearCampaign() {self._campaign = nil}

  /// Balance can be null.
  public var balance: Metro_Starclub_V2_CompanyBalance {
    get {return _balance ?? Metro_Starclub_V2_CompanyBalance()}
    set {_balance = newValue}
  }
  /// Returns true if `balance` has been explicitly set.
  public var hasBalance: Bool {return self._balance != nil}
  /// Clears the value of `balance`. Subsequent reads from it will return its default value.
  public mutating func clearBalance() {self._balance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _campaign: Metro_Starclub_V2_Campaign? = nil
  fileprivate var _balance: Metro_Starclub_V2_CompanyBalance? = nil
}

public struct Metro_Starclub_V2_Campaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _storage._id ?? Appelis_UUID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var range: Metro_Starclub_V2_CampaignRange {
    get {return _storage._range ?? Metro_Starclub_V2_CampaignRange()}
    set {_uniqueStorage()._range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  public var hasRange: Bool {return _storage._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  public mutating func clearRange() {_uniqueStorage()._range = nil}

  public var pictureURL: String {
    get {return _storage._pictureURL}
    set {_uniqueStorage()._pictureURL = newValue}
  }

  public var rule: Metro_Starclub_V2_CampaignRule {
    get {return _storage._rule ?? Metro_Starclub_V2_CampaignRule()}
    set {_uniqueStorage()._rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  public var hasRule: Bool {return _storage._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  public mutating func clearRule() {_uniqueStorage()._rule = nil}

  public var fullRulesURL: String {
    get {return _storage._fullRulesURL}
    set {_uniqueStorage()._fullRulesURL = newValue}
  }

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var minCollectedThreshold: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._minCollectedThreshold ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._minCollectedThreshold = newValue}
  }
  /// Returns true if `minCollectedThreshold` has been explicitly set.
  public var hasMinCollectedThreshold: Bool {return _storage._minCollectedThreshold != nil}
  /// Clears the value of `minCollectedThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearMinCollectedThreshold() {_uniqueStorage()._minCollectedThreshold = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Metro_Starclub_V2_CampaignRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var invoiceAmount: Double = 0

  public var clubPoints: Int32 = 0

  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_CampaignRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var start: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _start ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {self._start = nil}

  public var collectingStart: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _collectingStart ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_collectingStart = newValue}
  }
  /// Returns true if `collectingStart` has been explicitly set.
  public var hasCollectingStart: Bool {return self._collectingStart != nil}
  /// Clears the value of `collectingStart`. Subsequent reads from it will return its default value.
  public mutating func clearCollectingStart() {self._collectingStart = nil}

  public var collectingEnd: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _collectingEnd ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_collectingEnd = newValue}
  }
  /// Returns true if `collectingEnd` has been explicitly set.
  public var hasCollectingEnd: Bool {return self._collectingEnd != nil}
  /// Clears the value of `collectingEnd`. Subsequent reads from it will return its default value.
  public mutating func clearCollectingEnd() {self._collectingEnd = nil}

  public var end: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _end ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {self._end = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _start: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _collectingStart: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _collectingEnd: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _end: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V2_CompanyBalance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var companyID: Int64 = 0

  /// Balance of starpoints...
  public var actualBalance: Int32 = 0

  public var totalCollected: Int64 = 0

  public var movementsCount: Int32 = 0

  public var companyName: String = String()

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Starclub_V2_PointMovementArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Metro_Starclub_V2_PointMovement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Starclub_V2_PointMovement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var data: Metro_Starclub_V2_PointMovement.OneOf_Data? = nil

  public var collect: Metro_Starclub_V2_PointMovement.CollectingData {
    get {
      if case .collect(let v)? = data {return v}
      return Metro_Starclub_V2_PointMovement.CollectingData()
    }
    set {data = .collect(newValue)}
  }

  public var spending: Metro_Starclub_V2_PointMovement.SpendingData {
    get {
      if case .spending(let v)? = data {return v}
      return Metro_Starclub_V2_PointMovement.SpendingData()
    }
    set {data = .spending(newValue)}
  }

  public var correction: Metro_Starclub_V2_PointMovement.CorrectionData {
    get {
      if case .correction(let v)? = data {return v}
      return Metro_Starclub_V2_PointMovement.CorrectionData()
    }
    set {data = .correction(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    case collect(Metro_Starclub_V2_PointMovement.CollectingData)
    case spending(Metro_Starclub_V2_PointMovement.SpendingData)
    case correction(Metro_Starclub_V2_PointMovement.CorrectionData)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Starclub_V2_PointMovement.OneOf_Data, rhs: Metro_Starclub_V2_PointMovement.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.collect, .collect): return {
        guard case .collect(let l) = lhs, case .collect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.spending, .spending): return {
        guard case .spending(let l) = lhs, case .spending(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.correction, .correction): return {
        guard case .correction(let l) = lhs, case .correction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct CollectingData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pointsCollected: Int32 = 0

    public var amount: Double = 0

    public var data: Metro_Starclub_V2_PointMovement.CollectingData.OneOf_Data? = nil

    public var fileData: Metro_Starclub_V2_PointMovement.CollectingData.File {
      get {
        if case .fileData(let v)? = data {return v}
        return Metro_Starclub_V2_PointMovement.CollectingData.File()
      }
      set {data = .fileData(newValue)}
    }

    public var invoiceData: Metro_Starclub_V2_PointMovement.CollectingData.Invoice {
      get {
        if case .invoiceData(let v)? = data {return v}
        return Metro_Starclub_V2_PointMovement.CollectingData.Invoice()
      }
      set {data = .invoiceData(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Data: Equatable {
      case fileData(Metro_Starclub_V2_PointMovement.CollectingData.File)
      case invoiceData(Metro_Starclub_V2_PointMovement.CollectingData.Invoice)

    #if !swift(>=4.1)
      public static func ==(lhs: Metro_Starclub_V2_PointMovement.CollectingData.OneOf_Data, rhs: Metro_Starclub_V2_PointMovement.CollectingData.OneOf_Data) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.fileData, .fileData): return {
          guard case .fileData(let l) = lhs, case .fileData(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.invoiceData, .invoiceData): return {
          guard case .invoiceData(let l) = lhs, case .invoiceData(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct File {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var fileName: String = String()

      public var fileRecordID: String = String()

      public var fileValue: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Invoice {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var invoiceID: String = String()

      /// Optional, because invoice have user optional.
      public var invoiceUser: SwiftProtobuf.Google_Protobuf_Int64Value {
        get {return _invoiceUser ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
        set {_invoiceUser = newValue}
      }
      /// Returns true if `invoiceUser` has been explicitly set.
      public var hasInvoiceUser: Bool {return self._invoiceUser != nil}
      /// Clears the value of `invoiceUser`. Subsequent reads from it will return its default value.
      public mutating func clearInvoiceUser() {self._invoiceUser = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _invoiceUser: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    }

    public init() {}
  }

  public struct SpendingData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pointsSpent: Int32 = 0

    public var couponID: Appelis_UUID {
      get {return _couponID ?? Appelis_UUID()}
      set {_couponID = newValue}
    }
    /// Returns true if `couponID` has been explicitly set.
    public var hasCouponID: Bool {return self._couponID != nil}
    /// Clears the value of `couponID`. Subsequent reads from it will return its default value.
    public mutating func clearCouponID() {self._couponID = nil}

    public var couponName: String = String()

    public var userID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _couponID: Appelis_UUID? = nil
  }

  public struct CorrectionData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var points: Int32 = 0

    public var description_p: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Metro_Starclub_V2_ApplyError: @unchecked Sendable {}
extension Metro_Starclub_V2_CouponUsageType: @unchecked Sendable {}
extension Metro_Starclub_V2_ApplicationIdentifier: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignDescriptionRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignDescriptionResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCampaignDescriptionResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_GetPointsSummaryRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_GetPointsSummaryResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_GetPointsSummaryResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_PointsSummary: @unchecked Sendable {}
extension Metro_Starclub_V2_ApplyCouponRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_ApplyCouponResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_ApplyCouponResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCouponByIdRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCouponByIdResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCouponByIdResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCouponsRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCouponsResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_GetCouponsResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_CompanyCouponArray: @unchecked Sendable {}
extension Metro_Starclub_V2_CompanyCoupon: @unchecked Sendable {}
extension Metro_Starclub_V2_Usage: @unchecked Sendable {}
extension Metro_Starclub_V2_Coupon: @unchecked Sendable {}
extension Metro_Starclub_V2_CouponUsagePlace: @unchecked Sendable {}
extension Metro_Starclub_V2_Price: @unchecked Sendable {}
extension Metro_Starclub_V2_GetPointMovementsRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_GetPointMovementsResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_GetPointMovementsResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_GetStatusRequest: @unchecked Sendable {}
extension Metro_Starclub_V2_GetStatusResponse: @unchecked Sendable {}
extension Metro_Starclub_V2_GetStatusResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Starclub_V2_GetStatusResponse.StatusError: @unchecked Sendable {}
extension Metro_Starclub_V2_CampaignStatus: @unchecked Sendable {}
extension Metro_Starclub_V2_Campaign: @unchecked Sendable {}
extension Metro_Starclub_V2_CampaignRule: @unchecked Sendable {}
extension Metro_Starclub_V2_CampaignRange: @unchecked Sendable {}
extension Metro_Starclub_V2_CompanyBalance: @unchecked Sendable {}
extension Metro_Starclub_V2_PointMovementArray: @unchecked Sendable {}
extension Metro_Starclub_V2_PointMovement: @unchecked Sendable {}
extension Metro_Starclub_V2_PointMovement.OneOf_Data: @unchecked Sendable {}
extension Metro_Starclub_V2_PointMovement.CollectingData: @unchecked Sendable {}
extension Metro_Starclub_V2_PointMovement.CollectingData.OneOf_Data: @unchecked Sendable {}
extension Metro_Starclub_V2_PointMovement.CollectingData.File: @unchecked Sendable {}
extension Metro_Starclub_V2_PointMovement.CollectingData.Invoice: @unchecked Sendable {}
extension Metro_Starclub_V2_PointMovement.SpendingData: @unchecked Sendable {}
extension Metro_Starclub_V2_PointMovement.CorrectionData: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "metro.starclub.v2"

extension Metro_Starclub_V2_ApplyError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INSUFFICIENT_POINTS"),
    2: .same(proto: "USER_BLOCKED"),
    3: .same(proto: "THRESHOLD_NOT_HIT"),
  ]
}

extension Metro_Starclub_V2_CouponUsageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_COUPON_USAGE"),
    1: .same(proto: "UNLIMITED"),
    2: .same(proto: "LIMITED"),
    3: .same(proto: "PERSISTENT"),
  ]
}

extension Metro_Starclub_V2_ApplicationIdentifier: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_APPLICATION_IDENTIFIER"),
    1: .same(proto: "VOUCHER"),
    2: .same(proto: "ITEM_DISCOUNT"),
    3: .same(proto: "VOUCHER_AND_ITEM_DISCOUNT"),
  ]
}

extension Metro_Starclub_V2_GetCampaignDescriptionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignDescriptionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "lang"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.lang) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.lang != .unknown {
      try visitor.visitSingularEnumField(value: self.lang, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCampaignDescriptionRequest, rhs: Metro_Starclub_V2_GetCampaignDescriptionRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.lang != rhs.lang {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetCampaignDescriptionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignDescriptionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCampaignDescriptionResponse, rhs: Metro_Starclub_V2_GetCampaignDescriptionResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetPointsSummaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPointsSummaryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetPointsSummaryRequest, rhs: Metro_Starclub_V2_GetPointsSummaryRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetPointsSummaryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPointsSummaryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "summary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V2_PointsSummary?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .summary(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .summary(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .summary?: try {
      guard case .summary(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetPointsSummaryResponse, rhs: Metro_Starclub_V2_GetPointsSummaryResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PointsSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointsSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "totalCollectedPoints"),
    2: .same(proto: "spentPoints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.totalCollectedPoints) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.spentPoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.totalCollectedPoints != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalCollectedPoints, fieldNumber: 1)
    }
    if self.spentPoints != 0 {
      try visitor.visitSingularUInt32Field(value: self.spentPoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PointsSummary, rhs: Metro_Starclub_V2_PointsSummary) -> Bool {
    if lhs.totalCollectedPoints != rhs.totalCollectedPoints {return false}
    if lhs.spentPoints != rhs.spentPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_ApplyCouponRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplyCouponRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "couponId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._couponID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._couponID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_ApplyCouponRequest, rhs: Metro_Starclub_V2_ApplyCouponRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._couponID != rhs._couponID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_ApplyCouponResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplyCouponResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "applyErr"),
    3: .same(proto: "usage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V2_ApplyError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .applyErr(v)
        }
      }()
      case 3: try {
        var v: Metro_Starclub_V2_Usage?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .usage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .usage(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .applyErr?: try {
      guard case .applyErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .usage?: try {
      guard case .usage(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_ApplyCouponResponse, rhs: Metro_Starclub_V2_ApplyCouponResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetCouponByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCouponByIdRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "couponId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._couponID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._couponID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCouponByIdRequest, rhs: Metro_Starclub_V2_GetCouponByIdRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs._couponID != rhs._couponID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetCouponByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCouponByIdResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V2_CompanyCoupon?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCouponByIdResponse, rhs: Metro_Starclub_V2_GetCouponByIdResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetCouponsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCouponsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCouponsRequest, rhs: Metro_Starclub_V2_GetCouponsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetCouponsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCouponsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V2_CompanyCouponArray?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetCouponsResponse, rhs: Metro_Starclub_V2_GetCouponsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_CompanyCouponArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyCouponArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_CompanyCouponArray, rhs: Metro_Starclub_V2_CompanyCouponArray) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_CompanyCoupon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyCoupon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coupon"),
    2: .same(proto: "usage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coupon) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._usage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coupon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._usage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_CompanyCoupon, rhs: Metro_Starclub_V2_CompanyCoupon) -> Bool {
    if lhs._coupon != rhs._coupon {return false}
    if lhs._usage != rhs._usage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_Usage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Usage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "createdAt"),
    2: .same(proto: "validUntil"),
    3: .same(proto: "ean"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validUntil) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ean) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._validUntil {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.ean.isEmpty {
      try visitor.visitSingularStringField(value: self.ean, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_Usage, rhs: Metro_Starclub_V2_Usage) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._validUntil != rhs._validUntil {return false}
    if lhs.ean != rhs.ean {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_Coupon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Coupon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "pictureUrl"),
    4: .same(proto: "standardPrice"),
    5: .same(proto: "starclubPrice"),
    6: .same(proto: "actionText"),
    7: .same(proto: "starPointPrice"),
    8: .same(proto: "description"),
    9: .same(proto: "validTo"),
    10: .same(proto: "application"),
    11: .same(proto: "usageType"),
    12: .same(proto: "maximalUse"),
    13: .same(proto: "alreadyUsed"),
    14: .same(proto: "usagePlace"),
  ]

  fileprivate class _StorageClass {
    var _id: Appelis_UUID? = nil
    var _name: String = String()
    var _pictureURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _standardPrice: Metro_Starclub_V2_Price? = nil
    var _starclubPrice: Metro_Starclub_V2_Price? = nil
    var _actionText: String = String()
    var _starPointPrice: UInt32 = 0
    var _description_p: Data = Data()
    var _validTo: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _application: Metro_Starclub_V2_ApplicationIdentifier = .unknownApplicationIdentifier
    var _usageType: Metro_Starclub_V2_CouponUsageType = .unknownCouponUsage
    var _maximalUse: UInt32 = 0
    var _alreadyUsed: UInt32 = 0
    var _usagePlace: Metro_Starclub_V2_CouponUsagePlace? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _pictureURL = source._pictureURL
      _standardPrice = source._standardPrice
      _starclubPrice = source._starclubPrice
      _actionText = source._actionText
      _starPointPrice = source._starPointPrice
      _description_p = source._description_p
      _validTo = source._validTo
      _application = source._application
      _usageType = source._usageType
      _maximalUse = source._maximalUse
      _alreadyUsed = source._alreadyUsed
      _usagePlace = source._usagePlace
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._pictureURL) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._standardPrice) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._starclubPrice) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._actionText) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._starPointPrice) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._description_p) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._validTo) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._application) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._usageType) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._maximalUse) }()
        case 13: try { try decoder.decodeSingularUInt32Field(value: &_storage._alreadyUsed) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._usagePlace) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._pictureURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._standardPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._starclubPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._actionText.isEmpty {
        try visitor.visitSingularStringField(value: _storage._actionText, fieldNumber: 6)
      }
      if _storage._starPointPrice != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._starPointPrice, fieldNumber: 7)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._description_p, fieldNumber: 8)
      }
      try { if let v = _storage._validTo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._application != .unknownApplicationIdentifier {
        try visitor.visitSingularEnumField(value: _storage._application, fieldNumber: 10)
      }
      if _storage._usageType != .unknownCouponUsage {
        try visitor.visitSingularEnumField(value: _storage._usageType, fieldNumber: 11)
      }
      if _storage._maximalUse != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maximalUse, fieldNumber: 12)
      }
      if _storage._alreadyUsed != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._alreadyUsed, fieldNumber: 13)
      }
      try { if let v = _storage._usagePlace {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_Coupon, rhs: Metro_Starclub_V2_Coupon) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._pictureURL != rhs_storage._pictureURL {return false}
        if _storage._standardPrice != rhs_storage._standardPrice {return false}
        if _storage._starclubPrice != rhs_storage._starclubPrice {return false}
        if _storage._actionText != rhs_storage._actionText {return false}
        if _storage._starPointPrice != rhs_storage._starPointPrice {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._validTo != rhs_storage._validTo {return false}
        if _storage._application != rhs_storage._application {return false}
        if _storage._usageType != rhs_storage._usageType {return false}
        if _storage._maximalUse != rhs_storage._maximalUse {return false}
        if _storage._alreadyUsed != rhs_storage._alreadyUsed {return false}
        if _storage._usagePlace != rhs_storage._usagePlace {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_CouponUsagePlace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CouponUsagePlace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pictureUrl"),
    2: .same(proto: "translation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pictureURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.translation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pictureURL.isEmpty {
      try visitor.visitSingularStringField(value: self.pictureURL, fieldNumber: 1)
    }
    if !self.translation.isEmpty {
      try visitor.visitSingularStringField(value: self.translation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_CouponUsagePlace, rhs: Metro_Starclub_V2_CouponUsagePlace) -> Bool {
    if lhs.pictureURL != rhs.pictureURL {return false}
    if lhs.translation != rhs.translation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_Price: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Price"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "valueTax"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.valueTax) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if self.valueTax != 0 {
      try visitor.visitSingularDoubleField(value: self.valueTax, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_Price, rhs: Metro_Starclub_V2_Price) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.valueTax != rhs.valueTax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetPointMovementsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPointMovementsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetPointMovementsRequest, rhs: Metro_Starclub_V2_GetPointMovementsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetPointMovementsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPointMovementsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V2_PointMovementArray?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetPointMovementsResponse, rhs: Metro_Starclub_V2_GetPointMovementsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetStatusRequest, rhs: Metro_Starclub_V2_GetStatusRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tokenErr"),
    3: .same(proto: "statusErr"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Identity_Common_V1_TokenError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .tokenErr(v)
        }
      }()
      case 2: try {
        var v: Metro_Starclub_V2_CampaignStatus?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .status(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .status(v)
        }
      }()
      case 3: try {
        var v: Metro_Starclub_V2_GetStatusResponse.StatusError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .statusErr(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .tokenErr?: try {
      guard case .tokenErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .status?: try {
      guard case .status(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .statusErr?: try {
      guard case .statusErr(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_GetStatusResponse, rhs: Metro_Starclub_V2_GetStatusResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_GetStatusResponse.StatusError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "USER_BLOCKED"),
  ]
}

extension Metro_Starclub_V2_CampaignStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CampaignStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "campaign"),
    2: .same(proto: "balance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._campaign) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._balance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._campaign {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._balance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_CampaignStatus, rhs: Metro_Starclub_V2_CampaignStatus) -> Bool {
    if lhs._campaign != rhs._campaign {return false}
    if lhs._balance != rhs._balance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_Campaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Campaign"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "range"),
    3: .same(proto: "pictureUrl"),
    4: .same(proto: "rule"),
    5: .same(proto: "fullRulesUrl"),
    6: .same(proto: "updatedAt"),
    7: .same(proto: "minCollectedThreshold"),
  ]

  fileprivate class _StorageClass {
    var _id: Appelis_UUID? = nil
    var _range: Metro_Starclub_V2_CampaignRange? = nil
    var _pictureURL: String = String()
    var _rule: Metro_Starclub_V2_CampaignRule? = nil
    var _fullRulesURL: String = String()
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _minCollectedThreshold: SwiftProtobuf.Google_Protobuf_Int64Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _range = source._range
      _pictureURL = source._pictureURL
      _rule = source._rule
      _fullRulesURL = source._fullRulesURL
      _updatedAt = source._updatedAt
      _minCollectedThreshold = source._minCollectedThreshold
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._range) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._pictureURL) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._rule) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._fullRulesURL) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._minCollectedThreshold) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._range {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._pictureURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pictureURL, fieldNumber: 3)
      }
      try { if let v = _storage._rule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._fullRulesURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._fullRulesURL, fieldNumber: 5)
      }
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._minCollectedThreshold {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_Campaign, rhs: Metro_Starclub_V2_Campaign) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._range != rhs_storage._range {return false}
        if _storage._pictureURL != rhs_storage._pictureURL {return false}
        if _storage._rule != rhs_storage._rule {return false}
        if _storage._fullRulesURL != rhs_storage._fullRulesURL {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._minCollectedThreshold != rhs_storage._minCollectedThreshold {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_CampaignRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CampaignRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invoiceAmount"),
    2: .same(proto: "clubPoints"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.invoiceAmount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.clubPoints) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.invoiceAmount != 0 {
      try visitor.visitSingularDoubleField(value: self.invoiceAmount, fieldNumber: 1)
    }
    if self.clubPoints != 0 {
      try visitor.visitSingularInt32Field(value: self.clubPoints, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_CampaignRule, rhs: Metro_Starclub_V2_CampaignRule) -> Bool {
    if lhs.invoiceAmount != rhs.invoiceAmount {return false}
    if lhs.clubPoints != rhs.clubPoints {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_CampaignRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CampaignRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    4: .same(proto: "collectingStart"),
    2: .same(proto: "collectingEnd"),
    3: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._start) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._collectingEnd) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._end) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._collectingStart) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._collectingEnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._collectingStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_CampaignRange, rhs: Metro_Starclub_V2_CampaignRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._collectingStart != rhs._collectingStart {return false}
    if lhs._collectingEnd != rhs._collectingEnd {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_CompanyBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyBalance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "companyId"),
    2: .same(proto: "actualBalance"),
    6: .same(proto: "totalCollected"),
    5: .same(proto: "movementsCount"),
    3: .same(proto: "companyName"),
    4: .same(proto: "updatedAt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.companyID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.actualBalance) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.companyName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.movementsCount) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.totalCollected) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.companyID != 0 {
      try visitor.visitSingularInt64Field(value: self.companyID, fieldNumber: 1)
    }
    if self.actualBalance != 0 {
      try visitor.visitSingularInt32Field(value: self.actualBalance, fieldNumber: 2)
    }
    if !self.companyName.isEmpty {
      try visitor.visitSingularStringField(value: self.companyName, fieldNumber: 3)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.movementsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.movementsCount, fieldNumber: 5)
    }
    if self.totalCollected != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCollected, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_CompanyBalance, rhs: Metro_Starclub_V2_CompanyBalance) -> Bool {
    if lhs.companyID != rhs.companyID {return false}
    if lhs.actualBalance != rhs.actualBalance {return false}
    if lhs.totalCollected != rhs.totalCollected {return false}
    if lhs.movementsCount != rhs.movementsCount {return false}
    if lhs.companyName != rhs.companyName {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PointMovementArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointMovementArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PointMovementArray, rhs: Metro_Starclub_V2_PointMovementArray) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PointMovement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointMovement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "createdAt"),
    3: .same(proto: "collect"),
    4: .same(proto: "spending"),
    5: .same(proto: "correction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try {
        var v: Metro_Starclub_V2_PointMovement.CollectingData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .collect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .collect(v)
        }
      }()
      case 4: try {
        var v: Metro_Starclub_V2_PointMovement.SpendingData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .spending(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .spending(v)
        }
      }()
      case 5: try {
        var v: Metro_Starclub_V2_PointMovement.CorrectionData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .correction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .correction(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.data {
    case .collect?: try {
      guard case .collect(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .spending?: try {
      guard case .spending(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .correction?: try {
      guard case .correction(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PointMovement, rhs: Metro_Starclub_V2_PointMovement) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PointMovement.CollectingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_PointMovement.protoMessageName + ".CollectingData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pointsCollected"),
    2: .same(proto: "amount"),
    3: .same(proto: "fileData"),
    4: .same(proto: "invoiceData"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pointsCollected) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.amount) }()
      case 3: try {
        var v: Metro_Starclub_V2_PointMovement.CollectingData.File?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .fileData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .fileData(v)
        }
      }()
      case 4: try {
        var v: Metro_Starclub_V2_PointMovement.CollectingData.Invoice?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .invoiceData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .invoiceData(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pointsCollected != 0 {
      try visitor.visitSingularInt32Field(value: self.pointsCollected, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularDoubleField(value: self.amount, fieldNumber: 2)
    }
    switch self.data {
    case .fileData?: try {
      guard case .fileData(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .invoiceData?: try {
      guard case .invoiceData(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PointMovement.CollectingData, rhs: Metro_Starclub_V2_PointMovement.CollectingData) -> Bool {
    if lhs.pointsCollected != rhs.pointsCollected {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PointMovement.CollectingData.File: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_PointMovement.CollectingData.protoMessageName + ".File"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fileName"),
    2: .same(proto: "fileRecordId"),
    3: .same(proto: "fileValue"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fileRecordID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fileValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 1)
    }
    if !self.fileRecordID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileRecordID, fieldNumber: 2)
    }
    if !self.fileValue.isEmpty {
      try visitor.visitSingularStringField(value: self.fileValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PointMovement.CollectingData.File, rhs: Metro_Starclub_V2_PointMovement.CollectingData.File) -> Bool {
    if lhs.fileName != rhs.fileName {return false}
    if lhs.fileRecordID != rhs.fileRecordID {return false}
    if lhs.fileValue != rhs.fileValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PointMovement.CollectingData.Invoice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_PointMovement.CollectingData.protoMessageName + ".Invoice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "invoiceId"),
    4: .same(proto: "invoiceUser"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.invoiceID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._invoiceUser) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.invoiceID.isEmpty {
      try visitor.visitSingularStringField(value: self.invoiceID, fieldNumber: 2)
    }
    try { if let v = self._invoiceUser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PointMovement.CollectingData.Invoice, rhs: Metro_Starclub_V2_PointMovement.CollectingData.Invoice) -> Bool {
    if lhs.invoiceID != rhs.invoiceID {return false}
    if lhs._invoiceUser != rhs._invoiceUser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PointMovement.SpendingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_PointMovement.protoMessageName + ".SpendingData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pointsSpent"),
    2: .same(proto: "couponId"),
    3: .same(proto: "couponName"),
    4: .same(proto: "userId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pointsSpent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._couponID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.couponName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pointsSpent != 0 {
      try visitor.visitSingularInt32Field(value: self.pointsSpent, fieldNumber: 1)
    }
    try { if let v = self._couponID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.couponName.isEmpty {
      try visitor.visitSingularStringField(value: self.couponName, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PointMovement.SpendingData, rhs: Metro_Starclub_V2_PointMovement.SpendingData) -> Bool {
    if lhs.pointsSpent != rhs.pointsSpent {return false}
    if lhs._couponID != rhs._couponID {return false}
    if lhs.couponName != rhs.couponName {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Starclub_V2_PointMovement.CorrectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Starclub_V2_PointMovement.protoMessageName + ".CorrectionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Starclub_V2_PointMovement.CorrectionData, rhs: Metro_Starclub_V2_PointMovement.CorrectionData) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
