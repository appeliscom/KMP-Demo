// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: loyalty/loyalty.data.v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Metro_Loyalty_Data_V1_UserLoyaltyStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownLoyaltyStatus // = 0
  case activeLoyaltyStatus // = 1
  case blockedLoyaltyStatus // = 2
  case blockedByExecLoyaltyStatus // = 3
  case blacklistedLoyaltyStatus // = 4
  case terminatedLoyaltyStatus // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownLoyaltyStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownLoyaltyStatus
    case 1: self = .activeLoyaltyStatus
    case 2: self = .blockedLoyaltyStatus
    case 3: self = .blockedByExecLoyaltyStatus
    case 4: self = .blacklistedLoyaltyStatus
    case 5: self = .terminatedLoyaltyStatus
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownLoyaltyStatus: return 0
    case .activeLoyaltyStatus: return 1
    case .blockedLoyaltyStatus: return 2
    case .blockedByExecLoyaltyStatus: return 3
    case .blacklistedLoyaltyStatus: return 4
    case .terminatedLoyaltyStatus: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Loyalty_Data_V1_UserLoyaltyStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_Data_V1_UserLoyaltyStatus] = [
    .unknownLoyaltyStatus,
    .activeLoyaltyStatus,
    .blockedLoyaltyStatus,
    .blockedByExecLoyaltyStatus,
    .blacklistedLoyaltyStatus,
    .terminatedLoyaltyStatus,
  ]
}

#endif  // swift(>=4.2)

public enum Metro_Loyalty_Data_V1_ApplicationIdentifier: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownAppID // = 0
  case voucherAppID // = 1
  case itemDiscountAppID // = 2
  case voucherAndItemDiscountAppID // = 3
  case academyCodeAppID // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownAppID
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownAppID
    case 1: self = .voucherAppID
    case 2: self = .itemDiscountAppID
    case 3: self = .voucherAndItemDiscountAppID
    case 4: self = .academyCodeAppID
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownAppID: return 0
    case .voucherAppID: return 1
    case .itemDiscountAppID: return 2
    case .voucherAndItemDiscountAppID: return 3
    case .academyCodeAppID: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Loyalty_Data_V1_ApplicationIdentifier: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_Data_V1_ApplicationIdentifier] = [
    .unknownAppID,
    .voucherAppID,
    .itemDiscountAppID,
    .voucherAndItemDiscountAppID,
    .academyCodeAppID,
  ]
}

#endif  // swift(>=4.2)

public enum Metro_Loyalty_Data_V1_RedeemType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknownRedeem // = 0
  case unlimitedRedeem // = 1
  case limitedRedeem // = 2
  case persistentRedeem // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownRedeem
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownRedeem
    case 1: self = .unlimitedRedeem
    case 2: self = .limitedRedeem
    case 3: self = .persistentRedeem
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownRedeem: return 0
    case .unlimitedRedeem: return 1
    case .limitedRedeem: return 2
    case .persistentRedeem: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Loyalty_Data_V1_RedeemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_Data_V1_RedeemType] = [
    .unknownRedeem,
    .unlimitedRedeem,
    .limitedRedeem,
    .persistentRedeem,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Loyalty_Data_V1_LoyaltyOverview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userLoyaltyStatus: Metro_Loyalty_Data_V1_UserLoyaltyStatus = .unknownLoyaltyStatus

  public var info: Metro_Loyalty_Data_V1_LoyaltyProgramInfo {
    get {return _info ?? Metro_Loyalty_Data_V1_LoyaltyProgramInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Metro_Loyalty_Data_V1_LoyaltyProgramInfo? = nil
}

public struct Metro_Loyalty_Data_V1_LoyaltyProgramInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var policyStatus: Metro_Loyalty_Data_V1_LoyaltyProgramInfo.PolicyStatus = .unknownPolicyStatus

  public var companyBalance: Metro_Loyalty_Data_V1_CompanyBalance {
    get {return _companyBalance ?? Metro_Loyalty_Data_V1_CompanyBalance()}
    set {_companyBalance = newValue}
  }
  /// Returns true if `companyBalance` has been explicitly set.
  public var hasCompanyBalance: Bool {return self._companyBalance != nil}
  /// Clears the value of `companyBalance`. Subsequent reads from it will return its default value.
  public mutating func clearCompanyBalance() {self._companyBalance = nil}

  public var rewards: [Metro_Loyalty_Data_V1_RewardPreview] = []

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  public var isExec: Bool = false

  public var academyTickets: [Metro_Loyalty_Data_V1_AcademyTicket] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PolicyStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknownPolicyStatus // = 0
    case approvedPolicyStatus // = 1
    case unapprovedPolicyStatus // = 2
    case unapprovedExecPolicyStatus // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownPolicyStatus
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownPolicyStatus
      case 1: self = .approvedPolicyStatus
      case 2: self = .unapprovedPolicyStatus
      case 3: self = .unapprovedExecPolicyStatus
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownPolicyStatus: return 0
      case .approvedPolicyStatus: return 1
      case .unapprovedPolicyStatus: return 2
      case .unapprovedExecPolicyStatus: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _companyBalance: Metro_Loyalty_Data_V1_CompanyBalance? = nil
  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Metro_Loyalty_Data_V1_LoyaltyProgramInfo.PolicyStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_Data_V1_LoyaltyProgramInfo.PolicyStatus] = [
    .unknownPolicyStatus,
    .approvedPolicyStatus,
    .unapprovedPolicyStatus,
    .unapprovedExecPolicyStatus,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Loyalty_Data_V1_AcademyTicket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  public var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  public mutating func clearDate() {self._date = nil}

  public var name: String = String()

  public var link: String = String()

  public var orderID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Loyalty_Data_V1_CompanyBalance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var companyName: String = String()

  public var actualPoints: UInt32 = 0

  public var totalPoints: UInt32 = 0

  public var spentPoints: UInt32 = 0

  public var expiredPoints: UInt32 = 0

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Loyalty_Data_V1_RewardPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var name: String = String()

  public var pictureURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _pictureURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_pictureURL = newValue}
  }
  /// Returns true if `pictureURL` has been explicitly set.
  public var hasPictureURL: Bool {return self._pictureURL != nil}
  /// Clears the value of `pictureURL`. Subsequent reads from it will return its default value.
  public mutating func clearPictureURL() {self._pictureURL = nil}

  public var pointPrice: UInt32 = 0

  public var actionText: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _actionText ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_actionText = newValue}
  }
  /// Returns true if `actionText` has been explicitly set.
  public var hasActionText: Bool {return self._actionText != nil}
  /// Clears the value of `actionText`. Subsequent reads from it will return its default value.
  public mutating func clearActionText() {self._actionText = nil}

  public var validFrom: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _validFrom ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_validFrom = newValue}
  }
  /// Returns true if `validFrom` has been explicitly set.
  public var hasValidFrom: Bool {return self._validFrom != nil}
  /// Clears the value of `validFrom`. Subsequent reads from it will return its default value.
  public mutating func clearValidFrom() {self._validFrom = nil}

  public var validTo: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _validTo ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_validTo = newValue}
  }
  /// Returns true if `validTo` has been explicitly set.
  public var hasValidTo: Bool {return self._validTo != nil}
  /// Clears the value of `validTo`. Subsequent reads from it will return its default value.
  public mutating func clearValidTo() {self._validTo = nil}

  public var limitedCount: Metro_Loyalty_Data_V1_LimitedCount {
    get {return _limitedCount ?? Metro_Loyalty_Data_V1_LimitedCount()}
    set {_limitedCount = newValue}
  }
  /// Returns true if `limitedCount` has been explicitly set.
  public var hasLimitedCount: Bool {return self._limitedCount != nil}
  /// Clears the value of `limitedCount`. Subsequent reads from it will return its default value.
  public mutating func clearLimitedCount() {self._limitedCount = nil}

  public var redeemType: Metro_Loyalty_Data_V1_RedeemType = .unknownRedeem

  public var academyCodeRedeemed: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _pictureURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _actionText: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _validFrom: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _validTo: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _limitedCount: Metro_Loyalty_Data_V1_LimitedCount? = nil
}

public struct Metro_Loyalty_Data_V1_LimitedCount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var total: UInt32 = 0

  public var alreadyUsed: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Loyalty_Data_V1_PointExpirationArray {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pointExpirations: [Metro_Loyalty_Data_V1_PointExpiration] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Loyalty_Data_V1_PointExpiration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var points: UInt32 = 0

  public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiresAt = newValue}
  }
  /// Returns true if `expiresAt` has been explicitly set.
  public var hasExpiresAt: Bool {return self._expiresAt != nil}
  /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
  public mutating func clearExpiresAt() {self._expiresAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Loyalty_Data_V1_PointMovement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Metro_Loyalty_Data_V1_PointMovement.OneOf_Data? = nil

  public var purchaseOrReturn: Metro_Loyalty_Data_V1_PointMovement.PurchaseOrReturn {
    get {
      if case .purchaseOrReturn(let v)? = data {return v}
      return Metro_Loyalty_Data_V1_PointMovement.PurchaseOrReturn()
    }
    set {data = .purchaseOrReturn(newValue)}
  }

  public var pointRedeem: Metro_Loyalty_Data_V1_PointMovement.PointRedeem {
    get {
      if case .pointRedeem(let v)? = data {return v}
      return Metro_Loyalty_Data_V1_PointMovement.PointRedeem()
    }
    set {data = .pointRedeem(newValue)}
  }

  public var adminCorrection: Metro_Loyalty_Data_V1_PointMovement.AdminCorrection {
    get {
      if case .adminCorrection(let v)? = data {return v}
      return Metro_Loyalty_Data_V1_PointMovement.AdminCorrection()
    }
    set {data = .adminCorrection(newValue)}
  }

  public var expiration: Metro_Loyalty_Data_V1_PointMovement.Expiration {
    get {
      if case .expiration(let v)? = data {return v}
      return Metro_Loyalty_Data_V1_PointMovement.Expiration()
    }
    set {data = .expiration(newValue)}
  }

  public var info: Metro_Loyalty_Data_V1_PointMovement.Info {
    get {
      if case .info(let v)? = data {return v}
      return Metro_Loyalty_Data_V1_PointMovement.Info()
    }
    set {data = .info(newValue)}
  }

  public var academyCodeRedeem: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeRedeem {
    get {
      if case .academyCodeRedeem(let v)? = data {return v}
      return Metro_Loyalty_Data_V1_PointMovement.AcademyCodeRedeem()
    }
    set {data = .academyCodeRedeem(newValue)}
  }

  public var academyCodeUsage: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeUsage {
    get {
      if case .academyCodeUsage(let v)? = data {return v}
      return Metro_Loyalty_Data_V1_PointMovement.AcademyCodeUsage()
    }
    set {data = .academyCodeUsage(newValue)}
  }

  public var academyCodeExpiration: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeExpiration {
    get {
      if case .academyCodeExpiration(let v)? = data {return v}
      return Metro_Loyalty_Data_V1_PointMovement.AcademyCodeExpiration()
    }
    set {data = .academyCodeExpiration(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable {
    case purchaseOrReturn(Metro_Loyalty_Data_V1_PointMovement.PurchaseOrReturn)
    case pointRedeem(Metro_Loyalty_Data_V1_PointMovement.PointRedeem)
    case adminCorrection(Metro_Loyalty_Data_V1_PointMovement.AdminCorrection)
    case expiration(Metro_Loyalty_Data_V1_PointMovement.Expiration)
    case info(Metro_Loyalty_Data_V1_PointMovement.Info)
    case academyCodeRedeem(Metro_Loyalty_Data_V1_PointMovement.AcademyCodeRedeem)
    case academyCodeUsage(Metro_Loyalty_Data_V1_PointMovement.AcademyCodeUsage)
    case academyCodeExpiration(Metro_Loyalty_Data_V1_PointMovement.AcademyCodeExpiration)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Loyalty_Data_V1_PointMovement.OneOf_Data, rhs: Metro_Loyalty_Data_V1_PointMovement.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.purchaseOrReturn, .purchaseOrReturn): return {
        guard case .purchaseOrReturn(let l) = lhs, case .purchaseOrReturn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pointRedeem, .pointRedeem): return {
        guard case .pointRedeem(let l) = lhs, case .pointRedeem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.adminCorrection, .adminCorrection): return {
        guard case .adminCorrection(let l) = lhs, case .adminCorrection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.expiration, .expiration): return {
        guard case .expiration(let l) = lhs, case .expiration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.info, .info): return {
        guard case .info(let l) = lhs, case .info(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.academyCodeRedeem, .academyCodeRedeem): return {
        guard case .academyCodeRedeem(let l) = lhs, case .academyCodeRedeem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.academyCodeUsage, .academyCodeUsage): return {
        guard case .academyCodeUsage(let l) = lhs, case .academyCodeUsage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.academyCodeExpiration, .academyCodeExpiration): return {
        guard case .academyCodeExpiration(let l) = lhs, case .academyCodeExpiration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct PurchaseOrReturn {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var amount: Double = 0

    public var points: Int32 = 0

    public var invoiceID: String = String()

    public var pointsAddedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _pointsAddedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_pointsAddedAt = newValue}
    }
    /// Returns true if `pointsAddedAt` has been explicitly set.
    public var hasPointsAddedAt: Bool {return self._pointsAddedAt != nil}
    /// Clears the value of `pointsAddedAt`. Subsequent reads from it will return its default value.
    public mutating func clearPointsAddedAt() {self._pointsAddedAt = nil}

    public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_expiresAt = newValue}
    }
    /// Returns true if `expiresAt` has been explicitly set.
    public var hasExpiresAt: Bool {return self._expiresAt != nil}
    /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
    public mutating func clearExpiresAt() {self._expiresAt = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _pointsAddedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public struct PointRedeem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var title: String = String()

    public var points: Int32 = 0

    public var redeemedBy: String = String()

    public var redeemedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _redeemedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_redeemedAt = newValue}
    }
    /// Returns true if `redeemedAt` has been explicitly set.
    public var hasRedeemedAt: Bool {return self._redeemedAt != nil}
    /// Clears the value of `redeemedAt`. Subsequent reads from it will return its default value.
    public mutating func clearRedeemedAt() {self._redeemedAt = nil}

    public var ean: String = String()

    public var custNo: String = String()

    public var storeNo: String = String()

    public var academyCode: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _academyCode ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_academyCode = newValue}
    }
    /// Returns true if `academyCode` has been explicitly set.
    public var hasAcademyCode: Bool {return self._academyCode != nil}
    /// Clears the value of `academyCode`. Subsequent reads from it will return its default value.
    public mutating func clearAcademyCode() {self._academyCode = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _redeemedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _academyCode: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  }

  public struct AdminCorrection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pointCorrection: Int32 = 0

    public var message: String = String()

    public var pointsAddedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _pointsAddedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_pointsAddedAt = newValue}
    }
    /// Returns true if `pointsAddedAt` has been explicitly set.
    public var hasPointsAddedAt: Bool {return self._pointsAddedAt != nil}
    /// Clears the value of `pointsAddedAt`. Subsequent reads from it will return its default value.
    public mutating func clearPointsAddedAt() {self._pointsAddedAt = nil}

    public var expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _expiresAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_expiresAt = newValue}
    }
    /// Returns true if `expiresAt` has been explicitly set.
    public var hasExpiresAt: Bool {return self._expiresAt != nil}
    /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
    public mutating func clearExpiresAt() {self._expiresAt = nil}

    public var idAdmin: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _idAdmin ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_idAdmin = newValue}
    }
    /// Returns true if `idAdmin` has been explicitly set.
    public var hasIDAdmin: Bool {return self._idAdmin != nil}
    /// Clears the value of `idAdmin`. Subsequent reads from it will return its default value.
    public mutating func clearIDAdmin() {self._idAdmin = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _pointsAddedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _expiresAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _idAdmin: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  }

  public struct Expiration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var expiredPoints: UInt32 = 0

    public var expiredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _expiredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_expiredAt = newValue}
    }
    /// Returns true if `expiredAt` has been explicitly set.
    public var hasExpiredAt: Bool {return self._expiredAt != nil}
    /// Clears the value of `expiredAt`. Subsequent reads from it will return its default value.
    public mutating func clearExpiredAt() {self._expiredAt = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _expiredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public struct Info {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Metro_Loyalty_Data_V1_PointMovement.Info.TypeEnum = .unknownInfoType

    public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_date = newValue}
    }
    /// Returns true if `date` has been explicitly set.
    public var hasDate: Bool {return self._date != nil}
    /// Clears the value of `date`. Subsequent reads from it will return its default value.
    public mutating func clearDate() {self._date = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknownInfoType // = 0
      case enterClapInfoType // = 1
      case exitClapInfoType // = 2
      case blockedInfoType // = 3
      case renewedInfoType // = 4
      case blacklistedInfoType // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknownInfoType
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknownInfoType
        case 1: self = .enterClapInfoType
        case 2: self = .exitClapInfoType
        case 3: self = .blockedInfoType
        case 4: self = .renewedInfoType
        case 5: self = .blacklistedInfoType
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknownInfoType: return 0
        case .enterClapInfoType: return 1
        case .exitClapInfoType: return 2
        case .blockedInfoType: return 3
        case .renewedInfoType: return 4
        case .blacklistedInfoType: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public struct AcademyCodeRedeem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var points: Int32 = 0

    public var redeemedBy: String = String()

    public var couponType: String = String()

    public var redeemedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _redeemedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_redeemedAt = newValue}
    }
    /// Returns true if `redeemedAt` has been explicitly set.
    public var hasRedeemedAt: Bool {return self._redeemedAt != nil}
    /// Clears the value of `redeemedAt`. Subsequent reads from it will return its default value.
    public mutating func clearRedeemedAt() {self._redeemedAt = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _redeemedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public struct AcademyCodeUsage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var couponType: String = String()

    public var redeemedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _redeemedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_redeemedAt = newValue}
    }
    /// Returns true if `redeemedAt` has been explicitly set.
    public var hasRedeemedAt: Bool {return self._redeemedAt != nil}
    /// Clears the value of `redeemedAt`. Subsequent reads from it will return its default value.
    public mutating func clearRedeemedAt() {self._redeemedAt = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _redeemedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public struct AcademyCodeExpiration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var couponType: String = String()

    public var expiredAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _expiredAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_expiredAt = newValue}
    }
    /// Returns true if `expiredAt` has been explicitly set.
    public var hasExpiredAt: Bool {return self._expiredAt != nil}
    /// Clears the value of `expiredAt`. Subsequent reads from it will return its default value.
    public mutating func clearExpiredAt() {self._expiredAt = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _expiredAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}
}

#if swift(>=4.2)

extension Metro_Loyalty_Data_V1_PointMovement.Info.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_Data_V1_PointMovement.Info.TypeEnum] = [
    .unknownInfoType,
    .enterClapInfoType,
    .exitClapInfoType,
    .blockedInfoType,
    .renewedInfoType,
    .blacklistedInfoType,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Loyalty_Data_V1_Reward {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _storage._id ?? Appelis_UUID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var pictureURL: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._pictureURL ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._pictureURL = newValue}
  }
  /// Returns true if `pictureURL` has been explicitly set.
  public var hasPictureURL: Bool {return _storage._pictureURL != nil}
  /// Clears the value of `pictureURL`. Subsequent reads from it will return its default value.
  public mutating func clearPictureURL() {_uniqueStorage()._pictureURL = nil}

  public var pointPrice: UInt32 {
    get {return _storage._pointPrice}
    set {_uniqueStorage()._pointPrice = newValue}
  }

  public var actionText: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _storage._actionText ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_uniqueStorage()._actionText = newValue}
  }
  /// Returns true if `actionText` has been explicitly set.
  public var hasActionText: Bool {return _storage._actionText != nil}
  /// Clears the value of `actionText`. Subsequent reads from it will return its default value.
  public mutating func clearActionText() {_uniqueStorage()._actionText = nil}

  public var validFrom: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._validFrom ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._validFrom = newValue}
  }
  /// Returns true if `validFrom` has been explicitly set.
  public var hasValidFrom: Bool {return _storage._validFrom != nil}
  /// Clears the value of `validFrom`. Subsequent reads from it will return its default value.
  public mutating func clearValidFrom() {_uniqueStorage()._validFrom = nil}

  public var validTo: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._validTo ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._validTo = newValue}
  }
  /// Returns true if `validTo` has been explicitly set.
  public var hasValidTo: Bool {return _storage._validTo != nil}
  /// Clears the value of `validTo`. Subsequent reads from it will return its default value.
  public mutating func clearValidTo() {_uniqueStorage()._validTo = nil}

  public var applicationIdentifier: Metro_Loyalty_Data_V1_ApplicationIdentifier {
    get {return _storage._applicationIdentifier}
    set {_uniqueStorage()._applicationIdentifier = newValue}
  }

  public var redeemType: Metro_Loyalty_Data_V1_RedeemType {
    get {return _storage._redeemType}
    set {_uniqueStorage()._redeemType = newValue}
  }

  public var limitedCount: Metro_Loyalty_Data_V1_LimitedCount {
    get {return _storage._limitedCount ?? Metro_Loyalty_Data_V1_LimitedCount()}
    set {_uniqueStorage()._limitedCount = newValue}
  }
  /// Returns true if `limitedCount` has been explicitly set.
  public var hasLimitedCount: Bool {return _storage._limitedCount != nil}
  /// Clears the value of `limitedCount`. Subsequent reads from it will return its default value.
  public mutating func clearLimitedCount() {_uniqueStorage()._limitedCount = nil}

  public var standardPrice: Metro_Loyalty_Data_V1_Price {
    get {return _storage._standardPrice ?? Metro_Loyalty_Data_V1_Price()}
    set {_uniqueStorage()._standardPrice = newValue}
  }
  /// Returns true if `standardPrice` has been explicitly set.
  public var hasStandardPrice: Bool {return _storage._standardPrice != nil}
  /// Clears the value of `standardPrice`. Subsequent reads from it will return its default value.
  public mutating func clearStandardPrice() {_uniqueStorage()._standardPrice = nil}

  public var loyaltyPrice: Metro_Loyalty_Data_V1_Price {
    get {return _storage._loyaltyPrice ?? Metro_Loyalty_Data_V1_Price()}
    set {_uniqueStorage()._loyaltyPrice = newValue}
  }
  /// Returns true if `loyaltyPrice` has been explicitly set.
  public var hasLoyaltyPrice: Bool {return _storage._loyaltyPrice != nil}
  /// Clears the value of `loyaltyPrice`. Subsequent reads from it will return its default value.
  public mutating func clearLoyaltyPrice() {_uniqueStorage()._loyaltyPrice = nil}

  public var description_p: Data {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var redeemPlace: Metro_Loyalty_Data_V1_RedeemPlace {
    get {return _storage._redeemPlace ?? Metro_Loyalty_Data_V1_RedeemPlace()}
    set {_uniqueStorage()._redeemPlace = newValue}
  }
  /// Returns true if `redeemPlace` has been explicitly set.
  public var hasRedeemPlace: Bool {return _storage._redeemPlace != nil}
  /// Clears the value of `redeemPlace`. Subsequent reads from it will return its default value.
  public mutating func clearRedeemPlace() {_uniqueStorage()._redeemPlace = nil}

  public var redeem: Metro_Loyalty_Data_V1_Redeem {
    get {return _storage._redeem ?? Metro_Loyalty_Data_V1_Redeem()}
    set {_uniqueStorage()._redeem = newValue}
  }
  /// Returns true if `redeem` has been explicitly set.
  public var hasRedeem: Bool {return _storage._redeem != nil}
  /// Clears the value of `redeem`. Subsequent reads from it will return its default value.
  public mutating func clearRedeem() {_uniqueStorage()._redeem = nil}

  public var level: UInt32 {
    get {return _storage._level}
    set {_uniqueStorage()._level = newValue}
  }

  public var academyCourses: [Metro_Loyalty_Data_V1_AcademyCourse] {
    get {return _storage._academyCourses}
    set {_uniqueStorage()._academyCourses = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Metro_Loyalty_Data_V1_AcademyCourse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var name: String = String()

  public var detailURL: String = String()

  public var pictureURL: String = String()

  public var applyURL: String = String()

  public var startDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  public var hasStartDate: Bool {return self._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  public mutating func clearStartDate() {self._startDate = nil}

  public var endDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  public var hasEndDate: Bool {return self._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  public mutating func clearEndDate() {self._endDate = nil}

  public var available: Bool = false

  public var price: UInt32 = 0

  public var ribbon: Metro_Loyalty_Data_V1_AcademyCourse.Ribbon {
    get {return _ribbon ?? Metro_Loyalty_Data_V1_AcademyCourse.Ribbon()}
    set {_ribbon = newValue}
  }
  /// Returns true if `ribbon` has been explicitly set.
  public var hasRibbon: Bool {return self._ribbon != nil}
  /// Clears the value of `ribbon`. Subsequent reads from it will return its default value.
  public mutating func clearRibbon() {self._ribbon = nil}

  public var category: Metro_Loyalty_Data_V1_AcademyCourse.Category {
    get {return _category ?? Metro_Loyalty_Data_V1_AcademyCourse.Category()}
    set {_category = newValue}
  }
  /// Returns true if `category` has been explicitly set.
  public var hasCategory: Bool {return self._category != nil}
  /// Clears the value of `category`. Subsequent reads from it will return its default value.
  public mutating func clearCategory() {self._category = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Ribbon {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var text: String = String()

    public var color: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Category {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var translationKey: String = String()

    public var iconURL: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _startDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _ribbon: Metro_Loyalty_Data_V1_AcademyCourse.Ribbon? = nil
  fileprivate var _category: Metro_Loyalty_Data_V1_AcademyCourse.Category? = nil
}

public struct Metro_Loyalty_Data_V1_RedeemPlace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pictureURL: String = String()

  public var translation: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Loyalty_Data_V1_Price {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Double = 0

  public var valueTax: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Loyalty_Data_V1_Redeem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var validUntil: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _validUntil ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_validUntil = newValue}
  }
  /// Returns true if `validUntil` has been explicitly set.
  public var hasValidUntil: Bool {return self._validUntil != nil}
  /// Clears the value of `validUntil`. Subsequent reads from it will return its default value.
  public mutating func clearValidUntil() {self._validUntil = nil}

  /// Ean will be populated only when now < validUntil
  public var ean: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _ean ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_ean = newValue}
  }
  /// Returns true if `ean` has been explicitly set.
  public var hasEan: Bool {return self._ean != nil}
  /// Clears the value of `ean`. Subsequent reads from it will return its default value.
  public mutating func clearEan() {self._ean = nil}

  public var validityInSeconds: UInt32 = 0

  public var academyCode: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _academyCode ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_academyCode = newValue}
  }
  /// Returns true if `academyCode` has been explicitly set.
  public var hasAcademyCode: Bool {return self._academyCode != nil}
  /// Clears the value of `academyCode`. Subsequent reads from it will return its default value.
  public mutating func clearAcademyCode() {self._academyCode = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _validUntil: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _ean: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _academyCode: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

public struct Metro_Loyalty_Data_V1_BlockListUser {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var name: String = String()

  public var surname: String = String()

  public var blocked: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Loyalty_Data_V1_CompanyBlockList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var users: [Metro_Loyalty_Data_V1_BlockListUser] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Loyalty_Data_V1_AccountPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {self._updatedAt = nil}

  public var idCompany: Int64 = 0

  public var companyName: String = String()

  public var registrationNo: String = String()

  public var status: Metro_Loyalty_Data_V1_UserLoyaltyStatus = .unknownLoyaltyStatus

  public var isPolicyApproved: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Metro_Loyalty_Data_V1_AccountDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _storage._id ?? Appelis_UUID()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  public var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  public mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  public var idCompany: Int64 {
    get {return _storage._idCompany}
    set {_uniqueStorage()._idCompany = newValue}
  }

  public var companyName: String {
    get {return _storage._companyName}
    set {_uniqueStorage()._companyName = newValue}
  }

  public var registrationNo: String {
    get {return _storage._registrationNo}
    set {_uniqueStorage()._registrationNo = newValue}
  }

  public var status: Metro_Loyalty_Data_V1_UserLoyaltyStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var isPolicyApproved: Bool {
    get {return _storage._isPolicyApproved}
    set {_uniqueStorage()._isPolicyApproved = newValue}
  }

  public var policyApprovedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._policyApprovedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._policyApprovedAt = newValue}
  }
  /// Returns true if `policyApprovedAt` has been explicitly set.
  public var hasPolicyApprovedAt: Bool {return _storage._policyApprovedAt != nil}
  /// Clears the value of `policyApprovedAt`. Subsequent reads from it will return its default value.
  public mutating func clearPolicyApprovedAt() {_uniqueStorage()._policyApprovedAt = nil}

  public var policyApprovedBy: String {
    get {return _storage._policyApprovedBy}
    set {_uniqueStorage()._policyApprovedBy = newValue}
  }

  public var statusHistory: [Metro_Loyalty_Data_V1_AccountDetail.StatusHistoryItem] {
    get {return _storage._statusHistory}
    set {_uniqueStorage()._statusHistory = newValue}
  }

  public var companyBalance: Metro_Loyalty_Data_V1_CompanyBalance {
    get {return _storage._companyBalance ?? Metro_Loyalty_Data_V1_CompanyBalance()}
    set {_uniqueStorage()._companyBalance = newValue}
  }
  /// Returns true if `companyBalance` has been explicitly set.
  public var hasCompanyBalance: Bool {return _storage._companyBalance != nil}
  /// Clears the value of `companyBalance`. Subsequent reads from it will return its default value.
  public mutating func clearCompanyBalance() {_uniqueStorage()._companyBalance = nil}

  public var level: UInt32 {
    get {return _storage._level}
    set {_uniqueStorage()._level = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct StatusHistoryItem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var status: Metro_Loyalty_Data_V1_UserLoyaltyStatus = .unknownLoyaltyStatus

    public var date: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _date ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_date = newValue}
    }
    /// Returns true if `date` has been explicitly set.
    public var hasDate: Bool {return self._date != nil}
    /// Clears the value of `date`. Subsequent reads from it will return its default value.
    public mutating func clearDate() {self._date = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _date: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Metro_Loyalty_Data_V1_Campaign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String = String()

  public var pictureURL: String = String()

  public var rule: Metro_Loyalty_Data_V1_Campaign.Rule {
    get {return _rule ?? Metro_Loyalty_Data_V1_Campaign.Rule()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  public var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  public mutating func clearRule() {self._rule = nil}

  public var notificationsConfig: Dictionary<String,Metro_Loyalty_Data_V1_Campaign.NotificationData> = [:]

  public var validity: Appelis_TimeRange {
    get {return _validity ?? Appelis_TimeRange()}
    set {_validity = newValue}
  }
  /// Returns true if `validity` has been explicitly set.
  public var hasValidity: Bool {return self._validity != nil}
  /// Clears the value of `validity`. Subsequent reads from it will return its default value.
  public mutating func clearValidity() {self._validity = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct NotificationData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var title: String = String()

    public var text: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Rule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var invoiceAmount: UInt32 = 0

    public var points: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _rule: Metro_Loyalty_Data_V1_Campaign.Rule? = nil
  fileprivate var _validity: Appelis_TimeRange? = nil
}

public struct Metro_Loyalty_Data_V1_Policy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lang: Appelis_Language = .unknown

  public var text: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Loyalty_Data_V1_PolicyVariations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var policy: [Metro_Loyalty_Data_V1_Policy] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Loyalty_Data_V1_PolicyShort {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var validFrom: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _validFrom ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_validFrom = newValue}
  }
  /// Returns true if `validFrom` has been explicitly set.
  public var hasValidFrom: Bool {return self._validFrom != nil}
  /// Clears the value of `validFrom`. Subsequent reads from it will return its default value.
  public mutating func clearValidFrom() {self._validFrom = nil}

  public var validTo: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _validTo ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_validTo = newValue}
  }
  /// Returns true if `validTo` has been explicitly set.
  public var hasValidTo: Bool {return self._validTo != nil}
  /// Clears the value of `validTo`. Subsequent reads from it will return its default value.
  public mutating func clearValidTo() {self._validTo = nil}

  public var variations: Metro_Loyalty_Data_V1_PolicyVariations {
    get {return _variations ?? Metro_Loyalty_Data_V1_PolicyVariations()}
    set {_variations = newValue}
  }
  /// Returns true if `variations` has been explicitly set.
  public var hasVariations: Bool {return self._variations != nil}
  /// Clears the value of `variations`. Subsequent reads from it will return its default value.
  public mutating func clearVariations() {self._variations = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
  fileprivate var _validFrom: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _validTo: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _variations: Metro_Loyalty_Data_V1_PolicyVariations? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Metro_Loyalty_Data_V1_UserLoyaltyStatus: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_ApplicationIdentifier: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_RedeemType: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_LoyaltyOverview: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_LoyaltyProgramInfo: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_LoyaltyProgramInfo.PolicyStatus: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_AcademyTicket: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_CompanyBalance: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_RewardPreview: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_LimitedCount: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointExpirationArray: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointExpiration: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointMovement: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointMovement.OneOf_Data: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointMovement.PurchaseOrReturn: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointMovement.PointRedeem: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointMovement.AdminCorrection: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointMovement.Expiration: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointMovement.Info: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointMovement.Info.TypeEnum: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointMovement.AcademyCodeRedeem: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointMovement.AcademyCodeUsage: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PointMovement.AcademyCodeExpiration: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_Reward: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_AcademyCourse: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_AcademyCourse.Ribbon: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_AcademyCourse.Category: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_RedeemPlace: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_Price: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_Redeem: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_BlockListUser: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_CompanyBlockList: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_AccountPreview: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_AccountDetail: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_AccountDetail.StatusHistoryItem: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_Campaign: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_Campaign.NotificationData: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_Campaign.Rule: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_Policy: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PolicyVariations: @unchecked Sendable {}
extension Metro_Loyalty_Data_V1_PolicyShort: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "metro.loyalty.data.v1"

extension Metro_Loyalty_Data_V1_UserLoyaltyStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_LOYALTY_STATUS"),
    1: .same(proto: "ACTIVE_LOYALTY_STATUS"),
    2: .same(proto: "BLOCKED_LOYALTY_STATUS"),
    3: .same(proto: "BLOCKED_BY_EXEC_LOYALTY_STATUS"),
    4: .same(proto: "BLACKLISTED_LOYALTY_STATUS"),
    5: .same(proto: "TERMINATED_LOYALTY_STATUS"),
  ]
}

extension Metro_Loyalty_Data_V1_ApplicationIdentifier: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_APP_ID"),
    1: .same(proto: "VOUCHER_APP_ID"),
    2: .same(proto: "ITEM_DISCOUNT_APP_ID"),
    3: .same(proto: "VOUCHER_AND_ITEM_DISCOUNT_APP_ID"),
    4: .same(proto: "ACADEMY_CODE_APP_ID"),
  ]
}

extension Metro_Loyalty_Data_V1_RedeemType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_REDEEM"),
    1: .same(proto: "UNLIMITED_REDEEM"),
    2: .same(proto: "LIMITED_REDEEM"),
    3: .same(proto: "PERSISTENT_REDEEM"),
  ]
}

extension Metro_Loyalty_Data_V1_LoyaltyOverview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoyaltyOverview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_loyalty_status"),
    2: .same(proto: "info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.userLoyaltyStatus) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.userLoyaltyStatus != .unknownLoyaltyStatus {
      try visitor.visitSingularEnumField(value: self.userLoyaltyStatus, fieldNumber: 1)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_LoyaltyOverview, rhs: Metro_Loyalty_Data_V1_LoyaltyOverview) -> Bool {
    if lhs.userLoyaltyStatus != rhs.userLoyaltyStatus {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_LoyaltyProgramInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoyaltyProgramInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "policy_status"),
    3: .standard(proto: "company_balance"),
    4: .same(proto: "rewards"),
    5: .standard(proto: "expires_at"),
    6: .standard(proto: "is_exec"),
    7: .standard(proto: "academy_tickets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.policyStatus) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._companyBalance) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.rewards) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isExec) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.academyTickets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.policyStatus != .unknownPolicyStatus {
      try visitor.visitSingularEnumField(value: self.policyStatus, fieldNumber: 2)
    }
    try { if let v = self._companyBalance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.rewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewards, fieldNumber: 4)
    }
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.isExec != false {
      try visitor.visitSingularBoolField(value: self.isExec, fieldNumber: 6)
    }
    if !self.academyTickets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.academyTickets, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_LoyaltyProgramInfo, rhs: Metro_Loyalty_Data_V1_LoyaltyProgramInfo) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.policyStatus != rhs.policyStatus {return false}
    if lhs._companyBalance != rhs._companyBalance {return false}
    if lhs.rewards != rhs.rewards {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.isExec != rhs.isExec {return false}
    if lhs.academyTickets != rhs.academyTickets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_LoyaltyProgramInfo.PolicyStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_POLICY_STATUS"),
    1: .same(proto: "APPROVED_POLICY_STATUS"),
    2: .same(proto: "UNAPPROVED_POLICY_STATUS"),
    3: .same(proto: "UNAPPROVED_EXEC_POLICY_STATUS"),
  ]
}

extension Metro_Loyalty_Data_V1_AcademyTicket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcademyTicket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "name"),
    3: .same(proto: "link"),
    4: .standard(proto: "order_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.link) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.orderID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.link.isEmpty {
      try visitor.visitSingularStringField(value: self.link, fieldNumber: 3)
    }
    if !self.orderID.isEmpty {
      try visitor.visitSingularStringField(value: self.orderID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_AcademyTicket, rhs: Metro_Loyalty_Data_V1_AcademyTicket) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs.name != rhs.name {return false}
    if lhs.link != rhs.link {return false}
    if lhs.orderID != rhs.orderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_CompanyBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyBalance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "company_name"),
    2: .standard(proto: "actual_points"),
    3: .standard(proto: "total_points"),
    4: .standard(proto: "spent_points"),
    5: .standard(proto: "expired_points"),
    6: .standard(proto: "updated_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.companyName) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.actualPoints) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.totalPoints) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.spentPoints) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.expiredPoints) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.companyName.isEmpty {
      try visitor.visitSingularStringField(value: self.companyName, fieldNumber: 1)
    }
    if self.actualPoints != 0 {
      try visitor.visitSingularUInt32Field(value: self.actualPoints, fieldNumber: 2)
    }
    if self.totalPoints != 0 {
      try visitor.visitSingularUInt32Field(value: self.totalPoints, fieldNumber: 3)
    }
    if self.spentPoints != 0 {
      try visitor.visitSingularUInt32Field(value: self.spentPoints, fieldNumber: 4)
    }
    if self.expiredPoints != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiredPoints, fieldNumber: 5)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_CompanyBalance, rhs: Metro_Loyalty_Data_V1_CompanyBalance) -> Bool {
    if lhs.companyName != rhs.companyName {return false}
    if lhs.actualPoints != rhs.actualPoints {return false}
    if lhs.totalPoints != rhs.totalPoints {return false}
    if lhs.spentPoints != rhs.spentPoints {return false}
    if lhs.expiredPoints != rhs.expiredPoints {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_RewardPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RewardPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "picture_url"),
    4: .standard(proto: "point_price"),
    5: .standard(proto: "action_text"),
    6: .standard(proto: "valid_from"),
    7: .standard(proto: "valid_to"),
    8: .standard(proto: "limited_count"),
    9: .standard(proto: "redeem_type"),
    10: .standard(proto: "academy_code_redeemed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pictureURL) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.pointPrice) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._actionText) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._validFrom) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._validTo) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._limitedCount) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.redeemType) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.academyCodeRedeemed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._pictureURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.pointPrice != 0 {
      try visitor.visitSingularUInt32Field(value: self.pointPrice, fieldNumber: 4)
    }
    try { if let v = self._actionText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._validFrom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._validTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._limitedCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.redeemType != .unknownRedeem {
      try visitor.visitSingularEnumField(value: self.redeemType, fieldNumber: 9)
    }
    if self.academyCodeRedeemed != false {
      try visitor.visitSingularBoolField(value: self.academyCodeRedeemed, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_RewardPreview, rhs: Metro_Loyalty_Data_V1_RewardPreview) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.name != rhs.name {return false}
    if lhs._pictureURL != rhs._pictureURL {return false}
    if lhs.pointPrice != rhs.pointPrice {return false}
    if lhs._actionText != rhs._actionText {return false}
    if lhs._validFrom != rhs._validFrom {return false}
    if lhs._validTo != rhs._validTo {return false}
    if lhs._limitedCount != rhs._limitedCount {return false}
    if lhs.redeemType != rhs.redeemType {return false}
    if lhs.academyCodeRedeemed != rhs.academyCodeRedeemed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_LimitedCount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LimitedCount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .standard(proto: "already_used"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.total) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.alreadyUsed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.total != 0 {
      try visitor.visitSingularUInt32Field(value: self.total, fieldNumber: 1)
    }
    if self.alreadyUsed != 0 {
      try visitor.visitSingularUInt32Field(value: self.alreadyUsed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_LimitedCount, rhs: Metro_Loyalty_Data_V1_LimitedCount) -> Bool {
    if lhs.total != rhs.total {return false}
    if lhs.alreadyUsed != rhs.alreadyUsed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PointExpirationArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointExpirationArray"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "point_expirations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pointExpirations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pointExpirations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pointExpirations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PointExpirationArray, rhs: Metro_Loyalty_Data_V1_PointExpirationArray) -> Bool {
    if lhs.pointExpirations != rhs.pointExpirations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PointExpiration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointExpiration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .standard(proto: "expires_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.points != 0 {
      try visitor.visitSingularUInt32Field(value: self.points, fieldNumber: 1)
    }
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PointExpiration, rhs: Metro_Loyalty_Data_V1_PointExpiration) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PointMovement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PointMovement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "purchase_or_return"),
    2: .standard(proto: "point_redeem"),
    3: .standard(proto: "admin_correction"),
    4: .same(proto: "expiration"),
    5: .same(proto: "info"),
    6: .standard(proto: "academy_code_redeem"),
    7: .standard(proto: "academy_code_usage"),
    8: .standard(proto: "academy_code_expiration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Metro_Loyalty_Data_V1_PointMovement.PurchaseOrReturn?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .purchaseOrReturn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .purchaseOrReturn(v)
        }
      }()
      case 2: try {
        var v: Metro_Loyalty_Data_V1_PointMovement.PointRedeem?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .pointRedeem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .pointRedeem(v)
        }
      }()
      case 3: try {
        var v: Metro_Loyalty_Data_V1_PointMovement.AdminCorrection?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .adminCorrection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .adminCorrection(v)
        }
      }()
      case 4: try {
        var v: Metro_Loyalty_Data_V1_PointMovement.Expiration?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .expiration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .expiration(v)
        }
      }()
      case 5: try {
        var v: Metro_Loyalty_Data_V1_PointMovement.Info?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .info(v)
        }
      }()
      case 6: try {
        var v: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeRedeem?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .academyCodeRedeem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .academyCodeRedeem(v)
        }
      }()
      case 7: try {
        var v: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeUsage?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .academyCodeUsage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .academyCodeUsage(v)
        }
      }()
      case 8: try {
        var v: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeExpiration?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .academyCodeExpiration(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .academyCodeExpiration(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .purchaseOrReturn?: try {
      guard case .purchaseOrReturn(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pointRedeem?: try {
      guard case .pointRedeem(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .adminCorrection?: try {
      guard case .adminCorrection(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .expiration?: try {
      guard case .expiration(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .info?: try {
      guard case .info(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .academyCodeRedeem?: try {
      guard case .academyCodeRedeem(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .academyCodeUsage?: try {
      guard case .academyCodeUsage(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .academyCodeExpiration?: try {
      guard case .academyCodeExpiration(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PointMovement, rhs: Metro_Loyalty_Data_V1_PointMovement) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PointMovement.PurchaseOrReturn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_PointMovement.protoMessageName + ".PurchaseOrReturn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "points"),
    3: .standard(proto: "invoice_id"),
    4: .standard(proto: "points_added_at"),
    5: .standard(proto: "expires_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.invoiceID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._pointsAddedAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.amount != 0 {
      try visitor.visitSingularDoubleField(value: self.amount, fieldNumber: 1)
    }
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 2)
    }
    if !self.invoiceID.isEmpty {
      try visitor.visitSingularStringField(value: self.invoiceID, fieldNumber: 3)
    }
    try { if let v = self._pointsAddedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PointMovement.PurchaseOrReturn, rhs: Metro_Loyalty_Data_V1_PointMovement.PurchaseOrReturn) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.points != rhs.points {return false}
    if lhs.invoiceID != rhs.invoiceID {return false}
    if lhs._pointsAddedAt != rhs._pointsAddedAt {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PointMovement.PointRedeem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_PointMovement.protoMessageName + ".PointRedeem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "points"),
    3: .standard(proto: "redeemed_by"),
    4: .standard(proto: "redeemed_at"),
    5: .same(proto: "ean"),
    6: .standard(proto: "cust_no"),
    7: .standard(proto: "store_no"),
    8: .standard(proto: "academy_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.redeemedBy) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._redeemedAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.ean) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.custNo) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.storeNo) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._academyCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 2)
    }
    if !self.redeemedBy.isEmpty {
      try visitor.visitSingularStringField(value: self.redeemedBy, fieldNumber: 3)
    }
    try { if let v = self._redeemedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.ean.isEmpty {
      try visitor.visitSingularStringField(value: self.ean, fieldNumber: 5)
    }
    if !self.custNo.isEmpty {
      try visitor.visitSingularStringField(value: self.custNo, fieldNumber: 6)
    }
    if !self.storeNo.isEmpty {
      try visitor.visitSingularStringField(value: self.storeNo, fieldNumber: 7)
    }
    try { if let v = self._academyCode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PointMovement.PointRedeem, rhs: Metro_Loyalty_Data_V1_PointMovement.PointRedeem) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.points != rhs.points {return false}
    if lhs.redeemedBy != rhs.redeemedBy {return false}
    if lhs._redeemedAt != rhs._redeemedAt {return false}
    if lhs.ean != rhs.ean {return false}
    if lhs.custNo != rhs.custNo {return false}
    if lhs.storeNo != rhs.storeNo {return false}
    if lhs._academyCode != rhs._academyCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PointMovement.AdminCorrection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_PointMovement.protoMessageName + ".AdminCorrection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pointCorrection"),
    2: .same(proto: "message"),
    3: .standard(proto: "points_added_at"),
    4: .standard(proto: "expires_at"),
    5: .standard(proto: "id_admin"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pointCorrection) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pointsAddedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expiresAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._idAdmin) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pointCorrection != 0 {
      try visitor.visitSingularInt32Field(value: self.pointCorrection, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._pointsAddedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._expiresAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._idAdmin {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PointMovement.AdminCorrection, rhs: Metro_Loyalty_Data_V1_PointMovement.AdminCorrection) -> Bool {
    if lhs.pointCorrection != rhs.pointCorrection {return false}
    if lhs.message != rhs.message {return false}
    if lhs._pointsAddedAt != rhs._pointsAddedAt {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs._idAdmin != rhs._idAdmin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PointMovement.Expiration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_PointMovement.protoMessageName + ".Expiration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "expired_points"),
    2: .standard(proto: "expired_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.expiredPoints) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expiredAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.expiredPoints != 0 {
      try visitor.visitSingularUInt32Field(value: self.expiredPoints, fieldNumber: 1)
    }
    try { if let v = self._expiredAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PointMovement.Expiration, rhs: Metro_Loyalty_Data_V1_PointMovement.Expiration) -> Bool {
    if lhs.expiredPoints != rhs.expiredPoints {return false}
    if lhs._expiredAt != rhs._expiredAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PointMovement.Info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_PointMovement.protoMessageName + ".Info"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknownInfoType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PointMovement.Info, rhs: Metro_Loyalty_Data_V1_PointMovement.Info) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PointMovement.Info.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_INFO_TYPE"),
    1: .same(proto: "ENTER_CLAP_INFO_TYPE"),
    2: .same(proto: "EXIT_CLAP_INFO_TYPE"),
    3: .same(proto: "BLOCKED_INFO_TYPE"),
    4: .same(proto: "RENEWED_INFO_TYPE"),
    5: .same(proto: "BLACKLISTED_INFO_TYPE"),
  ]
}

extension Metro_Loyalty_Data_V1_PointMovement.AcademyCodeRedeem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_PointMovement.protoMessageName + ".AcademyCodeRedeem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .standard(proto: "redeemed_by"),
    3: .standard(proto: "coupon_type"),
    4: .standard(proto: "redeemed_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.redeemedBy) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.couponType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._redeemedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.points != 0 {
      try visitor.visitSingularInt32Field(value: self.points, fieldNumber: 1)
    }
    if !self.redeemedBy.isEmpty {
      try visitor.visitSingularStringField(value: self.redeemedBy, fieldNumber: 2)
    }
    if !self.couponType.isEmpty {
      try visitor.visitSingularStringField(value: self.couponType, fieldNumber: 3)
    }
    try { if let v = self._redeemedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeRedeem, rhs: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeRedeem) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.redeemedBy != rhs.redeemedBy {return false}
    if lhs.couponType != rhs.couponType {return false}
    if lhs._redeemedAt != rhs._redeemedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PointMovement.AcademyCodeUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_PointMovement.protoMessageName + ".AcademyCodeUsage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coupon_type"),
    2: .standard(proto: "redeemed_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.couponType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._redeemedAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.couponType.isEmpty {
      try visitor.visitSingularStringField(value: self.couponType, fieldNumber: 1)
    }
    try { if let v = self._redeemedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeUsage, rhs: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeUsage) -> Bool {
    if lhs.couponType != rhs.couponType {return false}
    if lhs._redeemedAt != rhs._redeemedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PointMovement.AcademyCodeExpiration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_PointMovement.protoMessageName + ".AcademyCodeExpiration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coupon_type"),
    2: .standard(proto: "expired_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.couponType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expiredAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.couponType.isEmpty {
      try visitor.visitSingularStringField(value: self.couponType, fieldNumber: 1)
    }
    try { if let v = self._expiredAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeExpiration, rhs: Metro_Loyalty_Data_V1_PointMovement.AcademyCodeExpiration) -> Bool {
    if lhs.couponType != rhs.couponType {return false}
    if lhs._expiredAt != rhs._expiredAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_Reward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reward"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "picture_url"),
    4: .standard(proto: "point_price"),
    5: .standard(proto: "action_text"),
    6: .standard(proto: "valid_from"),
    7: .standard(proto: "valid_to"),
    8: .standard(proto: "application_identifier"),
    9: .standard(proto: "redeem_type"),
    10: .standard(proto: "limited_count"),
    11: .standard(proto: "standard_price"),
    12: .standard(proto: "loyalty_price"),
    13: .same(proto: "description"),
    14: .standard(proto: "redeem_place"),
    15: .same(proto: "redeem"),
    16: .same(proto: "level"),
    17: .standard(proto: "academy_courses"),
  ]

  fileprivate class _StorageClass {
    var _id: Appelis_UUID? = nil
    var _name: String = String()
    var _pictureURL: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _pointPrice: UInt32 = 0
    var _actionText: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _validFrom: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _validTo: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _applicationIdentifier: Metro_Loyalty_Data_V1_ApplicationIdentifier = .unknownAppID
    var _redeemType: Metro_Loyalty_Data_V1_RedeemType = .unknownRedeem
    var _limitedCount: Metro_Loyalty_Data_V1_LimitedCount? = nil
    var _standardPrice: Metro_Loyalty_Data_V1_Price? = nil
    var _loyaltyPrice: Metro_Loyalty_Data_V1_Price? = nil
    var _description_p: Data = Data()
    var _redeemPlace: Metro_Loyalty_Data_V1_RedeemPlace? = nil
    var _redeem: Metro_Loyalty_Data_V1_Redeem? = nil
    var _level: UInt32 = 0
    var _academyCourses: [Metro_Loyalty_Data_V1_AcademyCourse] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _pictureURL = source._pictureURL
      _pointPrice = source._pointPrice
      _actionText = source._actionText
      _validFrom = source._validFrom
      _validTo = source._validTo
      _applicationIdentifier = source._applicationIdentifier
      _redeemType = source._redeemType
      _limitedCount = source._limitedCount
      _standardPrice = source._standardPrice
      _loyaltyPrice = source._loyaltyPrice
      _description_p = source._description_p
      _redeemPlace = source._redeemPlace
      _redeem = source._redeem
      _level = source._level
      _academyCourses = source._academyCourses
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._pictureURL) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._pointPrice) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._actionText) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._validFrom) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._validTo) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._applicationIdentifier) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._redeemType) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._limitedCount) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._standardPrice) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._loyaltyPrice) }()
        case 13: try { try decoder.decodeSingularBytesField(value: &_storage._description_p) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._redeemPlace) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._redeem) }()
        case 16: try { try decoder.decodeSingularUInt32Field(value: &_storage._level) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._academyCourses) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._pictureURL {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._pointPrice != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._pointPrice, fieldNumber: 4)
      }
      try { if let v = _storage._actionText {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._validFrom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._validTo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._applicationIdentifier != .unknownAppID {
        try visitor.visitSingularEnumField(value: _storage._applicationIdentifier, fieldNumber: 8)
      }
      if _storage._redeemType != .unknownRedeem {
        try visitor.visitSingularEnumField(value: _storage._redeemType, fieldNumber: 9)
      }
      try { if let v = _storage._limitedCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._standardPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._loyaltyPrice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._description_p, fieldNumber: 13)
      }
      try { if let v = _storage._redeemPlace {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._redeem {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._level != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._level, fieldNumber: 16)
      }
      if !_storage._academyCourses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._academyCourses, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_Reward, rhs: Metro_Loyalty_Data_V1_Reward) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._pictureURL != rhs_storage._pictureURL {return false}
        if _storage._pointPrice != rhs_storage._pointPrice {return false}
        if _storage._actionText != rhs_storage._actionText {return false}
        if _storage._validFrom != rhs_storage._validFrom {return false}
        if _storage._validTo != rhs_storage._validTo {return false}
        if _storage._applicationIdentifier != rhs_storage._applicationIdentifier {return false}
        if _storage._redeemType != rhs_storage._redeemType {return false}
        if _storage._limitedCount != rhs_storage._limitedCount {return false}
        if _storage._standardPrice != rhs_storage._standardPrice {return false}
        if _storage._loyaltyPrice != rhs_storage._loyaltyPrice {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._redeemPlace != rhs_storage._redeemPlace {return false}
        if _storage._redeem != rhs_storage._redeem {return false}
        if _storage._level != rhs_storage._level {return false}
        if _storage._academyCourses != rhs_storage._academyCourses {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_AcademyCourse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcademyCourse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "detail_url"),
    4: .standard(proto: "picture_url"),
    5: .standard(proto: "apply_url"),
    6: .standard(proto: "start_date"),
    7: .standard(proto: "end_date"),
    8: .same(proto: "available"),
    9: .same(proto: "price"),
    10: .same(proto: "ribbon"),
    11: .same(proto: "category"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.detailURL) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pictureURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.applyURL) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._startDate) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._endDate) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.available) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.price) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._ribbon) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._category) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.detailURL.isEmpty {
      try visitor.visitSingularStringField(value: self.detailURL, fieldNumber: 3)
    }
    if !self.pictureURL.isEmpty {
      try visitor.visitSingularStringField(value: self.pictureURL, fieldNumber: 4)
    }
    if !self.applyURL.isEmpty {
      try visitor.visitSingularStringField(value: self.applyURL, fieldNumber: 5)
    }
    try { if let v = self._startDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._endDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.available != false {
      try visitor.visitSingularBoolField(value: self.available, fieldNumber: 8)
    }
    if self.price != 0 {
      try visitor.visitSingularUInt32Field(value: self.price, fieldNumber: 9)
    }
    try { if let v = self._ribbon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._category {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_AcademyCourse, rhs: Metro_Loyalty_Data_V1_AcademyCourse) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.detailURL != rhs.detailURL {return false}
    if lhs.pictureURL != rhs.pictureURL {return false}
    if lhs.applyURL != rhs.applyURL {return false}
    if lhs._startDate != rhs._startDate {return false}
    if lhs._endDate != rhs._endDate {return false}
    if lhs.available != rhs.available {return false}
    if lhs.price != rhs.price {return false}
    if lhs._ribbon != rhs._ribbon {return false}
    if lhs._category != rhs._category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_AcademyCourse.Ribbon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_AcademyCourse.protoMessageName + ".Ribbon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "color"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.color) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.color.isEmpty {
      try visitor.visitSingularStringField(value: self.color, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_AcademyCourse.Ribbon, rhs: Metro_Loyalty_Data_V1_AcademyCourse.Ribbon) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.color != rhs.color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_AcademyCourse.Category: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_AcademyCourse.protoMessageName + ".Category"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "translation_key"),
    2: .standard(proto: "icon_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.translationKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.iconURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.translationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.translationKey, fieldNumber: 1)
    }
    if !self.iconURL.isEmpty {
      try visitor.visitSingularStringField(value: self.iconURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_AcademyCourse.Category, rhs: Metro_Loyalty_Data_V1_AcademyCourse.Category) -> Bool {
    if lhs.translationKey != rhs.translationKey {return false}
    if lhs.iconURL != rhs.iconURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_RedeemPlace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RedeemPlace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "picture_url"),
    2: .same(proto: "translation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pictureURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.translation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pictureURL.isEmpty {
      try visitor.visitSingularStringField(value: self.pictureURL, fieldNumber: 1)
    }
    if !self.translation.isEmpty {
      try visitor.visitSingularStringField(value: self.translation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_RedeemPlace, rhs: Metro_Loyalty_Data_V1_RedeemPlace) -> Bool {
    if lhs.pictureURL != rhs.pictureURL {return false}
    if lhs.translation != rhs.translation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_Price: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Price"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "value_tax"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.valueTax) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if self.valueTax != 0 {
      try visitor.visitSingularDoubleField(value: self.valueTax, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_Price, rhs: Metro_Loyalty_Data_V1_Price) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.valueTax != rhs.valueTax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_Redeem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Redeem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .standard(proto: "valid_until"),
    3: .same(proto: "ean"),
    4: .standard(proto: "validity_in_seconds"),
    5: .standard(proto: "academy_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validUntil) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._ean) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.validityInSeconds) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._academyCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._validUntil {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ean {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.validityInSeconds != 0 {
      try visitor.visitSingularUInt32Field(value: self.validityInSeconds, fieldNumber: 4)
    }
    try { if let v = self._academyCode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_Redeem, rhs: Metro_Loyalty_Data_V1_Redeem) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._validUntil != rhs._validUntil {return false}
    if lhs._ean != rhs._ean {return false}
    if lhs.validityInSeconds != rhs.validityInSeconds {return false}
    if lhs._academyCode != rhs._academyCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_BlockListUser: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockListUser"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "surname"),
    4: .same(proto: "blocked"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.surname) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.blocked) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.surname.isEmpty {
      try visitor.visitSingularStringField(value: self.surname, fieldNumber: 3)
    }
    if self.blocked != false {
      try visitor.visitSingularBoolField(value: self.blocked, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_BlockListUser, rhs: Metro_Loyalty_Data_V1_BlockListUser) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.surname != rhs.surname {return false}
    if lhs.blocked != rhs.blocked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_CompanyBlockList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyBlockList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "users"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_CompanyBlockList, rhs: Metro_Loyalty_Data_V1_CompanyBlockList) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_AccountPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "updated_at"),
    3: .standard(proto: "id_company"),
    4: .standard(proto: "company_name"),
    5: .standard(proto: "registration_no"),
    6: .same(proto: "status"),
    7: .standard(proto: "is_policy_approved"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.idCompany) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.companyName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.registrationNo) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isPolicyApproved) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.idCompany != 0 {
      try visitor.visitSingularInt64Field(value: self.idCompany, fieldNumber: 3)
    }
    if !self.companyName.isEmpty {
      try visitor.visitSingularStringField(value: self.companyName, fieldNumber: 4)
    }
    if !self.registrationNo.isEmpty {
      try visitor.visitSingularStringField(value: self.registrationNo, fieldNumber: 5)
    }
    if self.status != .unknownLoyaltyStatus {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 6)
    }
    if self.isPolicyApproved != false {
      try visitor.visitSingularBoolField(value: self.isPolicyApproved, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_AccountPreview, rhs: Metro_Loyalty_Data_V1_AccountPreview) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.idCompany != rhs.idCompany {return false}
    if lhs.companyName != rhs.companyName {return false}
    if lhs.registrationNo != rhs.registrationNo {return false}
    if lhs.status != rhs.status {return false}
    if lhs.isPolicyApproved != rhs.isPolicyApproved {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_AccountDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "updated_at"),
    3: .standard(proto: "id_company"),
    4: .standard(proto: "company_name"),
    5: .standard(proto: "registration_no"),
    6: .same(proto: "status"),
    7: .standard(proto: "is_policy_approved"),
    8: .standard(proto: "policy_approved_at"),
    9: .standard(proto: "policy_approved_by"),
    10: .standard(proto: "status_history"),
    11: .standard(proto: "company_balance"),
    12: .same(proto: "level"),
  ]

  fileprivate class _StorageClass {
    var _id: Appelis_UUID? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _idCompany: Int64 = 0
    var _companyName: String = String()
    var _registrationNo: String = String()
    var _status: Metro_Loyalty_Data_V1_UserLoyaltyStatus = .unknownLoyaltyStatus
    var _isPolicyApproved: Bool = false
    var _policyApprovedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _policyApprovedBy: String = String()
    var _statusHistory: [Metro_Loyalty_Data_V1_AccountDetail.StatusHistoryItem] = []
    var _companyBalance: Metro_Loyalty_Data_V1_CompanyBalance? = nil
    var _level: UInt32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _updatedAt = source._updatedAt
      _idCompany = source._idCompany
      _companyName = source._companyName
      _registrationNo = source._registrationNo
      _status = source._status
      _isPolicyApproved = source._isPolicyApproved
      _policyApprovedAt = source._policyApprovedAt
      _policyApprovedBy = source._policyApprovedBy
      _statusHistory = source._statusHistory
      _companyBalance = source._companyBalance
      _level = source._level
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._idCompany) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._companyName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._registrationNo) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._isPolicyApproved) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._policyApprovedAt) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._policyApprovedBy) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._statusHistory) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._companyBalance) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._level) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._idCompany != 0 {
        try visitor.visitSingularInt64Field(value: _storage._idCompany, fieldNumber: 3)
      }
      if !_storage._companyName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._companyName, fieldNumber: 4)
      }
      if !_storage._registrationNo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._registrationNo, fieldNumber: 5)
      }
      if _storage._status != .unknownLoyaltyStatus {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 6)
      }
      if _storage._isPolicyApproved != false {
        try visitor.visitSingularBoolField(value: _storage._isPolicyApproved, fieldNumber: 7)
      }
      try { if let v = _storage._policyApprovedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._policyApprovedBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._policyApprovedBy, fieldNumber: 9)
      }
      if !_storage._statusHistory.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._statusHistory, fieldNumber: 10)
      }
      try { if let v = _storage._companyBalance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._level != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._level, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_AccountDetail, rhs: Metro_Loyalty_Data_V1_AccountDetail) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._idCompany != rhs_storage._idCompany {return false}
        if _storage._companyName != rhs_storage._companyName {return false}
        if _storage._registrationNo != rhs_storage._registrationNo {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._isPolicyApproved != rhs_storage._isPolicyApproved {return false}
        if _storage._policyApprovedAt != rhs_storage._policyApprovedAt {return false}
        if _storage._policyApprovedBy != rhs_storage._policyApprovedBy {return false}
        if _storage._statusHistory != rhs_storage._statusHistory {return false}
        if _storage._companyBalance != rhs_storage._companyBalance {return false}
        if _storage._level != rhs_storage._level {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_AccountDetail.StatusHistoryItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_AccountDetail.protoMessageName + ".StatusHistoryItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .unknownLoyaltyStatus {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_AccountDetail.StatusHistoryItem, rhs: Metro_Loyalty_Data_V1_AccountDetail.StatusHistoryItem) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._date != rhs._date {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_Campaign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Campaign"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "picture_url"),
    3: .same(proto: "rule"),
    4: .standard(proto: "notifications_config"),
    5: .same(proto: "validity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pictureURL) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Metro_Loyalty_Data_V1_Campaign.NotificationData>.self, value: &self.notificationsConfig) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._validity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.pictureURL.isEmpty {
      try visitor.visitSingularStringField(value: self.pictureURL, fieldNumber: 2)
    }
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.notificationsConfig.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Metro_Loyalty_Data_V1_Campaign.NotificationData>.self, value: self.notificationsConfig, fieldNumber: 4)
    }
    try { if let v = self._validity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_Campaign, rhs: Metro_Loyalty_Data_V1_Campaign) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.pictureURL != rhs.pictureURL {return false}
    if lhs._rule != rhs._rule {return false}
    if lhs.notificationsConfig != rhs.notificationsConfig {return false}
    if lhs._validity != rhs._validity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_Campaign.NotificationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_Campaign.protoMessageName + ".NotificationData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_Campaign.NotificationData, rhs: Metro_Loyalty_Data_V1_Campaign.NotificationData) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_Campaign.Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_Data_V1_Campaign.protoMessageName + ".Rule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invoice_amount"),
    3: .same(proto: "points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.invoiceAmount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.points) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.invoiceAmount != 0 {
      try visitor.visitSingularUInt32Field(value: self.invoiceAmount, fieldNumber: 1)
    }
    if self.points != 0 {
      try visitor.visitSingularUInt32Field(value: self.points, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_Campaign.Rule, rhs: Metro_Loyalty_Data_V1_Campaign.Rule) -> Bool {
    if lhs.invoiceAmount != rhs.invoiceAmount {return false}
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Policy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lang"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.lang) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lang != .unknown {
      try visitor.visitSingularEnumField(value: self.lang, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularBytesField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_Policy, rhs: Metro_Loyalty_Data_V1_Policy) -> Bool {
    if lhs.lang != rhs.lang {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PolicyVariations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PolicyVariations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.policy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.policy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.policy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PolicyVariations, rhs: Metro_Loyalty_Data_V1_PolicyVariations) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_Data_V1_PolicyShort: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PolicyShort"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "valid_from"),
    3: .standard(proto: "valid_to"),
    4: .same(proto: "variations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validFrom) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._validTo) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._variations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._validFrom {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._validTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._variations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_Data_V1_PolicyShort, rhs: Metro_Loyalty_Data_V1_PolicyShort) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._validFrom != rhs._validFrom {return false}
    if lhs._validTo != rhs._validTo {return false}
    if lhs._variations != rhs._variations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
