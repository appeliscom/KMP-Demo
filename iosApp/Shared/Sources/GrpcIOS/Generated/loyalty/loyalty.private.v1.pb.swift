// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: loyalty/loyalty.private.v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Metro_Loyalty_V1_GetRewardsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idProject: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Loyalty_V1_GetRewardsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Loyalty_V1_GetRewardsResponse.OneOf_Payload? = nil

  public var error: Metro_Loyalty_V1_GetRewardsResponse.GetRewardsError {
    get {
      if case .error(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .error(newValue)}
  }

  public var rewards: Metro_Loyalty_V1_GetRewardsResponse.Rewards {
    get {
      if case .rewards(let v)? = payload {return v}
      return Metro_Loyalty_V1_GetRewardsResponse.Rewards()
    }
    set {payload = .rewards(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case error(Metro_Loyalty_V1_GetRewardsResponse.GetRewardsError)
    case rewards(Metro_Loyalty_V1_GetRewardsResponse.Rewards)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Loyalty_V1_GetRewardsResponse.OneOf_Payload, rhs: Metro_Loyalty_V1_GetRewardsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rewards, .rewards): return {
        guard case .rewards(let l) = lhs, case .rewards(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum GetRewardsError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case projectNotFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .projectNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .projectNotFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Rewards {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var rewards: [Metro_Loyalty_Data_V1_Reward] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Metro_Loyalty_V1_GetRewardsResponse.GetRewardsError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_V1_GetRewardsResponse.GetRewardsError] = [
    .unknown,
    .projectNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Loyalty_V1_GetRewardDetailRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idProject: String = String()

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
}

public struct Metro_Loyalty_V1_GetRewardDetailResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Loyalty_V1_GetRewardDetailResponse.OneOf_Payload? = nil

  public var error: Metro_Loyalty_V1_GetRewardDetailResponse.GetRewardError {
    get {
      if case .error(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .error(newValue)}
  }

  public var reward: Metro_Loyalty_Data_V1_Reward {
    get {
      if case .reward(let v)? = payload {return v}
      return Metro_Loyalty_Data_V1_Reward()
    }
    set {payload = .reward(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case error(Metro_Loyalty_V1_GetRewardDetailResponse.GetRewardError)
    case reward(Metro_Loyalty_Data_V1_Reward)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Loyalty_V1_GetRewardDetailResponse.OneOf_Payload, rhs: Metro_Loyalty_V1_GetRewardDetailResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reward, .reward): return {
        guard case .reward(let l) = lhs, case .reward(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum GetRewardError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case rewardNotFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .rewardNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .rewardNotFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Metro_Loyalty_V1_GetRewardDetailResponse.GetRewardError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_V1_GetRewardDetailResponse.GetRewardError] = [
    .unknown,
    .rewardNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Loyalty_V1_SetRewardDetailRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idProject: String = String()

  public var level: UInt32 = 0

  public var reward: Metro_Loyalty_Data_V1_Reward {
    get {return _reward ?? Metro_Loyalty_Data_V1_Reward()}
    set {_reward = newValue}
  }
  /// Returns true if `reward` has been explicitly set.
  public var hasReward: Bool {return self._reward != nil}
  /// Clears the value of `reward`. Subsequent reads from it will return its default value.
  public mutating func clearReward() {self._reward = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _reward: Metro_Loyalty_Data_V1_Reward? = nil
}

public struct Metro_Loyalty_V1_SetRewardDetailResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: Metro_Loyalty_V1_SetRewardDetailResponse.SetRewardError {
    get {return _error ?? .unknown}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SetRewardError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case projectNotFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .projectNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .projectNotFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _error: Metro_Loyalty_V1_SetRewardDetailResponse.SetRewardError? = nil
}

#if swift(>=4.2)

extension Metro_Loyalty_V1_SetRewardDetailResponse.SetRewardError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_V1_SetRewardDetailResponse.SetRewardError] = [
    .unknown,
    .projectNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Loyalty_V1_DeleteRewardRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idProject: String = String()

  public var id: Appelis_UUID {
    get {return _id ?? Appelis_UUID()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Appelis_UUID? = nil
}

public struct Metro_Loyalty_V1_GetPointMovementsPagedPrivateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idProject: String = String()

  public var idAccount: Appelis_UUID {
    get {return _idAccount ?? Appelis_UUID()}
    set {_idAccount = newValue}
  }
  /// Returns true if `idAccount` has been explicitly set.
  public var hasIDAccount: Bool {return self._idAccount != nil}
  /// Clears the value of `idAccount`. Subsequent reads from it will return its default value.
  public mutating func clearIDAccount() {self._idAccount = nil}

  public var paging: Appelis_CursorForwardPagingParams {
    get {return _paging ?? Appelis_CursorForwardPagingParams()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  public var clientVersion: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _clientVersion ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_clientVersion = newValue}
  }
  /// Returns true if `clientVersion` has been explicitly set.
  public var hasClientVersion: Bool {return self._clientVersion != nil}
  /// Clears the value of `clientVersion`. Subsequent reads from it will return its default value.
  public mutating func clearClientVersion() {self._clientVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _idAccount: Appelis_UUID? = nil
  fileprivate var _paging: Appelis_CursorForwardPagingParams? = nil
  fileprivate var _clientVersion: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

public struct Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Page {
    get {return _data ?? Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Page()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Node {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var cursor: String = String()

    public var data: Metro_Loyalty_Data_V1_PointMovement {
      get {return _data ?? Metro_Loyalty_Data_V1_PointMovement()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    public var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    public mutating func clearData() {self._data = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _data: Metro_Loyalty_Data_V1_PointMovement? = nil
  }

  public struct Page {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var hasNext_p: Bool = false

    public var nodes: [Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Node] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Page? = nil
}

public struct Metro_Loyalty_V1_SetAccountStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idProject: String = String()

  public var idAccount: Appelis_UUID {
    get {return _idAccount ?? Appelis_UUID()}
    set {_idAccount = newValue}
  }
  /// Returns true if `idAccount` has been explicitly set.
  public var hasIDAccount: Bool {return self._idAccount != nil}
  /// Clears the value of `idAccount`. Subsequent reads from it will return its default value.
  public mutating func clearIDAccount() {self._idAccount = nil}

  public var status: Metro_Loyalty_Data_V1_UserLoyaltyStatus = .unknownLoyaltyStatus

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _idAccount: Appelis_UUID? = nil
}

public struct Metro_Loyalty_V1_SetAccountStatusResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: Metro_Loyalty_V1_SetAccountStatusResponse.SetAccountStatusError {
    get {return _error ?? .unknown}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum SetAccountStatusError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case campaignNotFound // = 1
    case accountNotFound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .campaignNotFound
      case 2: self = .accountNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .campaignNotFound: return 1
      case .accountNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _error: Metro_Loyalty_V1_SetAccountStatusResponse.SetAccountStatusError? = nil
}

#if swift(>=4.2)

extension Metro_Loyalty_V1_SetAccountStatusResponse.SetAccountStatusError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_V1_SetAccountStatusResponse.SetAccountStatusError] = [
    .unknown,
    .campaignNotFound,
    .accountNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Loyalty_V1_AddAdminCorrectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idAccount: Appelis_UUID {
    get {return _idAccount ?? Appelis_UUID()}
    set {_idAccount = newValue}
  }
  /// Returns true if `idAccount` has been explicitly set.
  public var hasIDAccount: Bool {return self._idAccount != nil}
  /// Clears the value of `idAccount`. Subsequent reads from it will return its default value.
  public mutating func clearIDAccount() {self._idAccount = nil}

  public var idProject: String = String()

  public var data: Metro_Loyalty_V1_AddAdminCorrectionRequest.CorrectionData {
    get {return _data ?? Metro_Loyalty_V1_AddAdminCorrectionRequest.CorrectionData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct CorrectionData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var points: Int64 = 0

    public var description_p: String = String()

    public var idAdmin: String = String()

    public var expirationAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _expirationAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_expirationAt = newValue}
    }
    /// Returns true if `expirationAt` has been explicitly set.
    public var hasExpirationAt: Bool {return self._expirationAt != nil}
    /// Clears the value of `expirationAt`. Subsequent reads from it will return its default value.
    public mutating func clearExpirationAt() {self._expirationAt = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _expirationAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}

  fileprivate var _idAccount: Appelis_UUID? = nil
  fileprivate var _data: Metro_Loyalty_V1_AddAdminCorrectionRequest.CorrectionData? = nil
}

public struct Metro_Loyalty_V1_AddAdminCorrectionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: Metro_Loyalty_V1_AddAdminCorrectionResponse.AddAdminCorrectionError {
    get {return _error ?? .unknown}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AddAdminCorrectionError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case campaignNotFound // = 1
    case accountNotFound // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .campaignNotFound
      case 2: self = .accountNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .campaignNotFound: return 1
      case .accountNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _error: Metro_Loyalty_V1_AddAdminCorrectionResponse.AddAdminCorrectionError? = nil
}

#if swift(>=4.2)

extension Metro_Loyalty_V1_AddAdminCorrectionResponse.AddAdminCorrectionError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_V1_AddAdminCorrectionResponse.AddAdminCorrectionError] = [
    .unknown,
    .campaignNotFound,
    .accountNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Loyalty_V1_GetAccountsPagedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idProject: String = String()

  public var idCampaign: Appelis_UUID {
    get {return _idCampaign ?? Appelis_UUID()}
    set {_idCampaign = newValue}
  }
  /// Returns true if `idCampaign` has been explicitly set.
  public var hasIDCampaign: Bool {return self._idCampaign != nil}
  /// Clears the value of `idCampaign`. Subsequent reads from it will return its default value.
  public mutating func clearIDCampaign() {self._idCampaign = nil}

  public var paging: Appelis_CursorForwardPagingParams {
    get {return _paging ?? Appelis_CursorForwardPagingParams()}
    set {_paging = newValue}
  }
  /// Returns true if `paging` has been explicitly set.
  public var hasPaging: Bool {return self._paging != nil}
  /// Clears the value of `paging`. Subsequent reads from it will return its default value.
  public mutating func clearPaging() {self._paging = nil}

  /// If filterKeyword will be provided. Results will
  /// be filtered by registrationNo using prefix search
  /// from "filterKeyword". Field is optional.
  public var filterKeyword: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _filterKeyword ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_filterKeyword = newValue}
  }
  /// Returns true if `filterKeyword` has been explicitly set.
  public var hasFilterKeyword: Bool {return self._filterKeyword != nil}
  /// Clears the value of `filterKeyword`. Subsequent reads from it will return its default value.
  public mutating func clearFilterKeyword() {self._filterKeyword = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _idCampaign: Appelis_UUID? = nil
  fileprivate var _paging: Appelis_CursorForwardPagingParams? = nil
  fileprivate var _filterKeyword: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

public struct Metro_Loyalty_V1_GetAccountsPagedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Loyalty_V1_GetAccountsPagedResponse.OneOf_Payload? = nil

  public var error: Metro_Loyalty_V1_GetAccountsPagedResponse.GetAccountsPagedError {
    get {
      if case .error(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .error(newValue)}
  }

  public var page: Metro_Loyalty_V1_GetAccountsPagedResponse.Page {
    get {
      if case .page(let v)? = payload {return v}
      return Metro_Loyalty_V1_GetAccountsPagedResponse.Page()
    }
    set {payload = .page(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case error(Metro_Loyalty_V1_GetAccountsPagedResponse.GetAccountsPagedError)
    case page(Metro_Loyalty_V1_GetAccountsPagedResponse.Page)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Loyalty_V1_GetAccountsPagedResponse.OneOf_Payload, rhs: Metro_Loyalty_V1_GetAccountsPagedResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.page, .page): return {
        guard case .page(let l) = lhs, case .page(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum GetAccountsPagedError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case campaignNotFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .campaignNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .campaignNotFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Node {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var cursor: Appelis_UUID {
      get {return _cursor ?? Appelis_UUID()}
      set {_cursor = newValue}
    }
    /// Returns true if `cursor` has been explicitly set.
    public var hasCursor: Bool {return self._cursor != nil}
    /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
    public mutating func clearCursor() {self._cursor = nil}

    public var data: Metro_Loyalty_Data_V1_AccountPreview {
      get {return _data ?? Metro_Loyalty_Data_V1_AccountPreview()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    public var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    public mutating func clearData() {self._data = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _cursor: Appelis_UUID? = nil
    fileprivate var _data: Metro_Loyalty_Data_V1_AccountPreview? = nil
  }

  public struct Page {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var hasNext_p: Bool = false

    public var nodes: [Metro_Loyalty_V1_GetAccountsPagedResponse.Node] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Metro_Loyalty_V1_GetAccountsPagedResponse.GetAccountsPagedError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_V1_GetAccountsPagedResponse.GetAccountsPagedError] = [
    .unknown,
    .campaignNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Loyalty_V1_GetAccountDetailRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idProject: String = String()

  public var idAccount: Appelis_UUID {
    get {return _idAccount ?? Appelis_UUID()}
    set {_idAccount = newValue}
  }
  /// Returns true if `idAccount` has been explicitly set.
  public var hasIDAccount: Bool {return self._idAccount != nil}
  /// Clears the value of `idAccount`. Subsequent reads from it will return its default value.
  public mutating func clearIDAccount() {self._idAccount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _idAccount: Appelis_UUID? = nil
}

public struct Metro_Loyalty_V1_GetAccountDetailResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var detail: Metro_Loyalty_Data_V1_AccountDetail {
    get {return _detail ?? Metro_Loyalty_Data_V1_AccountDetail()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  public var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  public mutating func clearDetail() {self._detail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _detail: Metro_Loyalty_Data_V1_AccountDetail? = nil
}

public struct Metro_Loyalty_V1_GetCampaignRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idProject: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Loyalty_V1_GetCampaignResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Metro_Loyalty_V1_GetCampaignResponse.OneOf_Payload? = nil

  public var error: Metro_Loyalty_V1_GetCampaignResponse.GetCampaignError {
    get {
      if case .error(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .error(newValue)}
  }

  public var campaign: Metro_Loyalty_Data_V1_Campaign {
    get {
      if case .campaign(let v)? = payload {return v}
      return Metro_Loyalty_Data_V1_Campaign()
    }
    set {payload = .campaign(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case error(Metro_Loyalty_V1_GetCampaignResponse.GetCampaignError)
    case campaign(Metro_Loyalty_Data_V1_Campaign)

  #if !swift(>=4.1)
    public static func ==(lhs: Metro_Loyalty_V1_GetCampaignResponse.OneOf_Payload, rhs: Metro_Loyalty_V1_GetCampaignResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.campaign, .campaign): return {
        guard case .campaign(let l) = lhs, case .campaign(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum GetCampaignError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case campaignNotFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .campaignNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .campaignNotFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Metro_Loyalty_V1_GetCampaignResponse.GetCampaignError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_V1_GetCampaignResponse.GetCampaignError] = [
    .unknown,
    .campaignNotFound,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Loyalty_V1_UpdateCampaignRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var idProject: String = String()

  public var campaign: Metro_Loyalty_Data_V1_Campaign {
    get {return _campaign ?? Metro_Loyalty_Data_V1_Campaign()}
    set {_campaign = newValue}
  }
  /// Returns true if `campaign` has been explicitly set.
  public var hasCampaign: Bool {return self._campaign != nil}
  /// Clears the value of `campaign`. Subsequent reads from it will return its default value.
  public mutating func clearCampaign() {self._campaign = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _campaign: Metro_Loyalty_Data_V1_Campaign? = nil
}

public struct Metro_Loyalty_V1_UpdateCampaignResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var error: Metro_Loyalty_V1_UpdateCampaignResponse.UpdateCampaignError {
    get {return _error ?? .unknown}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum UpdateCampaignError: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case campaignNotFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .campaignNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .campaignNotFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _error: Metro_Loyalty_V1_UpdateCampaignResponse.UpdateCampaignError? = nil
}

#if swift(>=4.2)

extension Metro_Loyalty_V1_UpdateCampaignResponse.UpdateCampaignError: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Loyalty_V1_UpdateCampaignResponse.UpdateCampaignError] = [
    .unknown,
    .campaignNotFound,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Metro_Loyalty_V1_GetRewardsRequest: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetRewardsResponse: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetRewardsResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetRewardsResponse.GetRewardsError: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetRewardsResponse.Rewards: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetRewardDetailRequest: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetRewardDetailResponse: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetRewardDetailResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetRewardDetailResponse.GetRewardError: @unchecked Sendable {}
extension Metro_Loyalty_V1_SetRewardDetailRequest: @unchecked Sendable {}
extension Metro_Loyalty_V1_SetRewardDetailResponse: @unchecked Sendable {}
extension Metro_Loyalty_V1_SetRewardDetailResponse.SetRewardError: @unchecked Sendable {}
extension Metro_Loyalty_V1_DeleteRewardRequest: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetPointMovementsPagedPrivateRequest: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Node: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Page: @unchecked Sendable {}
extension Metro_Loyalty_V1_SetAccountStatusRequest: @unchecked Sendable {}
extension Metro_Loyalty_V1_SetAccountStatusResponse: @unchecked Sendable {}
extension Metro_Loyalty_V1_SetAccountStatusResponse.SetAccountStatusError: @unchecked Sendable {}
extension Metro_Loyalty_V1_AddAdminCorrectionRequest: @unchecked Sendable {}
extension Metro_Loyalty_V1_AddAdminCorrectionRequest.CorrectionData: @unchecked Sendable {}
extension Metro_Loyalty_V1_AddAdminCorrectionResponse: @unchecked Sendable {}
extension Metro_Loyalty_V1_AddAdminCorrectionResponse.AddAdminCorrectionError: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetAccountsPagedRequest: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetAccountsPagedResponse: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetAccountsPagedResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetAccountsPagedResponse.GetAccountsPagedError: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetAccountsPagedResponse.Node: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetAccountsPagedResponse.Page: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetAccountDetailRequest: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetAccountDetailResponse: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetCampaignRequest: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetCampaignResponse: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetCampaignResponse.OneOf_Payload: @unchecked Sendable {}
extension Metro_Loyalty_V1_GetCampaignResponse.GetCampaignError: @unchecked Sendable {}
extension Metro_Loyalty_V1_UpdateCampaignRequest: @unchecked Sendable {}
extension Metro_Loyalty_V1_UpdateCampaignResponse: @unchecked Sendable {}
extension Metro_Loyalty_V1_UpdateCampaignResponse.UpdateCampaignError: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "metro.loyalty.v1"

extension Metro_Loyalty_V1_GetRewardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRewardsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_project"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetRewardsRequest, rhs: Metro_Loyalty_V1_GetRewardsRequest) -> Bool {
    if lhs.idProject != rhs.idProject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetRewardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRewardsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "rewards"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Metro_Loyalty_V1_GetRewardsResponse.GetRewardsError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      case 2: try {
        var v: Metro_Loyalty_V1_GetRewardsResponse.Rewards?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .rewards(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .rewards(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .rewards?: try {
      guard case .rewards(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetRewardsResponse, rhs: Metro_Loyalty_V1_GetRewardsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetRewardsResponse.GetRewardsError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PROJECT_NOT_FOUND"),
  ]
}

extension Metro_Loyalty_V1_GetRewardsResponse.Rewards: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_V1_GetRewardsResponse.protoMessageName + ".Rewards"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rewards"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rewards) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rewards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rewards, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetRewardsResponse.Rewards, rhs: Metro_Loyalty_V1_GetRewardsResponse.Rewards) -> Bool {
    if lhs.rewards != rhs.rewards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetRewardDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRewardDetailRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_project"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 1)
    }
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetRewardDetailRequest, rhs: Metro_Loyalty_V1_GetRewardDetailRequest) -> Bool {
    if lhs.idProject != rhs.idProject {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetRewardDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRewardDetailResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "reward"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Metro_Loyalty_V1_GetRewardDetailResponse.GetRewardError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      case 2: try {
        var v: Metro_Loyalty_Data_V1_Reward?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .reward(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .reward(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .reward?: try {
      guard case .reward(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetRewardDetailResponse, rhs: Metro_Loyalty_V1_GetRewardDetailResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetRewardDetailResponse.GetRewardError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "REWARD_NOT_FOUND"),
  ]
}

extension Metro_Loyalty_V1_SetRewardDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetRewardDetailRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_project"),
    2: .same(proto: "level"),
    3: .same(proto: "reward"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.level) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._reward) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 1)
    }
    if self.level != 0 {
      try visitor.visitSingularUInt32Field(value: self.level, fieldNumber: 2)
    }
    try { if let v = self._reward {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_SetRewardDetailRequest, rhs: Metro_Loyalty_V1_SetRewardDetailRequest) -> Bool {
    if lhs.idProject != rhs.idProject {return false}
    if lhs.level != rhs.level {return false}
    if lhs._reward != rhs._reward {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_SetRewardDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetRewardDetailResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_SetRewardDetailResponse, rhs: Metro_Loyalty_V1_SetRewardDetailResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_SetRewardDetailResponse.SetRewardError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PROJECT_NOT_FOUND"),
  ]
}

extension Metro_Loyalty_V1_DeleteRewardRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteRewardRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_project"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 1)
    }
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_DeleteRewardRequest, rhs: Metro_Loyalty_V1_DeleteRewardRequest) -> Bool {
    if lhs.idProject != rhs.idProject {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetPointMovementsPagedPrivateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPointMovementsPagedPrivateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_project"),
    2: .standard(proto: "id_account"),
    3: .same(proto: "paging"),
    4: .standard(proto: "client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._idAccount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._clientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 1)
    }
    try { if let v = self._idAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._clientVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetPointMovementsPagedPrivateRequest, rhs: Metro_Loyalty_V1_GetPointMovementsPagedPrivateRequest) -> Bool {
    if lhs.idProject != rhs.idProject {return false}
    if lhs._idAccount != rhs._idAccount {return false}
    if lhs._paging != rhs._paging {return false}
    if lhs._clientVersion != rhs._clientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPointMovementsPagedPrivateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse, rhs: Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.protoMessageName + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cursor) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cursor.isEmpty {
      try visitor.visitSingularStringField(value: self.cursor, fieldNumber: 1)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Node, rhs: Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Node) -> Bool {
    if lhs.cursor != rhs.cursor {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Page: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.protoMessageName + ".Page"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "has_next"),
    2: .same(proto: "nodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasNext_p) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hasNext_p != false {
      try visitor.visitSingularBoolField(value: self.hasNext_p, fieldNumber: 1)
    }
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Page, rhs: Metro_Loyalty_V1_GetPointMovementsPagedPrivateResponse.Page) -> Bool {
    if lhs.hasNext_p != rhs.hasNext_p {return false}
    if lhs.nodes != rhs.nodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_SetAccountStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetAccountStatusRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_project"),
    2: .standard(proto: "id_account"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._idAccount) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 1)
    }
    try { if let v = self._idAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.status != .unknownLoyaltyStatus {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_SetAccountStatusRequest, rhs: Metro_Loyalty_V1_SetAccountStatusRequest) -> Bool {
    if lhs.idProject != rhs.idProject {return false}
    if lhs._idAccount != rhs._idAccount {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_SetAccountStatusResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetAccountStatusResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_SetAccountStatusResponse, rhs: Metro_Loyalty_V1_SetAccountStatusResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_SetAccountStatusResponse.SetAccountStatusError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CAMPAIGN_NOT_FOUND"),
    2: .same(proto: "ACCOUNT_NOT_FOUND"),
  ]
}

extension Metro_Loyalty_V1_AddAdminCorrectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddAdminCorrectionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_account"),
    2: .standard(proto: "id_project"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._idAccount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._idAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 2)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_AddAdminCorrectionRequest, rhs: Metro_Loyalty_V1_AddAdminCorrectionRequest) -> Bool {
    if lhs._idAccount != rhs._idAccount {return false}
    if lhs.idProject != rhs.idProject {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_AddAdminCorrectionRequest.CorrectionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_V1_AddAdminCorrectionRequest.protoMessageName + ".CorrectionData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "description"),
    3: .standard(proto: "id_admin"),
    4: .standard(proto: "expiration_at"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.points) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.idAdmin) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expirationAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.points != 0 {
      try visitor.visitSingularInt64Field(value: self.points, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.idAdmin.isEmpty {
      try visitor.visitSingularStringField(value: self.idAdmin, fieldNumber: 3)
    }
    try { if let v = self._expirationAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_AddAdminCorrectionRequest.CorrectionData, rhs: Metro_Loyalty_V1_AddAdminCorrectionRequest.CorrectionData) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.idAdmin != rhs.idAdmin {return false}
    if lhs._expirationAt != rhs._expirationAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_AddAdminCorrectionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddAdminCorrectionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_AddAdminCorrectionResponse, rhs: Metro_Loyalty_V1_AddAdminCorrectionResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_AddAdminCorrectionResponse.AddAdminCorrectionError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CAMPAIGN_NOT_FOUND"),
    2: .same(proto: "ACCOUNT_NOT_FOUND"),
  ]
}

extension Metro_Loyalty_V1_GetAccountsPagedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountsPagedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_project"),
    2: .standard(proto: "id_campaign"),
    3: .same(proto: "paging"),
    4: .same(proto: "filterKeyword"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._idCampaign) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._paging) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._filterKeyword) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 1)
    }
    try { if let v = self._idCampaign {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._paging {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._filterKeyword {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetAccountsPagedRequest, rhs: Metro_Loyalty_V1_GetAccountsPagedRequest) -> Bool {
    if lhs.idProject != rhs.idProject {return false}
    if lhs._idCampaign != rhs._idCampaign {return false}
    if lhs._paging != rhs._paging {return false}
    if lhs._filterKeyword != rhs._filterKeyword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetAccountsPagedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountsPagedResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Metro_Loyalty_V1_GetAccountsPagedResponse.GetAccountsPagedError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      case 2: try {
        var v: Metro_Loyalty_V1_GetAccountsPagedResponse.Page?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .page(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .page(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .page?: try {
      guard case .page(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetAccountsPagedResponse, rhs: Metro_Loyalty_V1_GetAccountsPagedResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetAccountsPagedResponse.GetAccountsPagedError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CAMPAIGN_NOT_FOUND"),
  ]
}

extension Metro_Loyalty_V1_GetAccountsPagedResponse.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_V1_GetAccountsPagedResponse.protoMessageName + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetAccountsPagedResponse.Node, rhs: Metro_Loyalty_V1_GetAccountsPagedResponse.Node) -> Bool {
    if lhs._cursor != rhs._cursor {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetAccountsPagedResponse.Page: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Metro_Loyalty_V1_GetAccountsPagedResponse.protoMessageName + ".Page"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "has_next"),
    2: .same(proto: "nodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hasNext_p) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.nodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hasNext_p != false {
      try visitor.visitSingularBoolField(value: self.hasNext_p, fieldNumber: 1)
    }
    if !self.nodes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetAccountsPagedResponse.Page, rhs: Metro_Loyalty_V1_GetAccountsPagedResponse.Page) -> Bool {
    if lhs.hasNext_p != rhs.hasNext_p {return false}
    if lhs.nodes != rhs.nodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetAccountDetailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountDetailRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_project"),
    2: .standard(proto: "id_account"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._idAccount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 1)
    }
    try { if let v = self._idAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetAccountDetailRequest, rhs: Metro_Loyalty_V1_GetAccountDetailRequest) -> Bool {
    if lhs.idProject != rhs.idProject {return false}
    if lhs._idAccount != rhs._idAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetAccountDetailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountDetailResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "detail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._detail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetAccountDetailResponse, rhs: Metro_Loyalty_V1_GetAccountDetailResponse) -> Bool {
    if lhs._detail != rhs._detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetCampaignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_project"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetCampaignRequest, rhs: Metro_Loyalty_V1_GetCampaignRequest) -> Bool {
    if lhs.idProject != rhs.idProject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetCampaignResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCampaignResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "campaign"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Metro_Loyalty_V1_GetCampaignResponse.GetCampaignError?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      case 2: try {
        var v: Metro_Loyalty_Data_V1_Campaign?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .campaign(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .campaign(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .campaign?: try {
      guard case .campaign(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_GetCampaignResponse, rhs: Metro_Loyalty_V1_GetCampaignResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_GetCampaignResponse.GetCampaignError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CAMPAIGN_NOT_FOUND"),
  ]
}

extension Metro_Loyalty_V1_UpdateCampaignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCampaignRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "id_project"),
    2: .same(proto: "campaign"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._campaign) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 1)
    }
    try { if let v = self._campaign {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_UpdateCampaignRequest, rhs: Metro_Loyalty_V1_UpdateCampaignRequest) -> Bool {
    if lhs.idProject != rhs.idProject {return false}
    if lhs._campaign != rhs._campaign {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_UpdateCampaignResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCampaignResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._error {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Loyalty_V1_UpdateCampaignResponse, rhs: Metro_Loyalty_V1_UpdateCampaignResponse) -> Bool {
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Loyalty_V1_UpdateCampaignResponse.UpdateCampaignError: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CAMPAIGN_NOT_FOUND"),
  ]
}
