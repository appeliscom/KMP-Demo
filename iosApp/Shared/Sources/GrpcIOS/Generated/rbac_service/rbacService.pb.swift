// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rbac_service/rbacService.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Appelis_RbacService_V1_Permission: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0
  case articleArticleCreate // = 100
  case articleArticleRead // = 101
  case articleArticleDelete // = 103
  case articleCategorymapCreate // = 102
  case articleAttributesCreate // = 104
  case articleAttributesDelete // = 105
  case articleAttributesRead // = 106
  case articleAttributevalueRead // = 107
  case articleAttributevalueCreate // = 108
  case articleAttributevalueDelete // = 109
  case articleCurrencyCreate // = 110
  case articlePackageCreate // = 111
  case articlePackageRead // = 112
  case articlePackageDelete // = 113
  case articlePackageAssign // = 114
  case bannerBannerCreate // = 200
  case bannerBannerRead // = 201
  case bannerCollectionCreate // = 202
  case bannerCollectionRead // = 203
  case bannerCollectionmapCreate // = 204
  case bannerCategorymapCreate // = 205
  case beaconBeaconCreate // = 300
  case beaconBeaconRead // = 301
  case beaconActionCreate // = 302
  case beaconActionRead // = 303
  case beaconActionmapCreate // = 304
  case businessBusinessCreate // = 400
  case businessBusinessRead // = 401
  case categoryCategoryCreate // = 500
  case categoryCategoryRead // = 501
  case categoryBusinessmapCreate // = 502
  case categoryBannercollectionmapCreate // = 503
  case groupGroupCreate // = 600
  case groupGroupRead // = 601
  case mobileuserUserCreate // = 700
  case mobileuserUserRead // = 701
  case mobileuserGroupmapCreate // = 702
  case mobileuserUserDelete // = 703
  case mobileuserGroupmapDelete // = 704
  case myoffersArticleCreate // = 800
  case myoffersArticleRead // = 801
  case myoofersCategoryCreate // = 802
  case myoffersCategoryRead // = 803
  case notificationNotificationCreate // = 900
  case notificationNotificationRead // = 901
  case projectProjectCreate // = 1000
  case projectProjectRead // = 1001
  case rbacPermissionCreate // = 1100
  case retailorderLocationCreate // = 1200
  case retailorderKitchenRead // = 1201
  case retailorderCashdeskRead // = 1202
  case deliveryOrdersRead // = 1250
  case deliveryBusinessDeliveryhoursRead // = 1251
  case deliveryBusinessDeliveryhoursCreate // = 1252
  case deliveryBusinessDeliveryhoursDelete // = 1253
  case userUserCreate // = 1300
  case userUserRead // = 1301
  case userPasswordCreate // = 1302
  case clickcollectRegistrationRead // = 1400
  case clickcollectRegistrationUpdate // = 1401
  case clickcollectRegistrationDelete // = 1402
  case translationsCreate // = 1500
  case translationsDelete // = 1501
  case translationsRead // = 1502
  case starclubCampaignRead // = 1600
  case starclubCampaignCreate // = 1601
  case retailMenuSettingsCreate // = 1700
  case retailMenuSettingsRead // = 1701
  case retailMenuSettingsUpdate // = 1702
  case retailMenuSourceMenuCreate // = 1703
  case retailMenuSourceMenuRead // = 1704
  case retailMenuSourceMenuUpdate // = 1705
  case retailMenuSourceMenuDelete // = 1706
  case contactsContactsRead // = 1800
  case contactsContactsCreate // = 1801
  case contactsContactsDelete // = 1802
  case retailcartPaymentratesRead // = 1900
  case retailcartPaymentratesCreate // = 1901
  case retailcartPaymentratesDelete // = 1902
  case retailcartShippingratesRead // = 2000
  case retailcartShippingratesCreate // = 2001
  case retailcartShippingratesDelete // = 2002
  case paymentsCsobRead // = 2100
  case paymentsCsobCreate // = 2101
  case projectSettingsRead // = 2200
  case projectSettingsCreate // = 2201
  case newsfeedItemsRead // = 2300
  case newsfeedItemsCreate // = 2301
  case newsfeedItemsDelete // = 2302
  case statisticsRead // = 2400
  case loyaltyRead // = 2500
  case loyaltyWrite // = 2501
  case loyaltyAcademyCodesWrite // = 2502
  case unverifiedCardRead // = 2600
  case unverifiedCardWrite // = 2601
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 100: self = .articleArticleCreate
    case 101: self = .articleArticleRead
    case 102: self = .articleCategorymapCreate
    case 103: self = .articleArticleDelete
    case 104: self = .articleAttributesCreate
    case 105: self = .articleAttributesDelete
    case 106: self = .articleAttributesRead
    case 107: self = .articleAttributevalueRead
    case 108: self = .articleAttributevalueCreate
    case 109: self = .articleAttributevalueDelete
    case 110: self = .articleCurrencyCreate
    case 111: self = .articlePackageCreate
    case 112: self = .articlePackageRead
    case 113: self = .articlePackageDelete
    case 114: self = .articlePackageAssign
    case 200: self = .bannerBannerCreate
    case 201: self = .bannerBannerRead
    case 202: self = .bannerCollectionCreate
    case 203: self = .bannerCollectionRead
    case 204: self = .bannerCollectionmapCreate
    case 205: self = .bannerCategorymapCreate
    case 300: self = .beaconBeaconCreate
    case 301: self = .beaconBeaconRead
    case 302: self = .beaconActionCreate
    case 303: self = .beaconActionRead
    case 304: self = .beaconActionmapCreate
    case 400: self = .businessBusinessCreate
    case 401: self = .businessBusinessRead
    case 500: self = .categoryCategoryCreate
    case 501: self = .categoryCategoryRead
    case 502: self = .categoryBusinessmapCreate
    case 503: self = .categoryBannercollectionmapCreate
    case 600: self = .groupGroupCreate
    case 601: self = .groupGroupRead
    case 700: self = .mobileuserUserCreate
    case 701: self = .mobileuserUserRead
    case 702: self = .mobileuserGroupmapCreate
    case 703: self = .mobileuserUserDelete
    case 704: self = .mobileuserGroupmapDelete
    case 800: self = .myoffersArticleCreate
    case 801: self = .myoffersArticleRead
    case 802: self = .myoofersCategoryCreate
    case 803: self = .myoffersCategoryRead
    case 900: self = .notificationNotificationCreate
    case 901: self = .notificationNotificationRead
    case 1000: self = .projectProjectCreate
    case 1001: self = .projectProjectRead
    case 1100: self = .rbacPermissionCreate
    case 1200: self = .retailorderLocationCreate
    case 1201: self = .retailorderKitchenRead
    case 1202: self = .retailorderCashdeskRead
    case 1250: self = .deliveryOrdersRead
    case 1251: self = .deliveryBusinessDeliveryhoursRead
    case 1252: self = .deliveryBusinessDeliveryhoursCreate
    case 1253: self = .deliveryBusinessDeliveryhoursDelete
    case 1300: self = .userUserCreate
    case 1301: self = .userUserRead
    case 1302: self = .userPasswordCreate
    case 1400: self = .clickcollectRegistrationRead
    case 1401: self = .clickcollectRegistrationUpdate
    case 1402: self = .clickcollectRegistrationDelete
    case 1500: self = .translationsCreate
    case 1501: self = .translationsDelete
    case 1502: self = .translationsRead
    case 1600: self = .starclubCampaignRead
    case 1601: self = .starclubCampaignCreate
    case 1700: self = .retailMenuSettingsCreate
    case 1701: self = .retailMenuSettingsRead
    case 1702: self = .retailMenuSettingsUpdate
    case 1703: self = .retailMenuSourceMenuCreate
    case 1704: self = .retailMenuSourceMenuRead
    case 1705: self = .retailMenuSourceMenuUpdate
    case 1706: self = .retailMenuSourceMenuDelete
    case 1800: self = .contactsContactsRead
    case 1801: self = .contactsContactsCreate
    case 1802: self = .contactsContactsDelete
    case 1900: self = .retailcartPaymentratesRead
    case 1901: self = .retailcartPaymentratesCreate
    case 1902: self = .retailcartPaymentratesDelete
    case 2000: self = .retailcartShippingratesRead
    case 2001: self = .retailcartShippingratesCreate
    case 2002: self = .retailcartShippingratesDelete
    case 2100: self = .paymentsCsobRead
    case 2101: self = .paymentsCsobCreate
    case 2200: self = .projectSettingsRead
    case 2201: self = .projectSettingsCreate
    case 2300: self = .newsfeedItemsRead
    case 2301: self = .newsfeedItemsCreate
    case 2302: self = .newsfeedItemsDelete
    case 2400: self = .statisticsRead
    case 2500: self = .loyaltyRead
    case 2501: self = .loyaltyWrite
    case 2502: self = .loyaltyAcademyCodesWrite
    case 2600: self = .unverifiedCardRead
    case 2601: self = .unverifiedCardWrite
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .articleArticleCreate: return 100
    case .articleArticleRead: return 101
    case .articleCategorymapCreate: return 102
    case .articleArticleDelete: return 103
    case .articleAttributesCreate: return 104
    case .articleAttributesDelete: return 105
    case .articleAttributesRead: return 106
    case .articleAttributevalueRead: return 107
    case .articleAttributevalueCreate: return 108
    case .articleAttributevalueDelete: return 109
    case .articleCurrencyCreate: return 110
    case .articlePackageCreate: return 111
    case .articlePackageRead: return 112
    case .articlePackageDelete: return 113
    case .articlePackageAssign: return 114
    case .bannerBannerCreate: return 200
    case .bannerBannerRead: return 201
    case .bannerCollectionCreate: return 202
    case .bannerCollectionRead: return 203
    case .bannerCollectionmapCreate: return 204
    case .bannerCategorymapCreate: return 205
    case .beaconBeaconCreate: return 300
    case .beaconBeaconRead: return 301
    case .beaconActionCreate: return 302
    case .beaconActionRead: return 303
    case .beaconActionmapCreate: return 304
    case .businessBusinessCreate: return 400
    case .businessBusinessRead: return 401
    case .categoryCategoryCreate: return 500
    case .categoryCategoryRead: return 501
    case .categoryBusinessmapCreate: return 502
    case .categoryBannercollectionmapCreate: return 503
    case .groupGroupCreate: return 600
    case .groupGroupRead: return 601
    case .mobileuserUserCreate: return 700
    case .mobileuserUserRead: return 701
    case .mobileuserGroupmapCreate: return 702
    case .mobileuserUserDelete: return 703
    case .mobileuserGroupmapDelete: return 704
    case .myoffersArticleCreate: return 800
    case .myoffersArticleRead: return 801
    case .myoofersCategoryCreate: return 802
    case .myoffersCategoryRead: return 803
    case .notificationNotificationCreate: return 900
    case .notificationNotificationRead: return 901
    case .projectProjectCreate: return 1000
    case .projectProjectRead: return 1001
    case .rbacPermissionCreate: return 1100
    case .retailorderLocationCreate: return 1200
    case .retailorderKitchenRead: return 1201
    case .retailorderCashdeskRead: return 1202
    case .deliveryOrdersRead: return 1250
    case .deliveryBusinessDeliveryhoursRead: return 1251
    case .deliveryBusinessDeliveryhoursCreate: return 1252
    case .deliveryBusinessDeliveryhoursDelete: return 1253
    case .userUserCreate: return 1300
    case .userUserRead: return 1301
    case .userPasswordCreate: return 1302
    case .clickcollectRegistrationRead: return 1400
    case .clickcollectRegistrationUpdate: return 1401
    case .clickcollectRegistrationDelete: return 1402
    case .translationsCreate: return 1500
    case .translationsDelete: return 1501
    case .translationsRead: return 1502
    case .starclubCampaignRead: return 1600
    case .starclubCampaignCreate: return 1601
    case .retailMenuSettingsCreate: return 1700
    case .retailMenuSettingsRead: return 1701
    case .retailMenuSettingsUpdate: return 1702
    case .retailMenuSourceMenuCreate: return 1703
    case .retailMenuSourceMenuRead: return 1704
    case .retailMenuSourceMenuUpdate: return 1705
    case .retailMenuSourceMenuDelete: return 1706
    case .contactsContactsRead: return 1800
    case .contactsContactsCreate: return 1801
    case .contactsContactsDelete: return 1802
    case .retailcartPaymentratesRead: return 1900
    case .retailcartPaymentratesCreate: return 1901
    case .retailcartPaymentratesDelete: return 1902
    case .retailcartShippingratesRead: return 2000
    case .retailcartShippingratesCreate: return 2001
    case .retailcartShippingratesDelete: return 2002
    case .paymentsCsobRead: return 2100
    case .paymentsCsobCreate: return 2101
    case .projectSettingsRead: return 2200
    case .projectSettingsCreate: return 2201
    case .newsfeedItemsRead: return 2300
    case .newsfeedItemsCreate: return 2301
    case .newsfeedItemsDelete: return 2302
    case .statisticsRead: return 2400
    case .loyaltyRead: return 2500
    case .loyaltyWrite: return 2501
    case .loyaltyAcademyCodesWrite: return 2502
    case .unverifiedCardRead: return 2600
    case .unverifiedCardWrite: return 2601
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Appelis_RbacService_V1_Permission: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_RbacService_V1_Permission] = [
    .unspecified,
    .articleArticleCreate,
    .articleArticleRead,
    .articleArticleDelete,
    .articleCategorymapCreate,
    .articleAttributesCreate,
    .articleAttributesDelete,
    .articleAttributesRead,
    .articleAttributevalueRead,
    .articleAttributevalueCreate,
    .articleAttributevalueDelete,
    .articleCurrencyCreate,
    .articlePackageCreate,
    .articlePackageRead,
    .articlePackageDelete,
    .articlePackageAssign,
    .bannerBannerCreate,
    .bannerBannerRead,
    .bannerCollectionCreate,
    .bannerCollectionRead,
    .bannerCollectionmapCreate,
    .bannerCategorymapCreate,
    .beaconBeaconCreate,
    .beaconBeaconRead,
    .beaconActionCreate,
    .beaconActionRead,
    .beaconActionmapCreate,
    .businessBusinessCreate,
    .businessBusinessRead,
    .categoryCategoryCreate,
    .categoryCategoryRead,
    .categoryBusinessmapCreate,
    .categoryBannercollectionmapCreate,
    .groupGroupCreate,
    .groupGroupRead,
    .mobileuserUserCreate,
    .mobileuserUserRead,
    .mobileuserGroupmapCreate,
    .mobileuserUserDelete,
    .mobileuserGroupmapDelete,
    .myoffersArticleCreate,
    .myoffersArticleRead,
    .myoofersCategoryCreate,
    .myoffersCategoryRead,
    .notificationNotificationCreate,
    .notificationNotificationRead,
    .projectProjectCreate,
    .projectProjectRead,
    .rbacPermissionCreate,
    .retailorderLocationCreate,
    .retailorderKitchenRead,
    .retailorderCashdeskRead,
    .deliveryOrdersRead,
    .deliveryBusinessDeliveryhoursRead,
    .deliveryBusinessDeliveryhoursCreate,
    .deliveryBusinessDeliveryhoursDelete,
    .userUserCreate,
    .userUserRead,
    .userPasswordCreate,
    .clickcollectRegistrationRead,
    .clickcollectRegistrationUpdate,
    .clickcollectRegistrationDelete,
    .translationsCreate,
    .translationsDelete,
    .translationsRead,
    .starclubCampaignRead,
    .starclubCampaignCreate,
    .retailMenuSettingsCreate,
    .retailMenuSettingsRead,
    .retailMenuSettingsUpdate,
    .retailMenuSourceMenuCreate,
    .retailMenuSourceMenuRead,
    .retailMenuSourceMenuUpdate,
    .retailMenuSourceMenuDelete,
    .contactsContactsRead,
    .contactsContactsCreate,
    .contactsContactsDelete,
    .retailcartPaymentratesRead,
    .retailcartPaymentratesCreate,
    .retailcartPaymentratesDelete,
    .retailcartShippingratesRead,
    .retailcartShippingratesCreate,
    .retailcartShippingratesDelete,
    .paymentsCsobRead,
    .paymentsCsobCreate,
    .projectSettingsRead,
    .projectSettingsCreate,
    .newsfeedItemsRead,
    .newsfeedItemsCreate,
    .newsfeedItemsDelete,
    .statisticsRead,
    .loyaltyRead,
    .loyaltyWrite,
    .loyaltyAcademyCodesWrite,
    .unverifiedCardRead,
    .unverifiedCardWrite,
  ]
}

#endif  // swift(>=4.2)

public struct Appelis_RbacService_V1_ListProjectUserIdsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var projectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_RbacService_V1_ListProjectUserIdsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_RbacService_V1_Token {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_RbacService_V1_ListProjectsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var webUserID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_RbacService_V1_ListProjectsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var projectIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_RbacService_V1_HasPermissionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Appelis_RbacService_V1_HasPermissionsResponse.OneOf_Payload? = nil

  public var error: Appelis_RbacService_V1_HasPermissionsResponse.Error {
    get {
      if case .error(let v)? = payload {return v}
      return .unspecified
    }
    set {payload = .error(newValue)}
  }

  public var data: Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermissions {
    get {
      if case .data(let v)? = payload {return v}
      return Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermissions()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case error(Appelis_RbacService_V1_HasPermissionsResponse.Error)
    case data(Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermissions)

  #if !swift(>=4.1)
    public static func ==(lhs: Appelis_RbacService_V1_HasPermissionsResponse.OneOf_Payload, rhs: Appelis_RbacService_V1_HasPermissionsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case invalidToken // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .invalidToken
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .invalidToken: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct ValidatedPermission {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var permission: Appelis_RbacService_V1_Permission = .unspecified

    public var value: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct ValidatedPermissions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: [Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermission] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Appelis_RbacService_V1_HasPermissionsResponse.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_RbacService_V1_HasPermissionsResponse.Error] = [
    .unspecified,
    .invalidToken,
  ]
}

#endif  // swift(>=4.2)

public struct Appelis_RbacService_V1_HasPermissionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_RbacService_V1_Token {
    get {return _token ?? Appelis_RbacService_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var permissions: [Appelis_RbacService_V1_Permission] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_RbacService_V1_Token? = nil
}

public struct Appelis_RbacService_V1_ManagePermissionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_RbacService_V1_Token {
    get {return _token ?? Appelis_RbacService_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  public var idUser: String = String()

  public var permissions: [Appelis_RbacService_V1_Permission] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_RbacService_V1_Token? = nil
}

public struct Appelis_RbacService_V1_ManagePermissionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Appelis_RbacService_V1_ManagePermissionsResponse.OneOf_Payload? = nil

  public var error: Appelis_RbacService_V1_ManagePermissionsResponse.Error {
    get {
      if case .error(let v)? = payload {return v}
      return .unspecified
    }
    set {payload = .error(newValue)}
  }

  public var data: Appelis_RbacService_V1_ManagePermissionsResponse.PermissionsPayload {
    get {
      if case .data(let v)? = payload {return v}
      return Appelis_RbacService_V1_ManagePermissionsResponse.PermissionsPayload()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case error(Appelis_RbacService_V1_ManagePermissionsResponse.Error)
    case data(Appelis_RbacService_V1_ManagePermissionsResponse.PermissionsPayload)

  #if !swift(>=4.1)
    public static func ==(lhs: Appelis_RbacService_V1_ManagePermissionsResponse.OneOf_Payload, rhs: Appelis_RbacService_V1_ManagePermissionsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case invalidToken // = 1
    case unauthorized // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .invalidToken
      case 2: self = .unauthorized
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .invalidToken: return 1
      case .unauthorized: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct PermissionsPayload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var idUser: String = String()

    public var permissionsStatus: [Appelis_RbacService_V1_ManagePermissionsResponse.PermissionStatus] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct PermissionStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var permission: Appelis_RbacService_V1_Permission = .unspecified

    public var status: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Appelis_RbacService_V1_ManagePermissionsResponse.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_RbacService_V1_ManagePermissionsResponse.Error] = [
    .unspecified,
    .invalidToken,
    .unauthorized,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Appelis_RbacService_V1_Permission: @unchecked Sendable {}
extension Appelis_RbacService_V1_ListProjectUserIdsRequest: @unchecked Sendable {}
extension Appelis_RbacService_V1_ListProjectUserIdsResponse: @unchecked Sendable {}
extension Appelis_RbacService_V1_Token: @unchecked Sendable {}
extension Appelis_RbacService_V1_ListProjectsRequest: @unchecked Sendable {}
extension Appelis_RbacService_V1_ListProjectsResponse: @unchecked Sendable {}
extension Appelis_RbacService_V1_HasPermissionsResponse: @unchecked Sendable {}
extension Appelis_RbacService_V1_HasPermissionsResponse.OneOf_Payload: @unchecked Sendable {}
extension Appelis_RbacService_V1_HasPermissionsResponse.Error: @unchecked Sendable {}
extension Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermission: @unchecked Sendable {}
extension Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermissions: @unchecked Sendable {}
extension Appelis_RbacService_V1_HasPermissionsRequest: @unchecked Sendable {}
extension Appelis_RbacService_V1_ManagePermissionsRequest: @unchecked Sendable {}
extension Appelis_RbacService_V1_ManagePermissionsResponse: @unchecked Sendable {}
extension Appelis_RbacService_V1_ManagePermissionsResponse.OneOf_Payload: @unchecked Sendable {}
extension Appelis_RbacService_V1_ManagePermissionsResponse.Error: @unchecked Sendable {}
extension Appelis_RbacService_V1_ManagePermissionsResponse.PermissionsPayload: @unchecked Sendable {}
extension Appelis_RbacService_V1_ManagePermissionsResponse.PermissionStatus: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "appelis.rbacService.v1"

extension Appelis_RbacService_V1_Permission: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    100: .same(proto: "ARTICLE_ARTICLE_CREATE"),
    101: .same(proto: "ARTICLE_ARTICLE_READ"),
    102: .same(proto: "ARTICLE_CATEGORYMAP_CREATE"),
    103: .same(proto: "ARTICLE_ARTICLE_DELETE"),
    104: .same(proto: "ARTICLE_ATTRIBUTES_CREATE"),
    105: .same(proto: "ARTICLE_ATTRIBUTES_DELETE"),
    106: .same(proto: "ARTICLE_ATTRIBUTES_READ"),
    107: .same(proto: "ARTICLE_ATTRIBUTEVALUE_READ"),
    108: .same(proto: "ARTICLE_ATTRIBUTEVALUE_CREATE"),
    109: .same(proto: "ARTICLE_ATTRIBUTEVALUE_DELETE"),
    110: .same(proto: "ARTICLE_CURRENCY_CREATE"),
    111: .same(proto: "ARTICLE_PACKAGE_CREATE"),
    112: .same(proto: "ARTICLE_PACKAGE_READ"),
    113: .same(proto: "ARTICLE_PACKAGE_DELETE"),
    114: .same(proto: "ARTICLE_PACKAGE_ASSIGN"),
    200: .same(proto: "BANNER_BANNER_CREATE"),
    201: .same(proto: "BANNER_BANNER_READ"),
    202: .same(proto: "BANNER_COLLECTION_CREATE"),
    203: .same(proto: "BANNER_COLLECTION_READ"),
    204: .same(proto: "BANNER_COLLECTIONMAP_CREATE"),
    205: .same(proto: "BANNER_CATEGORYMAP_CREATE"),
    300: .same(proto: "BEACON_BEACON_CREATE"),
    301: .same(proto: "BEACON_BEACON_READ"),
    302: .same(proto: "BEACON_ACTION_CREATE"),
    303: .same(proto: "BEACON_ACTION_READ"),
    304: .same(proto: "BEACON_ACTIONMAP_CREATE"),
    400: .same(proto: "BUSINESS_BUSINESS_CREATE"),
    401: .same(proto: "BUSINESS_BUSINESS_READ"),
    500: .same(proto: "CATEGORY_CATEGORY_CREATE"),
    501: .same(proto: "CATEGORY_CATEGORY_READ"),
    502: .same(proto: "CATEGORY_BUSINESSMAP_CREATE"),
    503: .same(proto: "CATEGORY_BANNERCOLLECTIONMAP_CREATE"),
    600: .same(proto: "GROUP_GROUP_CREATE"),
    601: .same(proto: "GROUP_GROUP_READ"),
    700: .same(proto: "MOBILEUSER_USER_CREATE"),
    701: .same(proto: "MOBILEUSER_USER_READ"),
    702: .same(proto: "MOBILEUSER_GROUPMAP_CREATE"),
    703: .same(proto: "MOBILEUSER_USER_DELETE"),
    704: .same(proto: "MOBILEUSER_GROUPMAP_DELETE"),
    800: .same(proto: "MYOFFERS_ARTICLE_CREATE"),
    801: .same(proto: "MYOFFERS_ARTICLE_READ"),
    802: .same(proto: "MYOOFERS_CATEGORY_CREATE"),
    803: .same(proto: "MYOFFERS_CATEGORY_READ"),
    900: .same(proto: "NOTIFICATION_NOTIFICATION_CREATE"),
    901: .same(proto: "NOTIFICATION_NOTIFICATION_READ"),
    1000: .same(proto: "PROJECT_PROJECT_CREATE"),
    1001: .same(proto: "PROJECT_PROJECT_READ"),
    1100: .same(proto: "RBAC_PERMISSION_CREATE"),
    1200: .same(proto: "RETAILORDER_LOCATION_CREATE"),
    1201: .same(proto: "RETAILORDER_KITCHEN_READ"),
    1202: .same(proto: "RETAILORDER_CASHDESK_READ"),
    1250: .same(proto: "DELIVERY_ORDERS_READ"),
    1251: .same(proto: "DELIVERY_BUSINESS_DELIVERYHOURS_READ"),
    1252: .same(proto: "DELIVERY_BUSINESS_DELIVERYHOURS_CREATE"),
    1253: .same(proto: "DELIVERY_BUSINESS_DELIVERYHOURS_DELETE"),
    1300: .same(proto: "USER_USER_CREATE"),
    1301: .same(proto: "USER_USER_READ"),
    1302: .same(proto: "USER_PASSWORD_CREATE"),
    1400: .same(proto: "CLICKCOLLECT_REGISTRATION_READ"),
    1401: .same(proto: "CLICKCOLLECT_REGISTRATION_UPDATE"),
    1402: .same(proto: "CLICKCOLLECT_REGISTRATION_DELETE"),
    1500: .same(proto: "TRANSLATIONS_CREATE"),
    1501: .same(proto: "TRANSLATIONS_DELETE"),
    1502: .same(proto: "TRANSLATIONS_READ"),
    1600: .same(proto: "STARCLUB_CAMPAIGN_READ"),
    1601: .same(proto: "STARCLUB_CAMPAIGN_CREATE"),
    1700: .same(proto: "RETAIL_MENU_SETTINGS_CREATE"),
    1701: .same(proto: "RETAIL_MENU_SETTINGS_READ"),
    1702: .same(proto: "RETAIL_MENU_SETTINGS_UPDATE"),
    1703: .same(proto: "RETAIL_MENU_SOURCE_MENU_CREATE"),
    1704: .same(proto: "RETAIL_MENU_SOURCE_MENU_READ"),
    1705: .same(proto: "RETAIL_MENU_SOURCE_MENU_UPDATE"),
    1706: .same(proto: "RETAIL_MENU_SOURCE_MENU_DELETE"),
    1800: .same(proto: "CONTACTS_CONTACTS_READ"),
    1801: .same(proto: "CONTACTS_CONTACTS_CREATE"),
    1802: .same(proto: "CONTACTS_CONTACTS_DELETE"),
    1900: .same(proto: "RETAILCART_PAYMENTRATES_READ"),
    1901: .same(proto: "RETAILCART_PAYMENTRATES_CREATE"),
    1902: .same(proto: "RETAILCART_PAYMENTRATES_DELETE"),
    2000: .same(proto: "RETAILCART_SHIPPINGRATES_READ"),
    2001: .same(proto: "RETAILCART_SHIPPINGRATES_CREATE"),
    2002: .same(proto: "RETAILCART_SHIPPINGRATES_DELETE"),
    2100: .same(proto: "PAYMENTS_CSOB_READ"),
    2101: .same(proto: "PAYMENTS_CSOB_CREATE"),
    2200: .same(proto: "PROJECT_SETTINGS_READ"),
    2201: .same(proto: "PROJECT_SETTINGS_CREATE"),
    2300: .same(proto: "NEWSFEED_ITEMS_READ"),
    2301: .same(proto: "NEWSFEED_ITEMS_CREATE"),
    2302: .same(proto: "NEWSFEED_ITEMS_DELETE"),
    2400: .same(proto: "STATISTICS_READ"),
    2500: .same(proto: "LOYALTY_READ"),
    2501: .same(proto: "LOYALTY_WRITE"),
    2502: .same(proto: "LOYALTY_ACADEMY_CODES_WRITE"),
    2600: .same(proto: "UNVERIFIED_CARD_READ"),
    2601: .same(proto: "UNVERIFIED_CARD_WRITE"),
  ]
}

extension Appelis_RbacService_V1_ListProjectUserIdsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListProjectUserIdsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "projectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_ListProjectUserIdsRequest, rhs: Appelis_RbacService_V1_ListProjectUserIdsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_ListProjectUserIdsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListProjectUserIdsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.userIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.userIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_ListProjectUserIdsResponse, rhs: Appelis_RbacService_V1_ListProjectUserIdsResponse) -> Bool {
    if lhs.userIds != rhs.userIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Token"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_Token, rhs: Appelis_RbacService_V1_Token) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_ListProjectsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListProjectsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "webUserId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.webUserID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.webUserID.isEmpty {
      try visitor.visitSingularStringField(value: self.webUserID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_ListProjectsRequest, rhs: Appelis_RbacService_V1_ListProjectsRequest) -> Bool {
    if lhs.webUserID != rhs.webUserID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_ListProjectsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListProjectsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "projectIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.projectIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.projectIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_ListProjectsResponse, rhs: Appelis_RbacService_V1_ListProjectsResponse) -> Bool {
    if lhs.projectIds != rhs.projectIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_HasPermissionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HasPermissionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_RbacService_V1_HasPermissionsResponse.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      case 2: try {
        var v: Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermissions?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_HasPermissionsResponse, rhs: Appelis_RbacService_V1_HasPermissionsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_HasPermissionsResponse.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "INVALID_TOKEN"),
  ]
}

extension Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_RbacService_V1_HasPermissionsResponse.protoMessageName + ".ValidatedPermission"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permission"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.permission) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.permission != .unspecified {
      try visitor.visitSingularEnumField(value: self.permission, fieldNumber: 1)
    }
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermission, rhs: Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermission) -> Bool {
    if lhs.permission != rhs.permission {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_RbacService_V1_HasPermissionsResponse.protoMessageName + ".ValidatedPermissions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermissions, rhs: Appelis_RbacService_V1_HasPermissionsResponse.ValidatedPermissions) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_HasPermissionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HasPermissionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    3: .same(proto: "permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.permissions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.permissions.isEmpty {
      try visitor.visitPackedEnumField(value: self.permissions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_HasPermissionsRequest, rhs: Appelis_RbacService_V1_HasPermissionsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_ManagePermissionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagePermissionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "idUser"),
    4: .same(proto: "permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.idUser) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.permissions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.idUser.isEmpty {
      try visitor.visitSingularStringField(value: self.idUser, fieldNumber: 2)
    }
    if !self.permissions.isEmpty {
      try visitor.visitPackedEnumField(value: self.permissions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_ManagePermissionsRequest, rhs: Appelis_RbacService_V1_ManagePermissionsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.idUser != rhs.idUser {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_ManagePermissionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagePermissionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_RbacService_V1_ManagePermissionsResponse.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      case 2: try {
        var v: Appelis_RbacService_V1_ManagePermissionsResponse.PermissionsPayload?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_ManagePermissionsResponse, rhs: Appelis_RbacService_V1_ManagePermissionsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_ManagePermissionsResponse.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "INVALID_TOKEN"),
    2: .same(proto: "UNAUTHORIZED"),
  ]
}

extension Appelis_RbacService_V1_ManagePermissionsResponse.PermissionsPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_RbacService_V1_ManagePermissionsResponse.protoMessageName + ".PermissionsPayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "idUser"),
    3: .same(proto: "permissionsStatus"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idUser) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.permissionsStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idUser.isEmpty {
      try visitor.visitSingularStringField(value: self.idUser, fieldNumber: 1)
    }
    if !self.permissionsStatus.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permissionsStatus, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_ManagePermissionsResponse.PermissionsPayload, rhs: Appelis_RbacService_V1_ManagePermissionsResponse.PermissionsPayload) -> Bool {
    if lhs.idUser != rhs.idUser {return false}
    if lhs.permissionsStatus != rhs.permissionsStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_RbacService_V1_ManagePermissionsResponse.PermissionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_RbacService_V1_ManagePermissionsResponse.protoMessageName + ".PermissionStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permission"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.permission) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.permission != .unspecified {
      try visitor.visitSingularEnumField(value: self.permission, fieldNumber: 1)
    }
    if self.status != false {
      try visitor.visitSingularBoolField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_RbacService_V1_ManagePermissionsResponse.PermissionStatus, rhs: Appelis_RbacService_V1_ManagePermissionsResponse.PermissionStatus) -> Bool {
    if lhs.permission != rhs.permission {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
