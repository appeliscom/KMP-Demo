// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: metro_signIn_service/signIn.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Appelis_Metro_SignIn_V1_UpdateUsersCardsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var token: Appelis_Metro_SignIn_V1_AipToken {
    get {return _token ?? Appelis_Metro_SignIn_V1_AipToken()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  /// Ids of users for which cards will be updated, and bool for logic when user will be logged out.
  public var mobileUserIds: Dictionary<Int64,Bool> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Metro_SignIn_V1_AipToken? = nil
}

public struct Appelis_Metro_SignIn_V1_UpdateUsersCardsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Appelis_Metro_SignIn_V1_UpdateUsersCardsResponse.OneOf_Payload? = nil

  public var error: Appelis_Metro_SignIn_V1_ExportLoginResponse.Error {
    get {
      if case .error(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case error(Appelis_Metro_SignIn_V1_ExportLoginResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Appelis_Metro_SignIn_V1_UpdateUsersCardsResponse.OneOf_Payload, rhs: Appelis_Metro_SignIn_V1_UpdateUsersCardsResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

public struct Appelis_Metro_SignIn_V1_LoginData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int64 = 0

  public var idProject: String = String()

  public var storeNo: String = String()

  public var custNo: String = String()

  public var chNo: String = String()

  public var advisorID: String = String()

  public var branchID: String = String()

  public var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  public var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  public mutating func clearCreatedAt() {self._createdAt = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Appelis_Metro_SignIn_V1_ArrayLoginData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Appelis_Metro_SignIn_V1_LoginData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Appelis_Metro_SignIn_V1_ExportLoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Appelis_Metro_SignIn_V1_ExportLoginResponse.OneOf_Payload? = nil

  public var error: Appelis_Metro_SignIn_V1_ExportLoginResponse.Error {
    get {
      if case .error(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .error(newValue)}
  }

  public var data: Appelis_Metro_SignIn_V1_ArrayLoginData {
    get {
      if case .data(let v)? = payload {return v}
      return Appelis_Metro_SignIn_V1_ArrayLoginData()
    }
    set {payload = .data(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case error(Appelis_Metro_SignIn_V1_ExportLoginResponse.Error)
    case data(Appelis_Metro_SignIn_V1_ArrayLoginData)

  #if !swift(>=4.1)
    public static func ==(lhs: Appelis_Metro_SignIn_V1_ExportLoginResponse.OneOf_Payload, rhs: Appelis_Metro_SignIn_V1_ExportLoginResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0
    case invalidToken // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .invalidToken
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .invalidToken: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Appelis_Metro_SignIn_V1_ExportLoginResponse.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_Metro_SignIn_V1_ExportLoginResponse.Error] = [
    .unknown,
    .invalidToken,
  ]
}

#endif  // swift(>=4.2)

public struct Appelis_Metro_SignIn_V1_EmailVerifyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var req: Appelis_Metro_SignIn_V1_PhoneVerifyRequest {
    get {return _req ?? Appelis_Metro_SignIn_V1_PhoneVerifyRequest()}
    set {_req = newValue}
  }
  /// Returns true if `req` has been explicitly set.
  public var hasReq: Bool {return self._req != nil}
  /// Clears the value of `req`. Subsequent reads from it will return its default value.
  public mutating func clearReq() {self._req = nil}

  /// Selected businessId in device. For first login and business setup from email link.
  public var businessID: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _req: Appelis_Metro_SignIn_V1_PhoneVerifyRequest? = nil
}

public struct Appelis_Metro_SignIn_V1_PhoneVerifyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MobileUser id that is bind to card.
  public var mobileUserID: Int64 = 0

  /// CardEan scanned by device.
  public var cardEan: String = String()

  /// AccessToken
  public var token: Appelis_Metro_SignIn_V1_AipToken {
    get {return _token ?? Appelis_Metro_SignIn_V1_AipToken()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  public var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  public mutating func clearToken() {self._token = nil}

  /// if true -> email/sms won't be send.
  public var dryRun: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _token: Appelis_Metro_SignIn_V1_AipToken? = nil
}

public struct Appelis_Metro_SignIn_V1_PhoneVerifyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Appelis_Metro_SignIn_V1_PhoneVerifyResponse.OneOf_Payload? = nil

  /// Error is optional can be null
  public var error: Appelis_Metro_SignIn_V1_PhoneVerifyResponse.Error {
    get {
      if case .error(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    /// Error is optional can be null
    case error(Appelis_Metro_SignIn_V1_PhoneVerifyResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Appelis_Metro_SignIn_V1_PhoneVerifyResponse.OneOf_Payload, rhs: Appelis_Metro_SignIn_V1_PhoneVerifyResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Invalid token or bad claims.
    case invalidToken // = 1

    /// cardEan can't be parsed or have bad data.
    case invalidCard // = 2

    /// Selected mobile user was not found.
    case mobileUserNotFound // = 3

    /// When phone number is set to "" or some bad value...
    case phoneNumberNotFound // = 4

    /// Cardholder version doesn't match version on scanned card.
    case wrongCardVersion // = 5

    /// Error occurs when sending sms to external service.
    case failedToSendSms // = 6

    /// Block codes are set.
    case userBlocked // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .invalidToken
      case 2: self = .invalidCard
      case 3: self = .mobileUserNotFound
      case 4: self = .phoneNumberNotFound
      case 5: self = .wrongCardVersion
      case 6: self = .failedToSendSms
      case 7: self = .userBlocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .invalidToken: return 1
      case .invalidCard: return 2
      case .mobileUserNotFound: return 3
      case .phoneNumberNotFound: return 4
      case .wrongCardVersion: return 5
      case .failedToSendSms: return 6
      case .userBlocked: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Appelis_Metro_SignIn_V1_PhoneVerifyResponse.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_Metro_SignIn_V1_PhoneVerifyResponse.Error] = [
    .unknown,
    .invalidToken,
    .invalidCard,
    .mobileUserNotFound,
    .phoneNumberNotFound,
    .wrongCardVersion,
    .failedToSendSms,
    .userBlocked,
  ]
}

#endif  // swift(>=4.2)

public struct Appelis_Metro_SignIn_V1_EmailVerifyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Appelis_Metro_SignIn_V1_EmailVerifyResponse.OneOf_Payload? = nil

  /// Error is optional can be null
  public var error: Appelis_Metro_SignIn_V1_EmailVerifyResponse.Error {
    get {
      if case .error(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    /// Error is optional can be null
    case error(Appelis_Metro_SignIn_V1_EmailVerifyResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Appelis_Metro_SignIn_V1_EmailVerifyResponse.OneOf_Payload, rhs: Appelis_Metro_SignIn_V1_EmailVerifyResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Invalid token or bad claims.
    case invalidToken // = 1

    /// cardEan can't be parsed or have bad data.
    case invalidCard // = 2

    /// Selected mobile user was not found.
    case mobileUserNotFound // = 3

    /// When email is set to "" or some bad value...
    case emailNotFound // = 4

    /// Cardholder version doesn't match version on scanned card.
    case wrongCardVersion // = 5

    /// Block codes are set.
    case userBlocked // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .invalidToken
      case 2: self = .invalidCard
      case 3: self = .mobileUserNotFound
      case 4: self = .emailNotFound
      case 5: self = .wrongCardVersion
      case 6: self = .userBlocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .invalidToken: return 1
      case .invalidCard: return 2
      case .mobileUserNotFound: return 3
      case .emailNotFound: return 4
      case .wrongCardVersion: return 5
      case .userBlocked: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Appelis_Metro_SignIn_V1_EmailVerifyResponse.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_Metro_SignIn_V1_EmailVerifyResponse.Error] = [
    .unknown,
    .invalidToken,
    .invalidCard,
    .mobileUserNotFound,
    .emailNotFound,
    .wrongCardVersion,
    .userBlocked,
  ]
}

#endif  // swift(>=4.2)

public struct Appelis_Metro_SignIn_V1_FirebaseLoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var req: Appelis_Metro_SignIn_V1_PhoneVerifyRequest {
    get {return _req ?? Appelis_Metro_SignIn_V1_PhoneVerifyRequest()}
    set {_req = newValue}
  }
  /// Returns true if `req` has been explicitly set.
  public var hasReq: Bool {return self._req != nil}
  /// Clears the value of `req`. Subsequent reads from it will return its default value.
  public mutating func clearReq() {self._req = nil}

  public var firebaseIDToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _req: Appelis_Metro_SignIn_V1_PhoneVerifyRequest? = nil
}

public struct Appelis_Metro_SignIn_V1_FirebaseLoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Appelis_Metro_SignIn_V1_FirebaseLoginResponse.OneOf_Payload? = nil

  public var error: Appelis_Metro_SignIn_V1_FirebaseLoginResponse.Error {
    get {
      if case .error(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case error(Appelis_Metro_SignIn_V1_FirebaseLoginResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Appelis_Metro_SignIn_V1_FirebaseLoginResponse.OneOf_Payload, rhs: Appelis_Metro_SignIn_V1_FirebaseLoginResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Invalid token or bad claims.
    case invalidToken // = 1

    /// cardEan can't be parsed or have bad data.
    case invalidCard // = 2

    /// Selected mobile user was not found.
    case mobileUserNotFound // = 3

    /// Firebase sdk returns error when verifying id token.
    case invalidFirebaseToken // = 4

    /// Cardholder version doesn't match version on scanned card.
    case wrongCardVersion // = 5

    /// Block codes are set.
    case userBlocked // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .invalidToken
      case 2: self = .invalidCard
      case 3: self = .mobileUserNotFound
      case 4: self = .invalidFirebaseToken
      case 5: self = .wrongCardVersion
      case 6: self = .userBlocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .invalidToken: return 1
      case .invalidCard: return 2
      case .mobileUserNotFound: return 3
      case .invalidFirebaseToken: return 4
      case .wrongCardVersion: return 5
      case .userBlocked: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Appelis_Metro_SignIn_V1_FirebaseLoginResponse.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_Metro_SignIn_V1_FirebaseLoginResponse.Error] = [
    .unknown,
    .invalidToken,
    .invalidCard,
    .mobileUserNotFound,
    .invalidFirebaseToken,
    .wrongCardVersion,
    .userBlocked,
  ]
}

#endif  // swift(>=4.2)

public struct Appelis_Metro_SignIn_V1_LoginRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var req: Appelis_Metro_SignIn_V1_PhoneVerifyRequest {
    get {return _req ?? Appelis_Metro_SignIn_V1_PhoneVerifyRequest()}
    set {_req = newValue}
  }
  /// Returns true if `req` has been explicitly set.
  public var hasReq: Bool {return self._req != nil}
  /// Clears the value of `req`. Subsequent reads from it will return its default value.
  public mutating func clearReq() {self._req = nil}

  /// Code sent by verifyEmail/phoneVerify
  public var verificationCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _req: Appelis_Metro_SignIn_V1_PhoneVerifyRequest? = nil
}

public struct Appelis_Metro_SignIn_V1_LoginResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: Appelis_Metro_SignIn_V1_LoginResponse.OneOf_Payload? = nil

  public var error: Appelis_Metro_SignIn_V1_LoginResponse.Error {
    get {
      if case .error(let v)? = payload {return v}
      return .unknown
    }
    set {payload = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case error(Appelis_Metro_SignIn_V1_LoginResponse.Error)

  #if !swift(>=4.1)
    public static func ==(lhs: Appelis_Metro_SignIn_V1_LoginResponse.OneOf_Payload, rhs: Appelis_Metro_SignIn_V1_LoginResponse.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public enum Error: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unknown // = 0

    /// Invalid token or bad claims.
    case invalidToken // = 1

    /// cardEan can't be parsed or have bad data.
    case invalidCard // = 2

    /// Selected mobile user was not found.
    case mobileUserNotFound // = 3

    /// Verification code was not found or belongs to other user.
    case invalidVerificationCode // = 4

    /// Cardholder version doesn't match version on scanned card.
    case wrongCardVersion // = 5

    /// Block codes are set.
    case userBlocked // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .invalidToken
      case 2: self = .invalidCard
      case 3: self = .mobileUserNotFound
      case 4: self = .invalidVerificationCode
      case 5: self = .wrongCardVersion
      case 6: self = .userBlocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .invalidToken: return 1
      case .invalidCard: return 2
      case .mobileUserNotFound: return 3
      case .invalidVerificationCode: return 4
      case .wrongCardVersion: return 5
      case .userBlocked: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Appelis_Metro_SignIn_V1_LoginResponse.Error: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Appelis_Metro_SignIn_V1_LoginResponse.Error] = [
    .unknown,
    .invalidToken,
    .invalidCard,
    .mobileUserNotFound,
    .invalidVerificationCode,
    .wrongCardVersion,
    .userBlocked,
  ]
}

#endif  // swift(>=4.2)

/// Token from new AIP service, will be used in stateless verification flow.
public struct Appelis_Metro_SignIn_V1_AipToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Appelis_Metro_SignIn_V1_UpdateUsersCardsRequest: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_UpdateUsersCardsResponse: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_UpdateUsersCardsResponse.OneOf_Payload: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_LoginData: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_ArrayLoginData: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_ExportLoginResponse: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_ExportLoginResponse.OneOf_Payload: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_ExportLoginResponse.Error: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_EmailVerifyRequest: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_PhoneVerifyRequest: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_PhoneVerifyResponse: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_PhoneVerifyResponse.OneOf_Payload: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_PhoneVerifyResponse.Error: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_EmailVerifyResponse: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_EmailVerifyResponse.OneOf_Payload: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_EmailVerifyResponse.Error: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_FirebaseLoginRequest: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_FirebaseLoginResponse: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_FirebaseLoginResponse.OneOf_Payload: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_FirebaseLoginResponse.Error: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_LoginRequest: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_LoginResponse: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_LoginResponse.OneOf_Payload: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_LoginResponse.Error: @unchecked Sendable {}
extension Appelis_Metro_SignIn_V1_AipToken: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "appelis.metro.signIn.v1"

extension Appelis_Metro_SignIn_V1_UpdateUsersCardsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUsersCardsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .same(proto: "mobileUserIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufBool>.self, value: &self.mobileUserIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.mobileUserIds.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufBool>.self, value: self.mobileUserIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_UpdateUsersCardsRequest, rhs: Appelis_Metro_SignIn_V1_UpdateUsersCardsRequest) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.mobileUserIds != rhs.mobileUserIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_UpdateUsersCardsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUsersCardsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Metro_SignIn_V1_ExportLoginResponse.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .error(let v)? = self.payload {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_UpdateUsersCardsResponse, rhs: Appelis_Metro_SignIn_V1_UpdateUsersCardsResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_LoginData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "idProject"),
    3: .same(proto: "storeNo"),
    4: .same(proto: "custNo"),
    5: .same(proto: "chNo"),
    6: .same(proto: "advisorId"),
    7: .same(proto: "branchId"),
    8: .same(proto: "createdAt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.idProject) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.storeNo) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.custNo) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.chNo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.advisorID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.branchID) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.idProject.isEmpty {
      try visitor.visitSingularStringField(value: self.idProject, fieldNumber: 2)
    }
    if !self.storeNo.isEmpty {
      try visitor.visitSingularStringField(value: self.storeNo, fieldNumber: 3)
    }
    if !self.custNo.isEmpty {
      try visitor.visitSingularStringField(value: self.custNo, fieldNumber: 4)
    }
    if !self.chNo.isEmpty {
      try visitor.visitSingularStringField(value: self.chNo, fieldNumber: 5)
    }
    if !self.advisorID.isEmpty {
      try visitor.visitSingularStringField(value: self.advisorID, fieldNumber: 6)
    }
    if !self.branchID.isEmpty {
      try visitor.visitSingularStringField(value: self.branchID, fieldNumber: 7)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_LoginData, rhs: Appelis_Metro_SignIn_V1_LoginData) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.idProject != rhs.idProject {return false}
    if lhs.storeNo != rhs.storeNo {return false}
    if lhs.custNo != rhs.custNo {return false}
    if lhs.chNo != rhs.chNo {return false}
    if lhs.advisorID != rhs.advisorID {return false}
    if lhs.branchID != rhs.branchID {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_ArrayLoginData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArrayLoginData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_ArrayLoginData, rhs: Appelis_Metro_SignIn_V1_ArrayLoginData) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_ExportLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportLoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Metro_SignIn_V1_ExportLoginResponse.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      case 2: try {
        var v: Appelis_Metro_SignIn_V1_ArrayLoginData?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .data(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .error?: try {
      guard case .error(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_ExportLoginResponse, rhs: Appelis_Metro_SignIn_V1_ExportLoginResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_ExportLoginResponse.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INVALID_TOKEN"),
  ]
}

extension Appelis_Metro_SignIn_V1_EmailVerifyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmailVerifyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "req"),
    2: .same(proto: "businessId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._req) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.businessID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._req {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.businessID != 0 {
      try visitor.visitSingularInt64Field(value: self.businessID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_EmailVerifyRequest, rhs: Appelis_Metro_SignIn_V1_EmailVerifyRequest) -> Bool {
    if lhs._req != rhs._req {return false}
    if lhs.businessID != rhs.businessID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_PhoneVerifyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhoneVerifyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mobileUserId"),
    3: .same(proto: "cardEan"),
    4: .same(proto: "token"),
    5: .same(proto: "dryRun"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.mobileUserID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.cardEan) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.dryRun) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.mobileUserID != 0 {
      try visitor.visitSingularInt64Field(value: self.mobileUserID, fieldNumber: 1)
    }
    if !self.cardEan.isEmpty {
      try visitor.visitSingularStringField(value: self.cardEan, fieldNumber: 3)
    }
    try { if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.dryRun != false {
      try visitor.visitSingularBoolField(value: self.dryRun, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_PhoneVerifyRequest, rhs: Appelis_Metro_SignIn_V1_PhoneVerifyRequest) -> Bool {
    if lhs.mobileUserID != rhs.mobileUserID {return false}
    if lhs.cardEan != rhs.cardEan {return false}
    if lhs._token != rhs._token {return false}
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_PhoneVerifyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhoneVerifyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Metro_SignIn_V1_PhoneVerifyResponse.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .error(let v)? = self.payload {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_PhoneVerifyResponse, rhs: Appelis_Metro_SignIn_V1_PhoneVerifyResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_PhoneVerifyResponse.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INVALID_TOKEN"),
    2: .same(proto: "INVALID_CARD"),
    3: .same(proto: "MOBILE_USER_NOT_FOUND"),
    4: .same(proto: "PHONE_NUMBER_NOT_FOUND"),
    5: .same(proto: "WRONG_CARD_VERSION"),
    6: .same(proto: "FAILED_TO_SEND_SMS"),
    7: .same(proto: "USER_BLOCKED"),
  ]
}

extension Appelis_Metro_SignIn_V1_EmailVerifyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmailVerifyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Metro_SignIn_V1_EmailVerifyResponse.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .error(let v)? = self.payload {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_EmailVerifyResponse, rhs: Appelis_Metro_SignIn_V1_EmailVerifyResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_EmailVerifyResponse.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INVALID_TOKEN"),
    2: .same(proto: "INVALID_CARD"),
    3: .same(proto: "MOBILE_USER_NOT_FOUND"),
    4: .same(proto: "EMAIL_NOT_FOUND"),
    5: .same(proto: "WRONG_CARD_VERSION"),
    6: .same(proto: "USER_BLOCKED"),
  ]
}

extension Appelis_Metro_SignIn_V1_FirebaseLoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FirebaseLoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "req"),
    2: .same(proto: "firebaseIdToken"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._req) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.firebaseIDToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._req {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.firebaseIDToken.isEmpty {
      try visitor.visitSingularStringField(value: self.firebaseIDToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_FirebaseLoginRequest, rhs: Appelis_Metro_SignIn_V1_FirebaseLoginRequest) -> Bool {
    if lhs._req != rhs._req {return false}
    if lhs.firebaseIDToken != rhs.firebaseIDToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_FirebaseLoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FirebaseLoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Metro_SignIn_V1_FirebaseLoginResponse.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .error(let v)? = self.payload {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_FirebaseLoginResponse, rhs: Appelis_Metro_SignIn_V1_FirebaseLoginResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_FirebaseLoginResponse.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INVALID_TOKEN"),
    2: .same(proto: "INVALID_CARD"),
    3: .same(proto: "MOBILE_USER_NOT_FOUND"),
    4: .same(proto: "INVALID_FIREBASE_TOKEN"),
    5: .same(proto: "WRONG_CARD_VERSION"),
    6: .same(proto: "USER_BLOCKED"),
  ]
}

extension Appelis_Metro_SignIn_V1_LoginRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "req"),
    2: .same(proto: "verificationCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._req) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.verificationCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._req {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.verificationCode.isEmpty {
      try visitor.visitSingularStringField(value: self.verificationCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_LoginRequest, rhs: Appelis_Metro_SignIn_V1_LoginRequest) -> Bool {
    if lhs._req != rhs._req {return false}
    if lhs.verificationCode != rhs.verificationCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_LoginResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoginResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Appelis_Metro_SignIn_V1_LoginResponse.Error?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.payload != nil {try decoder.handleConflictingOneOf()}
          self.payload = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .error(let v)? = self.payload {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_LoginResponse, rhs: Appelis_Metro_SignIn_V1_LoginResponse) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Metro_SignIn_V1_LoginResponse.Error: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INVALID_TOKEN"),
    2: .same(proto: "INVALID_CARD"),
    3: .same(proto: "MOBILE_USER_NOT_FOUND"),
    4: .same(proto: "INVALID_VERIFICATION_CODE"),
    5: .same(proto: "WRONG_CARD_VERSION"),
    6: .same(proto: "USER_BLOCKED"),
  ]
}

extension Appelis_Metro_SignIn_V1_AipToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AipToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Metro_SignIn_V1_AipToken, rhs: Appelis_Metro_SignIn_V1_AipToken) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
