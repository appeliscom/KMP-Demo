// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: newsfeed_service/newsfeedService.data.v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Appelis_Newsfeed_Data_V1_NewsFeedItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Appelis_ObjectId {
    get {return _storage._id ?? Appelis_ObjectId()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  public var index: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _storage._index ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_uniqueStorage()._index = newValue}
  }
  /// Returns true if `index` has been explicitly set.
  public var hasIndex: Bool {return _storage._index != nil}
  /// Clears the value of `index`. Subsequent reads from it will return its default value.
  public mutating func clearIndex() {_uniqueStorage()._index = nil}

  public var author: Appelis_Newsfeed_Data_V1_NewsFeedItem.Author {
    get {return _storage._author ?? Appelis_Newsfeed_Data_V1_NewsFeedItem.Author()}
    set {_uniqueStorage()._author = newValue}
  }
  /// Returns true if `author` has been explicitly set.
  public var hasAuthor: Bool {return _storage._author != nil}
  /// Clears the value of `author`. Subsequent reads from it will return its default value.
  public mutating func clearAuthor() {_uniqueStorage()._author = nil}

  public var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  public var perex: String {
    get {return _storage._perex}
    set {_uniqueStorage()._perex = newValue}
  }

  public var body: SwiftProtobuf.Google_Protobuf_BytesValue {
    get {return _storage._body ?? SwiftProtobuf.Google_Protobuf_BytesValue()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {_uniqueStorage()._body = nil}

  public var businessIds: Appelis_Newsfeed_Data_V1_NewsFeedItem.BusinessIds {
    get {return _storage._businessIds ?? Appelis_Newsfeed_Data_V1_NewsFeedItem.BusinessIds()}
    set {_uniqueStorage()._businessIds = newValue}
  }
  /// Returns true if `businessIds` has been explicitly set.
  public var hasBusinessIds: Bool {return _storage._businessIds != nil}
  /// Clears the value of `businessIds`. Subsequent reads from it will return its default value.
  public mutating func clearBusinessIds() {_uniqueStorage()._businessIds = nil}

  public var pictures: [Appelis_Picture] {
    get {return _storage._pictures}
    set {_uniqueStorage()._pictures = newValue}
  }

  public var dates: Appelis_Newsfeed_Data_V1_NewsFeedItem.Dates {
    get {return _storage._dates ?? Appelis_Newsfeed_Data_V1_NewsFeedItem.Dates()}
    set {_uniqueStorage()._dates = newValue}
  }
  /// Returns true if `dates` has been explicitly set.
  public var hasDates: Bool {return _storage._dates != nil}
  /// Clears the value of `dates`. Subsequent reads from it will return its default value.
  public mutating func clearDates() {_uniqueStorage()._dates = nil}

  public var validity: Appelis_TimeRange {
    get {return _storage._validity ?? Appelis_TimeRange()}
    set {_uniqueStorage()._validity = newValue}
  }
  /// Returns true if `validity` has been explicitly set.
  public var hasValidity: Bool {return _storage._validity != nil}
  /// Clears the value of `validity`. Subsequent reads from it will return its default value.
  public mutating func clearValidity() {_uniqueStorage()._validity = nil}

  public var display: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._display ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._display = newValue}
  }
  /// Returns true if `display` has been explicitly set.
  public var hasDisplay: Bool {return _storage._display != nil}
  /// Clears the value of `display`. Subsequent reads from it will return its default value.
  public mutating func clearDisplay() {_uniqueStorage()._display = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct BusinessIds {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var businessIds: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Dates {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var created: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _created ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_created = newValue}
    }
    /// Returns true if `created` has been explicitly set.
    public var hasCreated: Bool {return self._created != nil}
    /// Clears the value of `created`. Subsequent reads from it will return its default value.
    public mutating func clearCreated() {self._created = nil}

    public var modified: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _modified ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_modified = newValue}
    }
    /// Returns true if `modified` has been explicitly set.
    public var hasModified: Bool {return self._modified != nil}
    /// Clears the value of `modified`. Subsequent reads from it will return its default value.
    public mutating func clearModified() {self._modified = nil}

    public var published: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _published ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_published = newValue}
    }
    /// Returns true if `published` has been explicitly set.
    public var hasPublished: Bool {return self._published != nil}
    /// Clears the value of `published`. Subsequent reads from it will return its default value.
    public mutating func clearPublished() {self._published = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _created: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _modified: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _published: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public struct Author {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _id ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Appelis_Newsfeed_Data_V1_NewsFeedItem: @unchecked Sendable {}
extension Appelis_Newsfeed_Data_V1_NewsFeedItem.BusinessIds: @unchecked Sendable {}
extension Appelis_Newsfeed_Data_V1_NewsFeedItem.Dates: @unchecked Sendable {}
extension Appelis_Newsfeed_Data_V1_NewsFeedItem.Author: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "appelis.newsfeed.data.v1"

extension Appelis_Newsfeed_Data_V1_NewsFeedItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewsFeedItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "index"),
    3: .same(proto: "author"),
    4: .same(proto: "title"),
    5: .same(proto: "perex"),
    6: .same(proto: "body"),
    7: .standard(proto: "business_ids"),
    8: .same(proto: "pictures"),
    9: .same(proto: "dates"),
    10: .same(proto: "validity"),
    11: .same(proto: "display"),
  ]

  fileprivate class _StorageClass {
    var _id: Appelis_ObjectId? = nil
    var _index: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    var _author: Appelis_Newsfeed_Data_V1_NewsFeedItem.Author? = nil
    var _title: String = String()
    var _perex: String = String()
    var _body: SwiftProtobuf.Google_Protobuf_BytesValue? = nil
    var _businessIds: Appelis_Newsfeed_Data_V1_NewsFeedItem.BusinessIds? = nil
    var _pictures: [Appelis_Picture] = []
    var _dates: Appelis_Newsfeed_Data_V1_NewsFeedItem.Dates? = nil
    var _validity: Appelis_TimeRange? = nil
    var _display: SwiftProtobuf.Google_Protobuf_BoolValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _index = source._index
      _author = source._author
      _title = source._title
      _perex = source._perex
      _body = source._body
      _businessIds = source._businessIds
      _pictures = source._pictures
      _dates = source._dates
      _validity = source._validity
      _display = source._display
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._index) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._author) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._perex) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._body) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._businessIds) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._pictures) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._dates) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._validity) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._display) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._index {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._author {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 4)
      }
      if !_storage._perex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._perex, fieldNumber: 5)
      }
      try { if let v = _storage._body {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._businessIds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._pictures.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pictures, fieldNumber: 8)
      }
      try { if let v = _storage._dates {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._validity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._display {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Newsfeed_Data_V1_NewsFeedItem, rhs: Appelis_Newsfeed_Data_V1_NewsFeedItem) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._index != rhs_storage._index {return false}
        if _storage._author != rhs_storage._author {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._perex != rhs_storage._perex {return false}
        if _storage._body != rhs_storage._body {return false}
        if _storage._businessIds != rhs_storage._businessIds {return false}
        if _storage._pictures != rhs_storage._pictures {return false}
        if _storage._dates != rhs_storage._dates {return false}
        if _storage._validity != rhs_storage._validity {return false}
        if _storage._display != rhs_storage._display {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Newsfeed_Data_V1_NewsFeedItem.BusinessIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_Newsfeed_Data_V1_NewsFeedItem.protoMessageName + ".BusinessIds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "business_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.businessIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.businessIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.businessIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Newsfeed_Data_V1_NewsFeedItem.BusinessIds, rhs: Appelis_Newsfeed_Data_V1_NewsFeedItem.BusinessIds) -> Bool {
    if lhs.businessIds != rhs.businessIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Newsfeed_Data_V1_NewsFeedItem.Dates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_Newsfeed_Data_V1_NewsFeedItem.protoMessageName + ".Dates"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "created"),
    2: .same(proto: "modified"),
    3: .same(proto: "published"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._created) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._modified) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._published) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._created {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._modified {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._published {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Newsfeed_Data_V1_NewsFeedItem.Dates, rhs: Appelis_Newsfeed_Data_V1_NewsFeedItem.Dates) -> Bool {
    if lhs._created != rhs._created {return false}
    if lhs._modified != rhs._modified {return false}
    if lhs._published != rhs._published {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Appelis_Newsfeed_Data_V1_NewsFeedItem.Author: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Appelis_Newsfeed_Data_V1_NewsFeedItem.protoMessageName + ".Author"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Appelis_Newsfeed_Data_V1_NewsFeedItem.Author, rhs: Appelis_Newsfeed_Data_V1_NewsFeedItem.Author) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
