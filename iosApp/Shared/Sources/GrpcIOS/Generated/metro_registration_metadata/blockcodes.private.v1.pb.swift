// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: metro_registration_metadata/blockcodes.private.v1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Metro_Blockcodes_V1_CardholderStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// (neaktivní)
  case inactive // = 5

  /// (zrušen)
  case canceled // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 5: self = .inactive
    case 9: self = .canceled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .inactive: return 5
    case .canceled: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Blockcodes_V1_CardholderStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Blockcodes_V1_CardholderStatus] = [
    .unknown,
    .inactive,
    .canceled,
  ]
}

#endif  // swift(>=4.2)

public enum Metro_Blockcodes_V1_CardholderBlockCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// (krádež v obchode)
  case s // = 1

  /// (ztracená nebo ukradnuta karta)
  case l // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .s
    case 2: self = .l
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .s: return 1
    case .l: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Blockcodes_V1_CardholderBlockCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Blockcodes_V1_CardholderBlockCode] = [
    .unknown,
    .s,
    .l,
  ]
}

#endif  // swift(>=4.2)

public enum Metro_Blockcodes_V1_CustomerStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// (neaktivní)
  case inactive // = 5

  /// (zrušen)
  case canceled // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 5: self = .inactive
    case 9: self = .canceled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .inactive: return 5
    case .canceled: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Blockcodes_V1_CustomerStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Blockcodes_V1_CustomerStatus] = [
    .unknown,
    .inactive,
    .canceled,
  ]
}

#endif  // swift(>=4.2)

public enum Metro_Blockcodes_V1_CustomerBlockCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unknown // = 0

  /// (krádež v obchode)
  case s // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .s
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .s: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Metro_Blockcodes_V1_CustomerBlockCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Metro_Blockcodes_V1_CustomerBlockCode] = [
    .unknown,
    .s,
  ]
}

#endif  // swift(>=4.2)

public struct Metro_Blockcodes_V1_GetCardholderBlockCodesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [Metro_Common_Data_V1_CardholderId] = []

  public var projectID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Blockcodes_V1_BlockCodes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userCodes: Metro_Blockcodes_V1_CardholderBlockCodes {
    get {return _userCodes ?? Metro_Blockcodes_V1_CardholderBlockCodes()}
    set {_userCodes = newValue}
  }
  /// Returns true if `userCodes` has been explicitly set.
  public var hasUserCodes: Bool {return self._userCodes != nil}
  /// Clears the value of `userCodes`. Subsequent reads from it will return its default value.
  public mutating func clearUserCodes() {self._userCodes = nil}

  public var companyCodes: Metro_Blockcodes_V1_CompanyBlockCodes {
    get {return _companyCodes ?? Metro_Blockcodes_V1_CompanyBlockCodes()}
    set {_companyCodes = newValue}
  }
  /// Returns true if `companyCodes` has been explicitly set.
  public var hasCompanyCodes: Bool {return self._companyCodes != nil}
  /// Clears the value of `companyCodes`. Subsequent reads from it will return its default value.
  public mutating func clearCompanyCodes() {self._companyCodes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userCodes: Metro_Blockcodes_V1_CardholderBlockCodes? = nil
  fileprivate var _companyCodes: Metro_Blockcodes_V1_CompanyBlockCodes? = nil
}

public struct Metro_Blockcodes_V1_IdBlockCode {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Metro_Common_Data_V1_CardholderId {
    get {return _id ?? Metro_Common_Data_V1_CardholderId()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var blockCodes: Metro_Blockcodes_V1_BlockCodes {
    get {return _blockCodes ?? Metro_Blockcodes_V1_BlockCodes()}
    set {_blockCodes = newValue}
  }
  /// Returns true if `blockCodes` has been explicitly set.
  public var hasBlockCodes: Bool {return self._blockCodes != nil}
  /// Clears the value of `blockCodes`. Subsequent reads from it will return its default value.
  public mutating func clearBlockCodes() {self._blockCodes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Metro_Common_Data_V1_CardholderId? = nil
  fileprivate var _blockCodes: Metro_Blockcodes_V1_BlockCodes? = nil
}

public struct Metro_Blockcodes_V1_GetCardholderBlockCodesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Metro_Blockcodes_V1_IdBlockCode] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Blockcodes_V1_CardholderBlockCodes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Metro_Blockcodes_V1_CardholderStatus = .unknown

  public var blockCode: Metro_Blockcodes_V1_CardholderBlockCode = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Metro_Blockcodes_V1_CompanyBlockCodes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Metro_Blockcodes_V1_CustomerStatus = .unknown

  public var blockCode: Metro_Blockcodes_V1_CustomerBlockCode = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Metro_Blockcodes_V1_CardholderStatus: @unchecked Sendable {}
extension Metro_Blockcodes_V1_CardholderBlockCode: @unchecked Sendable {}
extension Metro_Blockcodes_V1_CustomerStatus: @unchecked Sendable {}
extension Metro_Blockcodes_V1_CustomerBlockCode: @unchecked Sendable {}
extension Metro_Blockcodes_V1_GetCardholderBlockCodesRequest: @unchecked Sendable {}
extension Metro_Blockcodes_V1_BlockCodes: @unchecked Sendable {}
extension Metro_Blockcodes_V1_IdBlockCode: @unchecked Sendable {}
extension Metro_Blockcodes_V1_GetCardholderBlockCodesResponse: @unchecked Sendable {}
extension Metro_Blockcodes_V1_CardholderBlockCodes: @unchecked Sendable {}
extension Metro_Blockcodes_V1_CompanyBlockCodes: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "metro.blockcodes.v1"

extension Metro_Blockcodes_V1_CardholderStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CARDHOLDER_STATUS_UNKNOWN"),
    5: .same(proto: "CARDHOLDER_STATUS_INACTIVE"),
    9: .same(proto: "CARDHOLDER_STATUS_CANCELED"),
  ]
}

extension Metro_Blockcodes_V1_CardholderBlockCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CARDHOLDER_BLOCK_CODE_UNKNOWN"),
    1: .same(proto: "CARDHOLDER_BLOCK_CODE_S"),
    2: .same(proto: "CARDHOLDER_BLOCK_CODE_L"),
  ]
}

extension Metro_Blockcodes_V1_CustomerStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOMER_STATUS_UNKNOWN"),
    5: .same(proto: "CUSTOMER_STATUS_INACTIVE"),
    9: .same(proto: "CUSTOMER_STATUS_CANCELED"),
  ]
}

extension Metro_Blockcodes_V1_CustomerBlockCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CUSTOMER_BLOCK_CODE_UNKNOWN"),
    1: .same(proto: "CUSTOMER_BLOCK_CODE_S"),
  ]
}

extension Metro_Blockcodes_V1_GetCardholderBlockCodesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCardholderBlockCodesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "projectId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Blockcodes_V1_GetCardholderBlockCodesRequest, rhs: Metro_Blockcodes_V1_GetCardholderBlockCodesRequest) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Blockcodes_V1_BlockCodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockCodes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "userCodes"),
    2: .same(proto: "companyCodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userCodes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._companyCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userCodes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._companyCodes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Blockcodes_V1_BlockCodes, rhs: Metro_Blockcodes_V1_BlockCodes) -> Bool {
    if lhs._userCodes != rhs._userCodes {return false}
    if lhs._companyCodes != rhs._companyCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Blockcodes_V1_IdBlockCode: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IdBlockCode"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "blockCodes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._blockCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._blockCodes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Blockcodes_V1_IdBlockCode, rhs: Metro_Blockcodes_V1_IdBlockCode) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._blockCodes != rhs._blockCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Blockcodes_V1_GetCardholderBlockCodesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCardholderBlockCodesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Blockcodes_V1_GetCardholderBlockCodesResponse, rhs: Metro_Blockcodes_V1_GetCardholderBlockCodesResponse) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Blockcodes_V1_CardholderBlockCodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CardholderBlockCodes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "blockCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.blockCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.blockCode != .unknown {
      try visitor.visitSingularEnumField(value: self.blockCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Blockcodes_V1_CardholderBlockCodes, rhs: Metro_Blockcodes_V1_CardholderBlockCodes) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.blockCode != rhs.blockCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Metro_Blockcodes_V1_CompanyBlockCodes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompanyBlockCodes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "blockCode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.blockCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if self.blockCode != .unknown {
      try visitor.visitSingularEnumField(value: self.blockCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Metro_Blockcodes_V1_CompanyBlockCodes, rhs: Metro_Blockcodes_V1_CompanyBlockCodes) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.blockCode != rhs.blockCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
